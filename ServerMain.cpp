// ServerMain.cpp: implementation of the CServerMain class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "math.h"
#include "OLASkeleton.h"
#include "OLAPositiveSrv.h"
#include "OLATcpBase.h"
#include "OLARouteSrv.h"
#include "OLAPositiveEventSrv.h"
#include "OLAPositive_FIPAYSrv.h"
#include "OLAProgressSrv.h"
#include "OLATcpPositiveSrv.h"
#include "OLA32Srv.h"
#include "OLA32EventSrv.h"
#include "OLAPositiveIFSF.h"
#include "OLASimulator.h"
#include "OLATravelCenter.h"
#include "AlarmConvert.h"
#include "CashAcceptor.h"  //4.0.1.38
#include "DelayedPrePay.h"
#include "OLAProgressSrvEx.h"//4.0.12.505
#include "OLADotNet.h"	//4.0.16.504
#include "StoreLineOLA.h"	//TD 42728
#include "OlaSimLinkSrv.h"  //TD 27377 4.0.20.500
#include "OLAPositiveUS.h"
#include "OLAEServiceSRV.h"
#include "TimeOutManager.h" // 4.0.23.1050 TD 233242
#include "OLAConnectedPayments.h"
#include "OLAEps.h"
#include "OLAEpsilon.h"
#include "OLAEpsilonDiscount.h" // RFUEL-2817
#include "TaxCalc.h"
#include "MutipleTaxCalculator.h"
#include "CandianTaxCalc.h"
#include "CarWash.h"
#include "SQLReceiptDB.h"
#include "PumpSrvDatabase.h"
#include "PumpSrvDatabaseLogger.h"
#include "SQLPumpSrvFile.h"
#include "SQLAlarmFile.h"
#include "TimingProfiling.h"
#include "ProductVersion.h"
#include "CStrFormat.h"


typedef struct 
{
	BYTE				sFileValid[sizeof(PUMP_INFO)];
	PUMP_INFO			p[MAX_PUMPS];
	PAY_AT_PUMP_INFO	pap[MAX_PUMPS];
	SERVER_INFO			serverInfo; 
	SHIFT_REC			currentShift; 
}OLD_PUMP_FILE;

// ServerMain.cpp: implementation of the CServerMain class.

 
#ifdef USE_XML_PRICE_CHANGE
#include "XMLInterface.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MILLISECONDS_IN_A_SECOND 1000

#define DELIVERY_START_AFTER_START       93
#define DELIVERY_END_AFTER_END           94

const int CServerMain::RECONFIGURE_TIMEOUT = 60000;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServerMain::CServerMain():m_cCompChecker("PumpSrv"),
							m_cOLASrv(0),
							m_bAllowPAKFinalizationWhenSytemDown(FALSE),
   							m_bServerInRecoveryProcess(TRUE),
							m_ulRegisteredReconfigureEvents(0),
							m_bReconfigureRequestWasSent(FALSE),
							m_dwLastReconfigureRequestTime(0),
							m_bOLAEpsilonSupport(FALSE)						
{	
	//InitializeCriticalSection(&m_csPumpArray);	
	InitializeCriticalSection(&m_csMemPumpArray);
	InitializeCriticalSection(&m_csModeSchemeArray);
	InitializeCriticalSection(&m_csReportArray);
	//InitializeCriticalSection(&m_csQDXMaintenance);
	InitializeCriticalSection(&m_csGetCardInfoEx); //4.0.19.0
	InitializeCriticalSection(&m_csNewOLAServer);

	m_lCtrlEventNumerator = 0;
	
	m_dwRunningValueThreshold = 0;
	m_dwEnhancedRollingUpdate = 0;
	m_dwSeverityAlarmsCount = 0;
	m_lRcvSetShiftCommand = NOT_RCV_SET_SHIFT; //4.0.13.501
	m_lPriceChangePOSMsg = 0;                  //4.0.27.42

	m_bAutoReconcileProcess = FALSE; // 4.0.23.1050 TD 233242
	
	for (long lPumpNum=0;lPumpNum<MAX_PUMPS_64;lPumpNum++)
	{
		m_lPAPDeclineTimer[lPumpNum] = 0;
	}

	//Reset the response of the price change 
	SetPriceChangeResponse(PRICE_CHANGE_NO_RESPONSE);
	
	memset(&m_cCvmListInfo, ' ', sizeof(m_cCvmListInfo));	//4.0.20.20

	m_bPAPEnabledOLA = TRUE;//4.0.21.13 68756

	m_bAllowAuthOnNonRequestPapResPumpCL = FALSE; //4.0.21.500 TD 69683

	m_AllowAuthOnStopByController = FALSE; //4.0.202.511
	m_bRedundancyByCL = FALSE;				//4.0.20.913

	m_bQdxEmptied = FALSE;					//4.0.27.500  TD 236009
	m_bShiftStateUnlockHandled = 0;			//4.0.29.0 - TD 241916

	m_lGradePriceMinimumLimit = 0;	// CR 438993
	memset(m_lNumberOfTendersAuthorized,0,sizeof(m_lNumberOfTendersAuthorized));
	SetDBAlaram(FALSE);
}

CServerMain::~CServerMain()
{

}

BOOL CServerMain::InitServer(BOOL bRun)
{
	DWORD dwTmp = 0;
	int i;
	CRegTable cReg;
	CThreadRetCode eThreadRetCode = THREAD_OK;

	CheckIfAnotherPumpSrvIsRunning();		//4.0.5.26

	// TD 389177 - Start

	m_cLogger.SystemUp();

	if(LOG_BASIC_FLOW_CONTROL)
	{	
		m_cLogger.LogMsg("________________________________________________________");
		m_cLogger.LogMsg("Server Started!");	
		m_cLogger.LogMsg(PUMPSRV_VERSION);	
	}

	if (bRun) 
	{
		CPumpSrvDatabase & PumpSrvDatabase = CPumpSrvDatabase::GetInstance();
		PumpSrvDatabase.AddCallBack(&CPumpSrvDatabaseLogger::GetInstance());
		BOOL bDatabaseInitializedSuccessfully = PumpSrvDatabase.Initialize();
		
		if (FALSE == bDatabaseInitializedSuccessfully) 
		{
			m_cLogger.LogMsg("Database wasn't initialized successfully. exiting", LOG_LEVEL_1);
			return FALSE;
		}

		CString FuelMsSqlVerion;
		PumpSrvDatabase.GetFuelMsSqlVersion(FuelMsSqlVerion);
		m_cLogger.LogMsg(FuelMsSqlVerion);
		m_cLogger.LogMsg("InitServer - Start");
	}

	CreateEventThread();
	CreateAlarmSrvThread();   //4.0.1.40

	// This is the size of each pump in pump stat:
	// size_t x = sizeof(PUMP_INFO) + sizeof(SERVER_INFO) + sizeof(SHIFT_REC) + sizeof(PAY_AT_PUMP_INFO);
	// this is ~ 10KB per pump

	/*
	size_t x1 = sizeof(CARD_SALE_INFO_);
	size_t x2 = sizeof(CARD_SALE_EXTRA_DATA2_);
	size_t x3 = sizeof(CARD_SALE_EXTRA_DATA3_);
	size_t x4 = sizeof(CARD_SALE_EXTRA_DATA4_);
	size_t x5 = sizeof(CARD_SALE_EXTRA_DATA5_);
	size_t trs = sizeof(CPumpTransact);
	size_t x6 = sizeof(CARD_SALE_EXTRA_DATA6_);
	size_t x = sizeof(PAY_AT_PUMP_INFO);
	*/
	// TD 389177 - End

	/*
	LONG			m_lNumber;
	BYTE			m_sPumpMenufacture[MAX_NAME_LENGTH];	
	LONG			m_lType;					
	CPumpTransact	m_cTrs[MAX_TRS_IN_LIST];
	OLA_STAT		m_cOLA;	
	CPumpStatus		m_cPumpStat;
	LockStatus		m_lLockStatus;
	long			m_lShiftNumber;
	TAG_SYSTEMTIME  m_cLastTimeUpdate; //14

	size_t x1 = sizeof(m_lNumber);
	size_t x2 = sizeof(m_sPumpMenufacture);
	size_t x3 = sizeof(m_lType);
	size_t x4 = sizeof(m_cTrs);
	size_t x5 = sizeof(m_cOLA);
	size_t x6 = sizeof(m_cPumpStat);
	size_t x7 = sizeof(m_lLockStatus);
	size_t x8 = sizeof(m_lShiftNumber);
	size_t x9 = sizeof(m_cLastTimeUpdate);
	size_t x10 = sizeof(CPumpTransact);
	*/


	///////////////////////////////
	
	memset(m_cShortCardTrsArr , ' ', sizeof(m_cShortCardTrsArr));  //4.0.12.518

	// On registry stage change the log level to 0
	if (!bRun)
	{
		m_cLogger.SetLogLevel(0);   //4.0.5.38
		m_cLogger.LogMsg("PumpSrv registration started!");
	}

	SetServerState(SERVER_NO_CONVERT);
	
	SetCLIsGone(FALSE);						//4.0.20.507 TD 89047
	ClearShowGPIMsgCLIsGone();				//4.0.20.950 TD 97894

	SetOperatingMode(NULL_MODE);
	GetVersion();

	SetApplicationToHighPriority();	

	cReg.LoadPumpSrvInternalParams();

	//Set Pumpsrv to work with a single cpu (core) - this method must core after LoadPumpSrvInternalParams
	SetApplicationSingleCore();    //4.0.24.90 TD 106227

	cReg.LoadForecourtLockConfiguration();
	cReg.LoadGeneralParamSubTable(ALL_TABLES, TRUE, FALSE);
	cReg.LoadFuelLoyalty(TRUE, FALSE);
	cReg.LoadFuelFlowControl(TRUE, FALSE, FALSE);//4.0.19.508 //4.0.22.504 69344
	cReg.LoadMultiSync(FALSE, FALSE); //4.0.14.502


	// Message Number generator:
	m_lMessageNumber = 0;
	m_lWatchdogCount = 0;
	
	ConvertPumpInfo2TerminalInfo();

	//Connect to Encrypt/Decrypt
	if(bRun) 
	{
		InitFuelEncryption();	// TD 347994
	}

	cReg.LoadTerminalTable(TRUE , FALSE);
	cReg.LoadIPTTable(TRUE , FALSE);

	cReg.LoadDispensersTable(0 , TRUE , FALSE , bRun);
	
	cReg.LoadModeSchemeTable(bRun);

	//4.0.1.32 - from this version on, do not change order
	//of LoadGradesTable and LoadPumpsTable and the terminal initialization
	//methods, because the devices per pump information (CCtrl::GetPumpDevices)
	//depends on this order.
	
	cReg.LoadGradesTable(TRUE , FALSE , bRun);

	cReg.LoadWashProgramsTable(TRUE , FALSE , bRun);

	cReg.LoadPureProductsTable(TRUE , FALSE , bRun);
	
	cReg.LoadShiftsTable(TRUE , FALSE , bRun);

	cReg.LoadReceiptTable(TRUE , FALSE , bRun);

	cReg.LoadScreenLayoutsTable(TRUE , FALSE , bRun);

	cReg.LoadModesTable(TRUE , FALSE , bRun);

	cReg.LoadLanguagesTable(TRUE , FALSE , bRun); //4.0.5.42

	cReg.LoadDatabaseTable(TRUE , FALSE , bRun);
		
	cReg.LoadServiceFeeTable(TRUE , FALSE , bRun);
	
	cReg.LoadPumpsTable(0 , TRUE , FALSE , bRun);
	
	cReg.LoadBankNoteTable(TRUE , FALSE , bRun);	// 4.0.3.60

	if(LOG_BASIC_FLOW_CONTROL)
		LogServerStatsOnStartup();
	
	// Init Reconfigure in EOS
	SetReconfigureInEOSRegistry (FALSE);


	m_cShiftLog.Init();
	
	m_cTrsLog.Init();	//4.0.3.39

	m_cStuckTrsLog.Init(); // 4.0.24.770  TD 275612

	m_cBuildLine2PosPump.Init(); //4.0.22.10 TD 71055
	
	CPosInfo newPos(SERVER_POS_NUMBER,GPI_LATEST_VERSION);
	CSingleLock slPosMap( &m_csPosMap );

	slPosMap.Lock(INFINITE);
	m_cPosMap.SetAt(SERVER_POS_NUMBER,newPos);

	// Create Event For Requesting Receipt Form Cl2PumpSrv
	newPos.CreateEventReceipt();   
	m_cPosMap.SetAt(SERVER_POS_NUMBER,newPos);
	slPosMap.Unlock();

	//m_cCashAcceptorFile.CheckSignitureFile(); // RFuel-292

    // ------------- Mode---------------//
	// Create adn load mode table
	//----------------------------------//
	m_cModeArray.SetSize( MAX_MODES ) ;	
	for(int m=0; m < MAX_MODES; m++)
	{
		m_cModeArray[m].SetNumber(m+1);
		m_cModeArray[m].LoadDefinition();
	}
	
	// -------------- Car Wash -------------- //
	//Create and load Car Wash parameters
	m_cCarWash.LoadCarWashDefinition();
	m_cCarWashGeneralRequest.LoadCarWashDefinition();	//4.0.23.504 76432

	//Load the requests and the cancels lists
	m_cCarWash.InitCarWashLists();
	// -------------------------------------- //

	cReg.LoadTanksTable(TRUE , FALSE , bRun);

	// -------------- Tanks Info -------------- //
	//Create and sets Tanks Info array
	m_cTankArray.SetSize( MAX_TANKS ) ;

	for(long tn = 0; tn < MAX_TANKS; tn++)
	{
		m_cTankArray[tn].SetTankNumber(tn+1);
		m_cTankArray[tn].LoadDeliveryEmulationInfo();	//4.0.20.52
		m_cTankArray[tn].UpdateCanIncDeliveryEmulationSales();	//4.0.19.1260 - TD 242013
	}
	//Load the connected pumps into each tank within the Tanks Info array
	LoadTanksConnectedPumps(); //TD 66935

	m_cServiceFeeArray.SetSize( MAX_SERVICE_FEE) ;
	for(i=0; i < MAX_SERVICE_FEE; i++)
	{	
		m_cServiceFeeArray[i].SetNumber(i+1);
		m_cServiceFeeArray[i].LoadDefinition();
	}

	m_cReportArray.SetSize( MAX_REPORTS );
	m_cDebitInfoArray.SetSize(MAX_PUMPS_64); 

	cReg.LoadPathsTable(TRUE , FALSE);
	
	CreateOLAServer();
	CreateBaseReceipt();//4.0.9.503		//4.0.20.501 TD 60236

	CreateTaxCalcator();

	//Create map of grades per pump
	//use for tank level protection
	m_cTankLevelMap.LoadTankMapPerPump();//4.0.9.506 //amram
	
	if(bRun) //4.0.3.49
		ConnectToHydService();

	InitDebitShiftParameter();

	if((m_cLogger.GetLogLevel() == LOG_LEVEL_5) && (bRun))
		m_cLogger.RedirectIOToConsole();

	cReg.LoadPricePolesTable(TRUE , FALSE);

	cReg.LoadANPRTable(TRUE , FALSE); //4.0.26.505 147073

	cReg.LoadTaxesTable(TRUE , FALSE);
	cReg.LoadTerminalSrvParams(TRUE);

	

	UpdateBlenderCount();

	//Setting the state machine of the exclusively locked pumps 
	m_cSinglePumpLock.SetInitiallyLockedPumps(0);

	LoadStatePumpLockByMode();

	LoadConfigurationThread(TRUE);			//4.0.22.45 TD 72716

	
	// Update Server with current PC time,  //4.0.1.35
	SYSTEMTIME cCurrentTime;
	GetLocalTime(&cCurrentTime);
	m_cPrevSysTime = cCurrentTime;

	//4.0.1.38 connect to VP
	if(m_dwVpActive && bRun)//4.0.3.49
		CreateVPThread();
    SetVpIsGone(FALSE);  // 1.0.29.500    TD 264908  
	SetQdxIsGone(FALSE); // 4.0.29.501    TD 288369

	//Connect to AlarmSrv 
	if(bRun) //4.0.3.49
	{
		ConnectToAlarmSrv();  //4.0.0.78
	}

	if(bRun)
	{
		KillDataExportSrvAndAgent(); //4.0.21.0
		
		ConnectToDataExport();		

		ConnectToIFSFTerminalSrv();			//4.0.12.503

		ConnectToFuelMobileSrv();	// CR 474446
		CreateFuelMobileSrvThread();
		
		m_lReloadQDXShiftsCounter = 0; 
		m_bIsInTheMiddleOfDoAutomaticReceiptCheck = FALSE;

		//CreateQDXMaintenanceThread(); //4.0.18.0		

 		if(CreateConfigurationThread() == TRUE)				//4.0.22.45 TD 72716
			StartConfigurationThread();						//4.0.22.60 TD 72716
	}

	//reset misc flag MISC_CREDIT_CARD_NOT_AUTHORIZED. 
	long lPumpNum;
	CPumpStatus pumpStat;
	long lMisc;

	for (lPumpNum = 0; lPumpNum < m_cPumpArray.GetSize(); lPumpNum++)
	{
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		lMisc = pumpStat.GetMisc();

		if (lMisc & MISC_CREDIT_CARD_DECLINE)
		{
			lMisc &= MISC_NOT_CREDIT_CARD_DECLINE;

			m_cCommonFunction.ResetMiscCardNotAuthorized(lMisc);
			
			pumpStat.SetMisc(lMisc);
			m_cPumpArray[lPumpNum].SetStat(pumpStat);			
		}
	}

	if (m_bPresentCardName)
		LoadShortCardNameFromQDX();

	//In case we were in the middle of price change - perform rollback.
	if (m_cServerInfo.GetInPriceChangeProcess() && !m_cServerInfo.IsInPriceChangeWithIntegrityProcess())	//4.0.27.20 147183
	{
		RollbackPriceChange();	
		//End of price change process
		SetInPriceChangeProcess(FALSE); 
		m_cServerInfo.SetInPriceChangeWithIntegrityProcessFlags(PRICE_CHANGE_WITH_INTEGRITY_NONE); 
		SetPriceChangeBatchNumber(0);		
	}
	if (m_cServerInfo.IsInPriceChangeWithIntegrityProcess()) //reload the batch id after recovery
	{
		DWORD dwTmp = 0;
		m_cParam.LoadParam("GeneralParam", "PriceChangeBatchNumber",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE); 	
		SetPriceChangeBatchNumber(dwTmp);
	}

	SetStartupBaseTotalsUpdate(TRUE);	//47235	4.0.19.502

	//4.0.25.50 - TD 108311
	if (GetSingleShiftAccumulationsActive())
		m_cSingleShiftAccumMgr.LoadDataFromDB();

	SetDBAlaram(FALSE);

	m_cLogger.LogMsg("InitServer - Finish" );
	return TRUE;
}

BOOL CServerMain::IsRegistredReconfigureEvents()
{
	return (0 != m_ulRegisteredReconfigureEvents);
}

void CServerMain::SetSwipeResultDataToCommand(CMD_STRUCT_PAP_SWIPE_RESULT3_EX & cmdInfo, PAY_AT_PUMP_INFO & cTmpInfo, long lAnswer)
{
	memset(&cmdInfo, ' ', sizeof(cmdInfo));
	cmdInfo.lDeviceNumber = '0';
	cmdInfo.lSeqNumber = a2l(cTmpInfo.CardSaleInfo.cardData.sTranNbr, sizeof(cTmpInfo.CardSaleInfo.cardData.sTranNbr));
	cmdInfo.lAnswer = lAnswer;
	cmdInfo.lFlags = STRUCT_IS_CARD_ALL_DATA3;

	memset(&cmdInfo.data, 0, sizeof(cmdInfo.data));
	cmdInfo.data		= cTmpInfo.CardSaleInfo.cardData;
	cmdInfo.extData		= cTmpInfo.CardSaleInfo.extraData;
	cmdInfo.extData2	= cTmpInfo.CardSaleExtraData2;
	cmdInfo.extData3	= cTmpInfo.CardSaleExtraData3;
	cmdInfo.extData4	= cTmpInfo.CardSaleExtraData4;
	cmdInfo.extData5	= cTmpInfo.CardSaleExtraData5;
	cmdInfo.extData6	= cTmpInfo.CardSaleExtraData6;
}


void  CServerMain::UnRegisterEOSReconfigureEvent (IN ULONG ulTableId)
{
	m_ulRegisteredReconfigureEvents &= ~ulTableId;
}

void CServerMain::UnRegisterEOSReconfigureEvent (IN CMD_STRUCT_RECONFIGURATION_EVENT const * const pRecEvent)
{
	
	m_ulRegisteredReconfigureEvents &= ~(pRecEvent->lTableId);
}

void CServerMain::RegisterEOSReconfigureEvent (IN CMD_STRUCT_RECONFIGURATION_EVENT const * const pRecEvent)
{
	
	int iReconfigureEventId = GetBitPosition(pRecEvent->lTableId);
	
	m_cmdReconfigureEvents [iReconfigureEventId - 1] = *pRecEvent;
	
	m_ulRegisteredReconfigureEvents |= pRecEvent->lTableId;
	
	m_bReconfigureRequestWasSent = FALSE;
}


void CServerMain::HandleReconfigureWhileEOS()
{
	if (FALSE == m_bReconfigureRequestWasSent)
	{
		for (int i = 0; i < 32; i++)
		{
			if (m_ulRegisteredReconfigureEvents & (ULONG)(1 << i))
			{
				long lRetVal = 0;
				
				CMD_STRUCT_RECONFIGURATION_EVENT RecEvent = m_cmdReconfigureEvents[i];
				
				CString str;
				str.Format("Send Reconfigure for Table ID:%d, Table Name:%s",i + 1, ReconfigureTableIdToString(1 << i));
				m_cLogger.LogMsg(str);
				
				m_cCommonFunction._Reconfigure2 (RecEvent.lTableId, RecEvent.lSubTableId, RecEvent.lSubTableIdExt, RecEvent.lFlags, &lRetVal, TRUE);
				
				m_bReconfigureRequestWasSent = TRUE;
				m_dwLastReconfigureRequestTime = GetTickCount();
				
			}
		}
	}
	else if ((GetTickCount() - m_dwLastReconfigureRequestTime) > RECONFIGURE_TIMEOUT)
	{
		CString str;
		str.Format("Timeout Expired! EOS Reconfigure events for Table ID's:%08x, were not received!",m_ulRegisteredReconfigureEvents);
		m_cLogger.LogMsg(str,LOG_LEVEL_0);
		
		m_ulRegisteredReconfigureEvents = 0;
		m_bReconfigureRequestWasSent = FALSE;
	}
}



// lPumpNumber can be 1 - 32 (or 64)
// Pump number 1  will be at PumpArray[0] 
// Pump number 32 will be at PumpArray[31] or PumpArray[63]
BOOL CServerMain::PumpNotValid(LONG lPumpNumber)
{
	if( (lPumpNumber > 0) && (lPumpNumber <= m_lMaxPumps))
		return FALSE;
	else
		return TRUE;
}

BOOL CServerMain::GradeNotValid(short nGrade)
{
	if( (nGrade >= 0) && (nGrade <= MAX_GRADES_99))//amram 4.0.10.502
		return FALSE;
	else
		return TRUE;
}

BOOL CServerMain::LevelNotValid(short nLevel)
{
	if( (nLevel >= 0) && (nLevel <= MAX_PRICE_LEVEL))
		return FALSE;
	else
		return TRUE;
}

BOOL CServerMain::NozzleNotValid(short nNozzle)
{
	if( (nNozzle >= 0) && (nNozzle <= MAX_POSITIONS_PER_PUMP))
		return FALSE;
	else
		return TRUE;
}

// lTankNumber can be 1 - 32 
BOOL CServerMain::TankNotValid(LONG lTankNumber)
{
	if( (lTankNumber > 0) && (lTankNumber <= MAX_TANKS))
		return FALSE;
	else
		return TRUE;
}

BOOL CServerMain::ModeNotValid(LONG lMode)
{
	if( (lMode > 0) && (lMode <= MAX_MODES))
		return FALSE;
	else
		return TRUE;
}

BOOL CServerMain::SchemeNotValid(LONG lScheme)
{
	if( (lScheme > 0) && (lScheme <= MAX_MODE_SCHEME))
		return FALSE;
	else
		return TRUE;
}


void CServerMain::SetOperatingMode(OperatingMode lNewMode)
{
	m_lOperatingMode = lNewMode;
}

OperatingMode CServerMain::GetOperatingMode()
{
	return(m_lOperatingMode);
}

long CServerMain::GetGradeCode(short nGrade)
{
	//Check that the parameter nGrade is at the right range.
	if ((nGrade > 0) && (nGrade <= MAX_GRADES_99))//amram 4.0.10.502
		return m_GradesRegistryData[nGrade-1].m_dwGradesCode;

	return 0;
}


//RFUEL-3309 Get the maximal discount allowed for the grade  
long CServerMain::GetGradeIndex(short nGradeCode)
{
	// i is the grade suffix on the registry keys 
	// e.g.:   i  = 7   for  HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Pointofsale\PumpSrv\Grades\Grade07
	//Check that the parameter nGrade is at the right range.
	for (int i = 0; i <= MAX_GRADES_99; i++)
	{
		if (m_GradesRegistryData[i].m_dwGradesCode == nGradeCode)
			return  i;
	}
	return -1;  // grade code not found
}

CString CServerMain::GetGradeAditionalCode(short nGrade)
{
	//Check that the parameter nGrade is at the right range.
	if ((nGrade > 0) && (nGrade <= MAX_GRADES_99))
		return m_GradesRegistryData[nGrade - 1].m_sAdditionalCode;

	return " ";
}


CString CServerMain::GetGradeName(short nGrade)
{
	//Check that the parameter nGrade is at the right range.
	if ((nGrade > 0) && (nGrade <= MAX_GRADES_99))//amram 4.0.10.502
		return m_GradesRegistryData[nGrade-1].m_sFullName;

	return " ";
}


long CServerMain::GetGradeTaxLink(short nGrade)
{
	if ((nGrade > 0) && (nGrade <= MAX_GRADES_99))
		return m_GradesRegistryData[nGrade-1].m_dwTaxLink;
	return 0;
}

long CServerMain::GetWashProgramIndex(long lProductCode)
{
	for(int iWashProgramIndex=0;iWashProgramIndex<MAX_WASH_PROGRAMAS;iWashProgramIndex++)
	{
		int iCarWashCode = _ttoi(m_WashProgramsData[iWashProgramIndex].m_sProduct_Code);

		if (iCarWashCode == lProductCode)
			return iWashProgramIndex;
	}
	return MAX_WASH_PROGRAMAS;
}

long	CServerMain::GetWashProgramIndex(CString sProductCode)
{
	CString sRetVal;
	sRetVal.Format("%d", MAX_WASH_PROGRAMAS);

	for (int i = 0; i < MAX_WASH_PROGRAMAS; i++)
	{
		if (m_WashProgramsData[i].m_sProduct_Code.Compare(sProductCode) == 0)
		{
			return i;
		}

	}

	return MAX_WASH_PROGRAMAS;
}

DWORD CServerMain::GetWashProgramTaxLink(int iWashProgramIndex)
{
	if ((iWashProgramIndex >= 0) && (iWashProgramIndex <= MAX_WASH_PROGRAMAS))
		return m_WashProgramsData[iWashProgramIndex].m_dwTaxLink;

	return 0;
}

DWORD CServerMain::GetWashProgramPrice(int iWashProgramIndex)
{
	if ((iWashProgramIndex >= 0) && (iWashProgramIndex <= MAX_WASH_PROGRAMAS))
		return m_WashProgramsData[iWashProgramIndex].m_dwPrice;

	return 0;
}

CString CServerMain::GetWashProgramName(int iWashProgramIndex)
{
	if ((iWashProgramIndex >= 0) && (iWashProgramIndex <= MAX_WASH_PROGRAMAS))
		return m_WashProgramsData[iWashProgramIndex].m_sFullName;

	return " ";
}

CString CServerMain::GetWashProgramCode(int iWashProgramIndex)
{
	if ((iWashProgramIndex >= 0) && (iWashProgramIndex <= MAX_WASH_PROGRAMAS))
		return m_WashProgramsData[iWashProgramIndex].m_sProduct_Code;

	return " ";
}

long CServerMain::GetWashIndexByProgramCode(CString sProductCode)
{
	long lRetInex = -1;
	for (int iWashProgramIndex = 1; iWashProgramIndex <= MAX_WASH_PROGRAMAS; iWashProgramIndex++)
	{
		if(m_WashProgramsData[iWashProgramIndex].m_sProduct_Code.Compare(sProductCode) == 0)
		{
			lRetInex = iWashProgramIndex;
			break;
		}
	}
	return lRetInex;
}

void CServerMain::SetServerState(ServerState lNewState,BOOL bUpdateCompConn)
{
	//4.0.5.26 - sets the connectivity state
	if(bUpdateCompConn)
		m_cCompConnectivity.SetPumpSrvState(lNewState);

	if( lNewState == SERVER_NO_CONVERT)
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{	
			m_cLogger.LogMsg("Server Switch to NO_CONVERT_LAYER");
		}
		m_lWatchdogCount = 0;

		//Mark PumpSrv as in Recovery.
		SetServerRecoveryProcess(TRUE); //4.0.19.502
	}

	if((lNewState != m_lServerState) && (lNewState == SERVER_STARTUP))
	{
		//4.0.19.504 - 47559
		if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse())  // CR 444830
			m_cGPIEventMgr.AddSetPumpStatus(0, POWER_UP, 0,0,0,0);

		if(LOG_BASIC_FLOW_CONTROL)
		{	
			m_cLogger.LogMsg("Server Switch to STARTUP");
		}
		m_lWatchdogCount = 0;

		//Mark PumpSrv as in Recovery.
		SetServerRecoveryProcess(TRUE); //4.0.19.502
	}

	//
	// Count to 3 before getting into IDLE
	//
	if(	(lNewState != m_lServerState) && (lNewState == SERVER_IDLE))
	{
		m_lWatchdogCount++; 
		if(m_lWatchdogCount == 1)
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				m_cLogger.LogMsg("Server STARTUP,  Watchdog 1, Trigger controller to send all pump status");
			}

			
			if(GetOperatingMode() == SLAVE)
			{
				CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

				CPumpTransact trs;
				trs.Clear();
				for (long lPump = 1; lPump <= m_lMaxPumps /*MAX_PUMPS4.0.0.079*/; lPump++)
					for (short nIndex = 0; nIndex <= MAX_TRS_IN_LIST; nIndex++)
						CentralUpdateTrsByIndex(lPump, 0, nIndex, &trs,FALSE);
			}

			// Trigger controller to send pump status (0 - Src, 0 - All pumps)
			SetCommand(CMD_GET_PUMP_STATUS, SERVER_POS_NUMBER, 0);
		}
		else if (m_lWatchdogCount == 2)
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				m_cLogger.LogMsg("Server STARTUP,  Watchdog 2");
			}
			// Triger controller to send pump status (0 - Src, 0 - All pumps)
			// Because some time CL lost the first request for getting the pumps statuses
			SetCommand(CMD_GET_PUMP_STATUS, SERVER_POS_NUMBER, 0);
		}
		else if (m_lWatchdogCount == 3)
		{
			//YA 4.0.0.35 start
			BOOL bNeedAllPumpStatus = FALSE;
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				m_cLogger.LogMsg("Server STARTUP,  Watchdog 3");
			}
			if( CanMoveToIDLE(&bNeedAllPumpStatus) )
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{	
					m_cLogger.LogMsg("Server Switch to IDLE !");	
				}
				m_lServerState = lNewState;

				m_cDataExportSrv.NotifySystemStartup(); 

				//Ravit 17.11.05
				SetServerRecoveryProcess(FALSE);

				//4.0.6.507 - sending "no controller" off alarm
				if(_ALARM_SRV.m_lAlarmSrvActive)//4.0.6.507
					m_cAlarm.ServerStateAlarm(SERVER_STARTUP,SERVER_IDLE);


				m_bWasModeUpdated = FALSE;

				if(m_bControllerManagePrinterStatus)
				{
					//Checking if at least one printer is conneted to a POS and sending 
					//the appropriate event according to it 
					if(IsPrinterConnected() )
					{
						SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_PRINTER_ONLINE);
					}
					else
					{
						SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_PRINTER_OFFLINE);
					}
				}

				// when we working with the backup system, 
				// there is situation that the backup machine is  updating the master with wrong status, 
				// to prevent report of wrong status, we ask the conntoller to send us his current update status.								
				if (bNeedAllPumpStatus == TRUE)//4.0.5.24
				{
					m_cLogger.LogMsg("Request for all Pump status , To be syncronize with the real pump status");
					SetCommand(CMD_GET_PUMP_STATUS, SERVER_POS_NUMBER, 0);
				}

				SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_SERVER_IDLE);	//4.0.9.511
				
			}
			else
			{
				if (GetVpIsGone()) 
				{
					SetVpIsGone(FALSE);
				}
				else
				{
				//waiting another watchdog. 
				m_lWatchdogCount = 2;
				}
			}
			//YA 4.0.0.35 end
		}
	}
	else
	{
		m_lServerState = lNewState;
	}

	if(m_lServerState == SERVER_NO_CONVERT)
	{
		m_bRcvAnyMsg = FALSE;				
	}
}

ServerState CServerMain::GetServerState()
{
	ServerState lTmp = m_lServerState;

	return(lTmp);
}


/******************************************************************************
 Description:	get server state extension 
 Returns:      	bit map state etension
				SSEBM_NONE										0x00000000		// none extansion
				SSEBM_CONVERT_LAYER_GONE						0x00000001		// convert layer is gone
				SSEBM_SHOW_GPI_MSG_CONVERT_LAYER_GONE			0x00000002		// show convert layer is gone msg on the POSPump while PumpSrv is not Idle //4.0.20.950 TD 97894

 Parameters:   	server state extention flags 
				SSEF_CONVERT_LAYER_GONE							0x00000001
				SSEF_SHOW_GPI_MSG_CONVERT_LAYER_GONE			0x00000002			//4.0.20.950 TD 97894
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 Gena			01/12/2009   11:54		Start			//4.0.20.880 TD 89047
 Gena			23/12/2009	 10:02(AUS)	Add new flag	//4.0.20.950 TD 97894
******************************************************************************/

DWORD CServerMain::GetServerStateEx(long lFlag)
{
	DWORD dwServerStateExBitMap = SSEBM_NONE;

	if ( lFlag & SSEF_CONVERT_LAYER_GONE )
	{
		if ( GetCLIsGone() == TRUE )											//4.0.20.950 TD 97894
			dwServerStateExBitMap |= SSEBM_CONVERT_LAYER_GONE; 
	}

	if (GetVpIsGone() == TRUE)												// 4.0.29.501 TD 288369
	{
		dwServerStateExBitMap |= SSEBM_VP_GONE;
		m_cLogger.LogMsg("Server state extension: SSEBM_VP_GONE");
	}
	
	if (GetQdxIsFail() == TRUE)												// 4.0.29.501 TD 288369
	{
		dwServerStateExBitMap |= SSEBM_QDX_FAIL;
		m_cLogger.LogMsg("Server state extension:  SSEBM_QDX_FAIL");
	}

	
	if ( lFlag & SSEF_SHOW_GPI_MSG_CONVERT_LAYER_GONE )							//4.0.20.950 TD 97894
	{
		if ( GetShowGPIMsgCLIsGone() == TRUE )
			dwServerStateExBitMap |= SSEBM_SHOW_GPI_MSG_CONVERT_LAYER_GONE; 
	}

	return( dwServerStateExBitMap );
}


//4.0.23.508 TD 89047
void	CServerMain::SetCLIsGone(BOOL bCLIsGone)
{
	m_bCLIsGone = bCLIsGone;
}


//4.0.23.508 TD 89047
BOOL	CServerMain::GetCLIsGone() const
{
	return m_bCLIsGone;
}


long CServerMain::SetCommand(Command lCommand, LONG lSrc, LONG lParam, LPVOID pData, SHORT nDataLen)
{

	CSingleLock slCmdQ( &m_csCmdQ );
	CSingleLock slPosMap( &m_csPosMap );

	slCmdQ.Lock(INFINITE); // if resource is currently locked - wait infinite time 
						   // until resource is unlocked.

	long lMsgNumber = NewMessageNumber();

	if(pData)
	{
		CCmdInfo	cCmd(lCommand,lSrc,lMsgNumber,lParam,pData,nDataLen);
		m_cCmdQ.AddHead(cCmd);	
	}
	else
	{
		
		CCmdInfo	cCmd(lCommand,lSrc,lMsgNumber,lParam);
		m_cCmdQ.AddHead(cCmd);		
	}

	slPosMap.Lock(INFINITE);
	m_cPosMap[lSrc].SetLastCmd(lCommand,lMsgNumber);

	return 0;
}

long CServerMain::SetCommand(Command lCommand, LONG lSrc, LONG lParam)
{
	return SetCommand(lCommand,lSrc, lParam, NULL, 0);	
}


long CServerMain::NewMessageNumber()
{
	return(m_lMessageNumber++);	
}


BOOL CServerMain::CmdInQ()
{
	CSingleLock slCmdQ( &m_csCmdQ );
	slCmdQ.Lock(INFINITE); // if resource is currently locked - wait infinite time 
						   // until resource is unlocked.	

	return (!m_cCmdQ.IsEmpty());
}

long CServerMain::NewTransactNumber()
{
//4.0.23.260 111318
	if(m_dwTransactNumber >= GetFuelTransactionNumberMaxValue())	// was (m_dwTransactNumber == MAX_TRANSACT_NUMBER)

		m_dwTransactNumber = GetFuelTransactionNumberMinValue();	//	was m_dwTransactNumber = 1;	
	else
	{
		m_dwTransactNumber++;
		if (m_dwTransactNumber < GetFuelTransactionNumberMinValue())
		{
			m_dwTransactNumber = GetFuelTransactionNumberMinValue();		

		}
	}
	
	m_cParam.SaveParam("GeneralParam","TransactNumber",m_dwTransactNumber,FALSE,_HOST.m_lGroupNum,0,0,TRUE); //4.0.8.503

	if(LOG_DETAIL_FLOW_CONTROL)
	{
		CString str;
		str.Format("NewTransactNumber %ld",m_dwTransactNumber); 
		m_cLogger.LogMsg(str);
	}

	return ((long)m_dwTransactNumber);
}

long CServerMain::NewActiveReadNumber()
{
	if(m_dwActiveReadNumber == MAX_READ_NUMBER)
		m_dwActiveReadNumber = 1;
	else
		m_dwActiveReadNumber++;

	m_cParam.SaveParam("GeneralParam","ActiveReadNumber",m_dwActiveReadNumber ,TRUE,0,0,0,TRUE);

	if(LOG_DETAIL_FLOW_CONTROL)
	{
		CString str;
		str.Format("NewActiveReadNumber %ld",m_dwActiveReadNumber); 
		m_cLogger.LogMsg(str);
	}

	return ((long)m_dwActiveReadNumber);
}

long CServerMain::NewActiveShiftNumber()
{
	
	m_cCurrentShift.dwFormalShiftNumber = m_cCurrentShift.dwActiveShiftNumber;
	
	if (m_cCurrentShift.dwActiveShiftNumber >= m_dwMaxShiftNumber)		//TD 417989
		m_cCurrentShift.dwActiveShiftNumber = 1;
	else
		m_cCurrentShift.dwActiveShiftNumber++;

	m_cParam.SaveParam("GeneralParam","ActiveShiftNumber",m_cCurrentShift.dwActiveShiftNumber,FALSE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 //4.0.8.503
	

	if(LOG_DETAIL_FLOW_CONTROL)
	{
		CString str;
		str.Format("NewActiveShiftNumber %ld",m_cCurrentShift.dwActiveShiftNumber); 
		m_cLogger.LogMsg(str);
	}

	return ((long)m_cCurrentShift.dwActiveShiftNumber);
}

long CServerMain::NewPumpTotalIndex()
{
	if(m_dwTotalIndex == MAX_INDEX_NUMBER)
		m_dwTotalIndex = 1;
	else
		m_dwTotalIndex++;

	m_cParam.SaveParam("GeneralParam","PumpTotalIndex",m_dwTotalIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503

	return ((long)m_dwTotalIndex);
}

long CServerMain::NewTankReadIndex()
{
	if(m_dwTankReadIndex == MAX_INDEX_NUMBER)
		m_dwTankReadIndex = 1;
	else
		m_dwTankReadIndex++;

	m_cParam.SaveParam("GeneralParam","TankReadIndex",m_dwTankReadIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503

	return ((long)m_dwTankReadIndex);
}


long CServerMain::NewFuelDeliveryIndex()
{
	if(m_dwDeliveryIndex == MAX_INDEX_NUMBER)
		m_dwDeliveryIndex = 1;
	else
		m_dwDeliveryIndex++;

	m_cParam.SaveParam("GeneralParam","FuelDeliveryIndex",m_dwDeliveryIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503

	return ((long)m_dwDeliveryIndex);
}

long CServerMain::NewAlarmIndex()
{
	if(m_dwAlarmIndex == MAX_INDEX_NUMBER)
		m_dwAlarmIndex = 1;
	else
		m_dwAlarmIndex++;

	m_cParam.SaveParam("GeneralParam","AlarmIndex",m_dwAlarmIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503

	return ((long)m_dwAlarmIndex);
}

long CServerMain::NewCarWashIndex()
{
	if(m_dwCarWashIndex == MAX_INDEX_NUMBER)
		m_dwCarWashIndex = 1;
	else
		m_dwCarWashIndex++;

	m_cParam.SaveParam("GeneralParam","CarWashIndex",m_dwCarWashIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503

	return ((long)m_dwCarWashIndex);
}

long CServerMain::NewOLAIndex()
{
	// 3.2.0.68
	if(m_dwOLAIndex >= MAX_INDEX_NUMBER - MAX_RECS_IN_OLA) //4.0.5.0
		m_dwOLAIndex = 1;
	else
		m_dwOLAIndex +=MAX_RECS_IN_OLA;

	m_cParam.SaveParam("GeneralParam","OLAIndex",m_dwOLAIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66
	
	return ((long)m_dwOLAIndex);
}





// 0 - OK
// 1 - Cant Open Key, Param set to default 
// 2 - NOt Found, Param created with default value
// 3 - NOt Found, Cant create new param , Param set to default
// 4 - NOt Found, Didn't create, accoording to request



void CServerMain::UpdateLastCmd(long lSrc, long lCommand, long lNumber, PosCmdState lCmdState, long lRetCode)
{
	CSingleLock slPosMap( &m_csPosMap );
	slPosMap.Lock(INFINITE);

	m_cPosMap[lSrc].UpdateLastCmd(lCommand,lNumber,lCmdState,lRetCode);

	//4.0.1.38
	slPosMap.Unlock();
}

void CServerMain::RemoveCmdFromQ()
{
	CSingleLock slCmdQ( &m_csCmdQ );
	slCmdQ.Lock(INFINITE); // if resource is currently locked - wait infinite time 
						   // until resource is unlocked.
	m_cCmdQ.RemoveTail();	

	//4.0.1.38
	slCmdQ.Unlock();
}

// 0 - OK
// 1 - Trs Not found 
// 2 - Not meet condition

long CServerMain::SpecialUpdateTrs(long lPumpNumber, long lTrsNumber, CPumpTransact * pTrs,long lFlags,TrsStatus lConditionStatus )
{

	CPumpTransact	trs;
	long			lRetCode = m_cPumpArray[lPumpNumber-1].GetTrsByNumber(lTrsNumber,&trs);
		
	if(lRetCode	== 0 )
	{
		if ( trs.m_lStatus == lConditionStatus )
		{
			if(lFlags & TRS_FIELD_NUMBER )
				trs.m_lNumber	= pTrs->m_lNumber;
			if (lFlags & TRS_FIELD_STATUS )
				trs.m_lStatus	= pTrs->m_lStatus;
			if (lFlags & TRS_FIELD_ON_OFFER	)
					trs.m_lOnOffer	= pTrs->m_lOnOffer;
			if (lFlags & TRS_FIELD_RAW_VOLUME )
					trs.m_lRawVolume = pTrs->m_lRawVolume;
			if (lFlags & TRS_FIELD_ROUNDED_VOLUME )
					trs.m_lRoundedVolume	= pTrs->m_lRoundedVolume;
			if (lFlags & TRS_FIELD_ROUNDED_VALUE )
					trs.m_lRoundedValue	= pTrs->m_lRoundedValue;
			if (lFlags & TRS_FIELD_GRADE_PRICE )
					trs.m_lGradePrice	= pTrs->m_lGradePrice;
			if (lFlags & TRS_FIELD_NOZZLE )
					trs.m_nNozzle	= pTrs->m_nNozzle;
			if (lFlags & TRS_FIELD_GRADE )
					trs.m_nGrade	= pTrs->m_nGrade;
			if (lFlags & TRS_FIELD_LEVEL )
					trs.m_nLevel	= pTrs->m_nLevel;
			if (lFlags & TRS_FIELD_PUMP	)
					trs.m_lPump	= pTrs->m_lPump;
			if (lFlags & TRS_FIELD_MODE	)
					trs.m_lMode	= pTrs->m_lMode;
			if (lFlags & TRS_FIELD_RES	)
					trs.m_lRes	= pTrs->m_lRes;
			if (lFlags & TRS_FIELD_RESEXT )
					trs.m_lResExt	= pTrs->m_lResExt;
			if (lFlags & TRS_FIELD_LINK_NUMBER )
					trs.m_lLinkNumber	= pTrs->m_lLinkNumber;
			if (lFlags & TRS_FIELD_LINK_FLAGS	)
					trs.m_nLinkFlags	= pTrs->m_nLinkFlags;
			if (lFlags & TRS_FIELD_ACTIVE_READ_NUMBER )
					trs.m_lActiveReadNumber	= pTrs->m_lActiveReadNumber;
			if (lFlags & TRS_FIELD_ACTIVE_SHIFT_NUMBER )
					trs.m_lActiveShiftNumber = pTrs->m_lActiveShiftNumber;
			if (lFlags & TRS_FIELD_MISC	)
					trs.m_lMisc	= pTrs->m_lMisc;

			lRetCode = m_cPumpArray[lPumpNumber-1].SetTrsByNumber(lTrsNumber,&trs,FALSE);
		}
		else
			lRetCode = 2;
	}

	if(lRetCode == 0)
		SavePumpInfo(lPumpNumber);

	return(lRetCode);			
}

	
long CServerMain::CentralUpdateTrsByIndex(long lPumpNumber, long lTrsNumber, short nIndex, CPumpTransact * pTrs,BOOL bRolling)
{
	long lRetCode = m_cPumpArray[lPumpNumber-1].SetTrsByIndex((int) nIndex, pTrs,bRolling);
	
	if(pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER)	
		TrsLinkOperation(REC_UPDATE, pTrs, NULL);

	if((!bRolling)&&(lRetCode == 0)) // save storing time
	{
		if(pTrs->GetStatus() != ACCEPTED)
		{
			if	(! ((pTrs->GetStatus() == UNPAID) && (pTrs->GetOnOffer()) ))  
				SavePumpInfo(lPumpNumber);				
		}
	}

	return(lRetCode);				
}

long CServerMain::CentralUpdateTrs(long lPumpNumber, long lTrsNumber, CPumpTransact * pTrs, BOOL bRolling)
{
	long lRetCode = m_cPumpArray[lPumpNumber - 1].SetTrsByNumber(lTrsNumber, pTrs, bRolling);

	if(pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER)	
		TrsLinkOperation(REC_UPDATE, pTrs, NULL);
	
	if((!bRolling)&&(lRetCode == 0)) // save storing time
	{
		if(pTrs->GetStatus() != ACCEPTED)
		{
			if	((! ((pTrs->GetStatus() == UNPAID) && (pTrs->GetOnOffer()))) ||
				 (GetOperatingMode() == MASTER))
				SavePumpInfo(lPumpNumber);				
		}
	}

	return(lRetCode);			
}

long CServerMain::CentralInsertTrs(long lPumpNumber, CPumpTransact * pTrs ,BOOL bPostVoid ,BOOL bValidateExtraInfo)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
	long lRetVal = (long)m_cPumpArray[lPumpNumber-1].InsertTrs(pTrs,FALSE,bPostVoid); // m_dwAccept0Transaction);

	if((lRetVal == 0)||(lRetVal == 3))
	{
		SQLPumpSrvFile.SaveInfo(lPumpNumber, __FUNCTION__, __LINE__);
		//4.0.11.410
		if (!bValidateExtraInfo) //4.0.11.451  //4.0.14.508
			CheckVlidityTransactionNumber(pTrs->m_lNumber);


		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("Insert new transaction (%d) at pump %02d, Link number %d, shift %d, (res %d, mode %d)", pTrs->m_lNumber, pTrs->m_lPump, pTrs->GetLinkNumber(),pTrs->m_lActiveShiftNumber,pTrs->m_lRes,pTrs->m_lMode);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
		}
	}
	
	return(lRetVal);			
}


long CServerMain::GetActiveReadNumber()
{
	return (long)m_dwActiveReadNumber;
}

long CServerMain::GetActiveShiftNumber()
{
	return (long)m_cCurrentShift.dwActiveShiftNumber;
}

long CServerMain::GetFormalShiftNumber()
{
	return (long)m_cCurrentShift.dwFormalShiftNumber;
}


long CServerMain::TrsLinkOperation(eFileOperation OpCode, CPumpTransact *pTrs, void *pData, void *pExtraData, BOOL bSkipLoyaltyOperation)
{
	long lRtc = 1;
	if (pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER)
	{

		lRtc = m_cSQLPrePayFile.Operation(OpCode, pData, pTrs);// pData);

		if (!bSkipLoyaltyOperation)
		{
			if (((OK == lRtc) && (pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER_AND_LOYALTY)) ||
				(pTrs->GetLinkFlags() & TRS_LINK_EXTRA_INFO ))  //4.0.1.38			
			{
				long lRtc1 =0;

				switch (OpCode)
				{
				case REC_INSERT:
					lRtc1 = m_cSQLExtraInfoFile.InsertPrePayRecord(pTrs, pExtraData);
					break;
				case  REC_DELETE:
					lRtc1 = m_cSQLExtraInfoFile.DeleteRecord(pTrs);
					break;
				default:
					break;
				}

				if(LOG_BASIC_FLOW_CONTROL  && lRtc1)	//3.1.1.66 //3.1.1.70
				{
					CString str;
					str.Format("Fail to update PREPAY LINK ExtraInfo opCode=%d, Rtc=%d " , OpCode , lRtc1);
					m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.23.500
				}
			}
		}
		// 4.0.3.44
	}

	else if (pTrs->GetLinkFlags() == TRS_LINK_OLA_NUMBER)
	{
		lRtc = m_cSQLOLATrs.OperationEx(OpCode, pTrs, pData);
	}
	else if (pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER_AND_LOYALTY)
	{
		CString sExtraDataXml;
		if (pExtraData != NULL)
			sExtraDataXml = *(CString*)pExtraData;
		lRtc = m_cSQLExtraInfoFile.Operation(OpCode, pData, *(CString*)pExtraData);
		CString tmp = sExtraDataXml.GetBuffer(0);
	}
	else if ((pTrs->GetLinkFlags() & TRS_LINK_PAK_AND_LOYALTY) ||
		(pTrs->GetLinkFlags() & TRS_LINK_ATTEND) ||
		(pTrs->GetLinkFlags() & TRS_LINK_EXTRA_INFO)) //4.0.1.38
	{
		long lRtc1 = 0;

		switch (OpCode)
		{
		case REC_INSERT:
			lRtc1 = m_cSQLExtraInfoFile.InsertPayAtKioskRecord(pTrs, pExtraData);
			if (!lRtc1)
				lRtc = lRtc1;
			break;
		case  REC_DELETE:
			lRtc1 = m_cSQLExtraInfoFile.DeleteRecord(pTrs);
			if (!lRtc1)			//3.2.0.22
				lRtc = lRtc1;

			break;
		default:
			CString sExtraDataXml;
			lRtc = m_cSQLExtraInfoFile.Operation(OpCode, pData, sExtraDataXml);		// 3.2.0.76
			CString str;
			str.Format("Read ExtraInfo opCode=%d, Rtc=%d ", OpCode, lRtc1);
			m_cLogger.LogMsg(str, LOG_LEVEL_1);
			break;
		}

		//3.1.1.66  //3.2.0.22
		if (LOG_BASIC_FLOW_CONTROL && lRtc1)
		{
			CString str;
			str.Format("Fail to update PAK LINK ExtraInfo opCode=%d, Rtc=%d ", OpCode, lRtc1);
			m_cLogger.LogMsg(str, LOG_LEVEL_1); //4.0.23.500
		}

	}

	return lRtc; // error - no link 

}

long CServerMain::TrsLinkOperationEx(eFileOperation OpCode, CPumpTransact *pTrs, void *pData, void *pExtraData,BOOL bSkipLoyaltyOperation)
{
	long lRtc = 1;
	if(pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER)
	{
		lRtc = m_cSQLPrePayFile.Operation(REC_UPDATE, pData, pTrs);
		// 4.0.3.44
		if (!bSkipLoyaltyOperation)
		{
			if (((!lRtc) && (pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER_AND_LOYALTY)) ||
				((!lRtc) && (pTrs->GetLinkFlags() & TRS_LINK_EXTRA_INFO)))  //4.0.1.38			
			{ 
				long lRtc1 =0; 

				switch (OpCode)
				{
				case REC_INSERT:
					//4.0.20.503m_cProtectedDataHandler.RemoveConfidencesData((PAY_AT_PUMP_INFO*)pData);
					lRtc = m_cSQLExtraInfoFile.InsertPrePayRecord(pTrs, pExtraData);
					break;

				case  REC_DELETE:
					lRtc = m_cSQLExtraInfoFile.DeleteRecord(pTrs);
					break;
				default:
					break;
				}

				//3.1.1.66 //3.1.1.70
				if(LOG_BASIC_FLOW_CONTROL  && lRtc1)
				{
					CString str;
					str.Format("Fail to update PREPAY LINK ExtraInfo opCode=%d, Rtc=%d " , OpCode , lRtc1);
					m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.23.500
				}
			}

		}
	}	
	
	else if(pTrs->GetLinkFlags() == TRS_LINK_OLA_NUMBER)
	{		
		lRtc = m_cSQLOLATrs.OperationEx(OpCode, pTrs, pData);
	}		
	else if(pTrs->GetLinkFlags() & TRS_LINK_PREPAY_NUMBER_AND_LOYALTY)
	{
		CString sExtraDataXml;
		if (pExtraData != NULL)
			sExtraDataXml = *(CString*)pExtraData;
		lRtc = m_cSQLExtraInfoFile.Operation(OpCode, pData, sExtraDataXml);
	}
	else if ((pTrs->GetLinkFlags() & TRS_LINK_PAK_AND_LOYALTY) ||
			(pTrs->GetLinkFlags() & TRS_LINK_ATTEND) ||
			(pTrs->GetLinkFlags() & TRS_LINK_EXTRA_INFO)) //4.0.1.38
	{
		long lRtc1 =0; 

		switch (OpCode)
		{
		case REC_INSERT:
		
			lRtc1 = m_cSQLExtraInfoFile.InsertPayAtKioskRecord(pTrs, pExtraData);

				if (!lRtc1)
					lRtc = lRtc1;

			break;
		case  REC_DELETE:
			lRtc1 = m_cSQLExtraInfoFile.DeleteRecord(pTrs);

				if (!lRtc1)			//3.2.0.22
					lRtc = lRtc1;

			break;
		default:
		{
			CString sExtraDataXml;
			lRtc = m_cSQLExtraInfoFile.Operation(OpCode, pData, sExtraDataXml);
			break;
		}
			
		}

		//3.1.1.66  //3.2.0.22
		if(LOG_BASIC_FLOW_CONTROL && lRtc1)
		{
			CString str;
			str.Format("Fail to update PAK LINK ExtraInfo opCode=%d, Rtc=%d " , OpCode , lRtc1);
			m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.23.500
		}
	}

	return lRtc; // error - no link 
	
}

long CServerMain::IndexOperation(short nFileNumber, eFileOperation OpCode, void *pData, void *pExtraData,long lFlags)
{
	long lRtc;
	switch (nFileNumber)
	{
	case PUMP_TOTALS_FILE:
		lRtc = m_cSQLPumpInoFile.Operation(OpCode, pData);
		break;


	case TANK_READS_FILE:
		lRtc = m_cSQLTankReads.Operation(OpCode, pData);
		break;
	case FUEL_DELIVERIES_FILE:
		lRtc = m_cSQLFuelDDeliveriesFile.Operation(OpCode, pData);
		break;
	case ALARM_FILE:
	{
		CSQLAlarmFile & SQLAlarmFile = CSQLAlarmFile::GetInstance();
		lRtc = SQLAlarmFile.Operation(OpCode, pData);
	}
	break;
	case CAR_WASH_FILE:
		lRtc = m_cSQLCarWashFile.Operation(OpCode, pData);
		break;
	case EXTRA_INFO_FILE:
	{
		
		CString sExtraDataXml;

		if (pExtraData != NULL)
			sExtraDataXml = *(CString*)pExtraData;

		lRtc = m_cSQLExtraInfoFile.Operation(OpCode, pData, sExtraDataXml); //3.1.1.5
		break;
	}
		//5.0.0.55
	case ITEMS_FILE:
		lRtc = m_cSQLItemsFile.Operation(OpCode, pData);
		break;

	case PUMP_PRE_PAY_FILE:
		lRtc = m_cSQLPrePayFile.Operation(OpCode, pExtraData, (CPumpTransact*)pData);
		break;

	case ASH2000_FILE:			//4.0.3.47
		lRtc = m_cSQLAsh2000File.Operation(OpCode, pData);
		break;
	case DB_TANK_GAUGE_FILE:   //4.0.5.24
	{
		lRtc = m_cSQLTankGauge.Operation(OpCode, pData, pExtraData);
	}
	break;
	case RECEIPT_EXTRA_DATA_FILE:   //4.0.5.24
	{
		lRtc = m_cSQLReceiptExtraInfoFile.OperationEx(OpCode, (PS::RECEIPT_EXTRA_INFO_REC&)pData);
	}
	break;
	case RECEIPT_EXTRA_INDEX_FILE:   //4.0.8.500
	{
		lRtc = m_cReceiptExtraIndexFile.Operation(OpCode, pData);
	}

	break;
	case PUMP_OLA_TEMP_FILE:	//4.0.9.509
		lRtc = m_cSQLOLATempTrs.Operation(OpCode, (CPumpTransact *)pData, pExtraData);
		break;

// 	case CASH_ACCEPTOR_FILE:
// 		lRtc = m_cCashAcceptorFile.Operation(OpCode, pData);
// 		break; // RFUEL-292
		//4.0.11.503
	case PAID_TRS_FILE:
		m_cSQLPaidTrsFile.Operation(OpCode, pData);
		break;

	case SINGLE_SHIFT_ACCUMULATIONS_FILE:   //4.0.25.50 - TD 108311
	{
		lRtc = m_SQLSingleShiftAccumulationFile.Operation(OpCode, pData, pExtraData);
	}
	break;	
	}
	return lRtc;
}



// 
//  WideCancelTrs 
//
//	return:
//	0 - trs canceled.
//  1 - trs not found
//	2 - Cant cancel trs
//	3 - trs not PrePay
//	4 - trs not Current
//  5 - failed IO
//	6 - cant cancel prepay trs from forecourt				
//	
//
//	lSrc can be:
//
//	SOURCE_GPI
//	SOURCE_GCI
//	SOURCE_INTERNAL
//

int CServerMain::WideCancelTrs(long lSrc, long lPumpNumber, long lTrsNumber, long *pRtc,BOOL bSkipDelPrePayRecord)
{

	long lRtc = TRS_CANCEL; 
	*pRtc = TRS_CANCEL;

	CPumpTransact trs;
	if(m_cPumpArray[lPumpNumber-1].GetTrsByNumber(lTrsNumber, &trs))
	{		
		return TRS_NOT_FOUND; // trs not found.
	}
	
	TrsStatus lTrsStat = trs.GetStatus();
	PumpStatus lPumpStat = m_cPumpArray[lPumpNumber-1].GetStat().GetStatus();
	PumpReservation lRes = m_cPumpArray[lPumpNumber-1].GetStat().GetRes();
	PumpResExt	lResExt = m_cPumpArray[lPumpNumber-1].GetStat().GetResExt();
	short nLinkFlags = trs.GetLinkFlags();


	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("WideCancelTrs : Trs %d, LinkFlags = %ld,", lTrsNumber, trs.GetLinkFlags());
		switch(lSrc)
		{
			case SOURCE_GPI: str += "(SOURCE_GPI)";break;
			case SOURCE_GCI: str += "(SOURCE_GCI)";break;
			case SOURCE_INTERNAL: str+= "(SOURCE_INTERNAL)"; break;
		}
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
	
	if(m_cFuelLoayaltyPS.GetFuelLoyaltyFlag() && (!(trs.GetLinkFlags() & TRS_LINK_PREPAY_NUMBER) )) //4.0.20.450 66977 //4.0.21.501
		m_cFuelLoayaltyPS.CancelTicket(lPumpNumber);

	
	switch(lSrc)
	{
		case SOURCE_GPI:
		///////////////////////////////////////////
		{
			// check if PrePay TRS
			if (nLinkFlags & TRS_LINK_PREPAY_NUMBER)
			{
				// check if trs already at the pump 
				if	(lTrsStat == IN_PROGRESS)  // M.L removed &&(pump status == DISPENSING)
					return TRS_CANT_CANCEL; //too late
				
				else if(((lTrsStat == WAIT_AUTH) && (!(trs.m_lMisc & MISC_PUMP_CHECK_AND_RESERVE)))	|| //Merge 4.0.17.430
						(lTrsStat == WAIT_PROGRESS)	||
						(lTrsStat == WAIT_TIME_OUT)) // M.L remove || (lTrsStat == IN_PROGRESS)			
				{
					if ((lRes == PRE_PAY_AT_POS) && (lResExt == RES_EXT_CASH_ACCEPTOR) || (lRes == PAY_AT_PUMP ))
					{
						if(LOG_BASIC_FLOW_CONTROL)  //4.0.24.373
						{
							CString str;
							str.Format("Pump %02ld detect cash acceptor in progress do not send cancel trs ..", trs.m_lPump);
							m_cLogger.LogMsg(str);
						}
					}
					else
					{
						CMD_STRUCT_TRS_CANCEL cmdInfo;
						cmdInfo.lTrsNumber = trs.m_lNumber;
						cmdInfo.lPumpStatus = lPumpStat;
						cmdInfo.lRes		= lRes;
						cmdInfo.lResExt		= trs.GetOnOffer();	
						SetCommand(CMD_TRS_CANCEL,SERVER_POS_NUMBER, lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_TRS_CANCEL));													
					}				
				}	// 4.0.28.500
				
				m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);

				SavePumpInfo(lPumpNumber);

				// POS Cancel a prepay transaction:
				//---------------------------------
				m_cShiftLog.LogTrs(&trs,TRUE,FALSE);

				if (!bSkipDelPrePayRecord)   //4.0,49
					lRtc = TrsLinkOperation(REC_DELETE,&trs,NULL);
				else
					lRtc = TRS_CANCEL;
					
				if(lRtc)
				{
					*pRtc = lRtc;
					return TRS_FAILED_IO; //failed IO
				}
				else
				{					
					if ((nLinkFlags & TRS_LINK_XML_BUFF) && (!bSkipDelPrePayRecord)) //52335	//53597 //4.0.18.502
					{
						PAY_AT_PUMP_INFO cPatAtPumpInfo;
						long lQdxRetCode = IndexOperation(PUMP_OLA_TEMP_FILE , REC_DELETE, &trs ,&cPatAtPumpInfo);

						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Pump %02ld Trs %ld Delete OLATmp record Rtc=%ld ", trs.m_lPump ,trs.m_lNumber, lQdxRetCode);
							m_cLogger.LogMsg(str);
						}
						
					}
					return TRS_CANCEL;					
				}
			}
			else return TRS_NOT_PREPAY; // not PrePay 

			break;
		}

		case SOURCE_GCI:
		///////////////////////////////////////////
		{
			if(trs.GetStatus() != IN_PROGRESS)
			{
				return TRS_NOT_CURRENT; // trs is not current.
			}
			if (nLinkFlags == TRS_LINK_OLA_NUMBER)
			{
				m_cPumpArray[lPumpNumber-1].ClearOlaStat();
				SavePumpInfo(lPumpNumber);
			}

			if (nLinkFlags & TRS_LINK_PREPAY_NUMBER)
			{
				return TRS_CANT_CANCEL_PREPAY_FROM_FORECOURT; // cant cancel prepay trs from forecourt				
			}		
			else if(nLinkFlags == TRS_NO_LINK)
			{
				m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);
				SavePumpInfo(lPumpNumber);
				
				// GCI Cancel PAK transaction  
				//---------------------------
				m_cShiftLog.LogTrs(&trs,TRUE,FALSE);
			}

			break;
		}

		case SOURCE_INTERNAL:
		///////////////////////////////////////////
		{
			if (nLinkFlags & TRS_LINK_PREPAY_NUMBER) 	// check if PrePay TRS
			{
				// check if trs already at the pump 		
				if( (lTrsStat == IN_PROGRESS) ) // M.L remove checking &&(lPumpStat == DISPENSING)  					
				{
					return TRS_CANT_CANCEL; //to late
				}
				else if ((lTrsStat == WAIT_AUTH) || (lTrsStat == WAIT_PROGRESS) ) // M.L remove checking || (lTrsStat == IN_PROGRESS))&&( lPumpStat != DISPENSING)         )		
				{					
					CMD_STRUCT_TRS_CANCEL cmdInfo;
					cmdInfo.lTrsNumber = trs.m_lNumber;
					cmdInfo.lPumpStatus = lPumpStat;
					cmdInfo.lRes		= lRes;
					cmdInfo.lResExt		= trs.GetOnOffer();	
					SetCommand(CMD_TRS_CANCEL, SERVER_POS_NUMBER , lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_TRS_CANCEL));				
					
					//4.0.22.507 - TD 75706
					if (trs.GetLinkFlags() & TRS_LINK_CASH_ACCEPTOR_INFO)	//4.0.17.660 62457
					{
						EXTRA_INFO_REC	ExtraInfoRec;
						memset(&ExtraInfoRec , 0 , sizeof(EXTRA_INFO_REC));

						ExtraInfoRec.info.lIndexNumber = trs.m_lNumber;
						lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);
						if (lRtc || (!lRtc && ExtraInfoRec.info.lCashDepositTotal <= 0))
						{
							if(LOG_BASIC_FLOW_CONTROL)
							{
								CString str;
								str.Format("WideCancelTrs : Delete cash acceptor Trs #%ld, Cash deposit=%ld", lTrsNumber, ExtraInfoRec.info.lCashDepositTotal);
								m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
							}

							m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);
							SavePumpInfo(lPumpNumber);

							//Cancel a prepay transaction:
							//---------------------------------
							if (!bSkipDelPrePayRecord)   
								lRtc = TrsLinkOperation(REC_DELETE,&trs,NULL);
							else
								lRtc = TRS_CANCEL;
							if(lRtc)
							{
								*pRtc = lRtc;
								return TRS_FAILED_IO; //failed IO
							}
							else
								return TRS_CANCEL;
						}
					}

					if (GetIFSFTerminalSrvInUse())	//4.0.19.504 - 47559
					{
						m_cGPIEventMgr.AddCancelTrs(lPumpNumber,
											cmdInfo.lTrsNumber, cmdInfo.lPumpStatus, 
											cmdInfo.lRes, cmdInfo.lResExt);
					}
				}			
				else
					return TRS_CANCEL;					
			}
			else if((nLinkFlags == TRS_NO_LINK) || ((trs.m_lResExt == RES_EXT_PAK_LOYALTY)&& (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag()))) //4.0.30.40 310103
			{
				//4.0.5.26
				if (( trs.m_lRoundedValue) && 
					(lResExt != RES_EXT_PAK_CANCELED)) //4.0.22.511 TD 76441 - let the pak be cleared in this case.
				{
					return TRS_CANT_CANCEL; //too late
				} 
				else
				{
					m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);
					m_cPumpArray[lPumpNumber-1].ClearOlaStat();//4.0.30.40 310103
					SavePumpInfo(lPumpNumber);
					
					// Internal cancel for PAK transaction 
					//------------------------------------
					m_cShiftLog.LogTrs(&trs,TRUE,FALSE);

					//4.0.19.504 - 47559
					if (GetIFSFTerminalSrvInUse())
					{
						CMD_STRUCT_TRS_CANCEL cmdInfo;
						cmdInfo.lTrsNumber = trs.m_lNumber;
						cmdInfo.lPumpStatus = lPumpStat;
						cmdInfo.lRes		= lRes;
						cmdInfo.lResExt		= trs.GetOnOffer();	
						SetCommand(CMD_TRS_CANCEL, SERVER_POS_NUMBER , lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_TRS_CANCEL));				
					
						m_cGPIEventMgr.AddCancelTrs(lPumpNumber,
											cmdInfo.lTrsNumber, cmdInfo.lPumpStatus, 
											cmdInfo.lRes, cmdInfo.lResExt);
					}

				}
				//4.0.5.26	
			}
			//4.0.19.504 - 47559
			else if (trs.GetLinkFlags() == TRS_LINK_OLA_NUMBER && (GetIFSFTerminalSrvInUse() || lResExt == RES_EXT_MOBILE) && lRes == PAY_AT_PUMP && (lResExt == RES_EXT_PAP_EXTERNAL || lResExt == RES_EXT_MOBILE))
			{
				if ( trs.m_lRoundedValue ) 
				{
					return TRS_CANT_CANCEL; //to late
				}
				else
				{
					m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);
					SavePumpInfo(lPumpNumber);
					
					// Internal cancel for special external PAP transaction 
					//------------------------------------
					m_cShiftLog.LogTrs(&trs,TRUE,FALSE);
					
					//TD 47559 cont.
					CMD_STRUCT_TRS_CANCEL cmdInfo;
					cmdInfo.lTrsNumber = trs.m_lNumber;
					cmdInfo.lPumpStatus = lPumpStat;
					cmdInfo.lRes		= lRes;
					cmdInfo.lResExt		= trs.GetOnOffer();	
					SetCommand(CMD_TRS_CANCEL, SERVER_POS_NUMBER , lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_TRS_CANCEL));				

					if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse())  // CR 444830
					{
						m_cGPIEventMgr.AddCancelTrs(lPumpNumber,
											cmdInfo.lTrsNumber, cmdInfo.lPumpStatus, 
											cmdInfo.lRes, cmdInfo.lResExt);
					}

				}
			}
			else if(nLinkFlags == TRS_LINK_ATTEND /* 4.0.1.34 */ ||
				  ((nLinkFlags == TRS_LINK_OLA_NUMBER) && OLA_BY_CONTROLLER)) /* 2.9.1.5 */
			{
				//4.0.5.26
				if (trs.m_lRoundedValue) 
					return TRS_CANT_CANCEL; //to late
				else
				{
					m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber);
					SavePumpInfo(lPumpNumber);
					
					// Internal cancel for PAK transaction 
					//------------------------------------
					m_cShiftLog.LogTrs(&trs,TRUE,FALSE);
				}
			}
			else if (nLinkFlags == TRS_LINK_PAK_AND_LOYALTY)	//4.0.24.100 118124
			{

				if (m_cPumpArray[lPumpNumber -1].IsPapToPakTrs()) 	//4.0.23.650 137641 //4.0.25.50  //4.0.23.2290 TD 380607
				{
					if (trs.m_lRoundedValue) 
						return TRS_CANT_CANCEL; //too late
				}
				
				if(m_cPumpArray[lPumpNumber - 1].IsForceZeroPakCompletionOn())
				{
					m_cPumpArray[lPumpNumber - 1].SetPapToPakTrsNum(lTrsNumber);

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str;
						str.Format("CServerMain::WideCancelTrs - PAK Loylty Trs with PAK Force Compleation, Ash2000Qdx will be deleted on session complete end. Saved Trs number=%d",lTrsNumber);
						m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
					}
				}
				else
				{
					if (m_cPumpArray[lPumpNumber -1].IsSavedDataInAsh2000Qdx()) //4.0.25.50 118124
						DeleteFromAsh2000Qdx(lTrsNumber);
				}  // 256101


				m_cPumpArray[lPumpNumber-1].ClearTrs(lTrsNumber); 
				SavePumpInfo(lPumpNumber); // TD 255105

			}
			else
				return TRS_NOT_PREPAY;
		break;
		}
	}
	return TRS_CANCEL;
}

// 1 - Failed IO
// 2 - Cant do operation - Valid Transaction
long CServerMain::WideRemoveTrs(CPumpTransact *pTrs, long *pRtc)
{

	long lRtc = 0; 
	*pRtc = 0;
	
	TrsStatus lTrsStat = pTrs->GetStatus();
	PumpStatus lPumpStatus = m_cPumpArray[pTrs->m_lPump - 1].GetStat().GetStatus();
	PumpReservation lRes = m_cPumpArray[pTrs->m_lPump - 1].GetStat().GetRes();
	long lPumpNumber = pTrs->m_lPump;

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("WideRemoveTrs : Trs %d, ", pTrs->m_lNumber);
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}

	if(	(lTrsStat == WAIT_RES) || 
		(lTrsStat == WAIT_AUTH) ||
		(lTrsStat == WAIT_PROGRESS) ||
		(lTrsStat == WAIT_TIME_OUT) ||
		(lTrsStat == IN_PROGRESS) || 
		(lTrsStat == INCOMPLETE))   //4.0.10.504

	{
		switch(pTrs->GetLinkFlags())
		{	
			case TRS_LINK_PREPAY_NUMBER:
			{
				*pRtc = TrsLinkOperation(REC_DELETE,pTrs,NULL);
				if(*pRtc)
					lRtc = 1;
				if(lRes == PRE_PAY_AT_POS) 
				{
					if (!(pTrs->m_lMisc & MISC_PUMP_CHECK_AND_RESERVE)) //4.0.17.20 - TD 26384
					{
						CMD_STRUCT_TRS_CANCEL cmdInfo;
						cmdInfo.lTrsNumber = pTrs->m_lNumber;
						cmdInfo.lPumpStatus = lPumpStatus;
						cmdInfo.lRes		= lRes;
						cmdInfo.lResExt		= pTrs->GetOnOffer();	
						SetCommand(CMD_TRS_CANCEL,SERVER_POS_NUMBER, lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_TRS_CANCEL));				
						if(LOG_BASIC_FLOW_CONTROL)//4.0.10.1000
						{
							CString str;
							str.Format("WideRemoveTrs Send cancel to CL - trs %ld",cmdInfo.lTrsNumber);
							m_cLogger.LogMsg(str);
						}
					}
					else
					{
						//4.0.17.20 - TD 26384
						// In case of check and reserve nee d to release pump
						CMD_STRUCT_RELEASE_PUMP cmdInfo;
						cmdInfo.lRes = lRes;
						cmdInfo.lResExt = 0; 
						SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER, lPumpNumber,&cmdInfo,sizeof(CMD_STRUCT_RELEASE_PUMP));

						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("WideRemoveTrs Send release pump to CL ");
							m_cLogger.LogMsg(str);
						}

						pTrs->m_lMisc &= MISC_NOT_PUMP_CHECK_AND_RESERVE; // remove the misc from transaction

						CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);
						
						CPumpStatus	pumpStat = m_cPumpArray[pTrs->m_lPump - 1].GetStat();
						long lMisc = pumpStat.GetMisc();
						
						lMisc &= MISC_NOT_PUMP_CHECK_AND_RESERVE;	// remove the misc from the pump

						pumpStat.SetMisc(lMisc);						
						m_cPumpArray[pTrs->m_lPump - 1].SetStat(pumpStat);
					}
				}
			}	
			break;
			case TRS_LINK_OLA_NUMBER:
			{
				*pRtc = TrsLinkOperation(REC_DELETE,pTrs,NULL);
				m_cPumpArray[lPumpNumber-1].ClearOlaStat();
				if(*pRtc)
					lRtc = 1;
			}
			break;
		}

		m_cPumpArray[lPumpNumber - 1].ClearTrs(pTrs->m_lNumber);
		SavePumpInfo(lPumpNumber);
		m_cShiftLog.LogTrs(pTrs,TRUE,TRUE,FALSE);
	}
	else
		lRtc = 2; 

	return lRtc;
}


void CServerMain::DoAutomaticPrePay__()
{
	__try
	{
		DoAutomaticPrePay();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticPrePay")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticPrePay()", LOG_LEVEL_0);

		exit(1);
	}
}

/******************************************************************************
 Description:	Scan pump array for available PrePay transactions and process 
                them.
 Returns:      	void
 Parameters:   	None.
 Assumptions:   Reauthorization of a PrePay on a requesting pump is blocked
                in AuthorizeAndLimit if CPump::m_dwAllowPrepayOnRequesting is 0.
 
 WHO			         WHEN                    WHAT
-------------------------------------------------------------------------------
 Eyal 4.0.0.5			20/5/2002   11:16		Modify
 Eyal 4.0.0.73          31/7/2002   12:45       Added if(m_dwPrePayEnabled)
******************************************************************************/

void CServerMain::DoAutomaticPrePay()
{
	
	// 1. Auto Reserve Pump For Prepay at POS
	// 2. Auto Authorize pump 
	// 3. Auto Timeout and cancel reservation 

	int iPosition=0;
	BOOL bDoReserve, bDoAuthorize,bDoTimeOut,bChanged;
	CString sLogMsg;

	if(m_dwPrePayEnabled)  //4.0.0.73
	{		
		for(int p =0; p< m_lLastValidPump; p++)  //4.0.0.79
		{
			// M.L 1/5/98 START: Change Locking at Automatic PrePay  
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

			// M.L 1/5/98 END

			bDoReserve = FALSE;
			bDoAuthorize = FALSE;
			bDoTimeOut	= FALSE;
			bChanged = FALSE;

			
			short nPrePayWaiting =0,nFree =0,nUnpaid =0;
			m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting,&nFree,&nUnpaid);

			switch(m_lAutoState[p])
			{
				//(check who come first)
				case PUMP_NONE_FIRST:
				//====================================================
				{
					// if any trs is waiting (WAIT_RES,WAIT_AUTH,WAIT_PROGRESS, IN_PROGRESS+AUTHORIZED)
					if(nPrePayWaiting) //m_cPumpArray[p].AnyWaitingTrs(WAIT_RES,&iPosition))
					{
						m_lAutoState[p] = PUMP_WAIT_FIRST;
						if(LOG_BASIC_FLOW_CONTROL)
						{
							sLogMsg.Format("Wait First");
							m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
						}
					}
					
					// else if pump status is ready and not reserved
					else if (m_cPumpArray[p].CanReserveForPrePay())
					{
						m_lAutoState[p] = PUMP_READY_FIRST;				
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							sLogMsg.Format("Ready First ");
							m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
						}
					}				
				}
				break;

				// Act as if ready come first
				case PUMP_READY_FIRST:
				//====================================================
				{
					CPumpTransact trs;
					if(m_cPumpArray[p].GetNextWaitingTrs(&trs))
					{
						if(trs.GetStatus() == WAIT_RES)
						{
						// if any trs status == wait_res 
						//		if pump can still be reserved
						//			send reserve pump
						//			change trs status to wait_auth
						//		else
						//			m_lAutoState[p] = PUMP_NONE_FIRST;
						//


							// M.L 7.7.98
							// If pump already reserved for pre pay and we have only one 
							// waiting transaction - let the process go.
							//
							if(	(m_cPumpArray[p].CanReserveForPrePay()) ||
								(m_cPumpArray[p].AlreadyReserveForSinglePrePay())
							  )
							
							{
								bDoReserve = TRUE;
							}
							else
							{
								m_lAutoState[p] = PUMP_NONE_FIRST;
								if(LOG_BASIC_FLOW_CONTROL)
								{
									//CString str;
									sLogMsg.Format("(1)PUMP_READY_FIRST to PUMP_NONE_FIRST");
									m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
								}
							}
						}
						else // trs not any more WAIT_RES
						{
							PumpReservation res = m_cPumpArray[p].GetStat().GetRes();
							if(res == PRE_PAY_AT_POS)
							{
								if(trs.GetStatus() == WAIT_AUTH)
								{											
									bDoAuthorize = TRUE;
								}
								else if(trs.GetStatus() == WAIT_PROGRESS) // M.L remove checking ||(trs.GetStatus() == IN_PROGRESS))
								{
									bDoTimeOut = TRUE;
								}
							}
							else if ((trs.GetStatus() == WAIT_PROGRESS) && (trs.GetLinkFlags() & TRS_LINK_CASH_ACCEPTOR_INFO)) //4.0.1.40
							{
								m_lAutoState[p] =PUMP_WAIT_FIRST; 
								CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);									
							}
							// PumpSrv 2.3.1.8 - change order of "if" statements 
							// check first for timeout, then asume that we lost
							else if((m_cPumpArray[p].CanReserveForPrePay())&&(trs.GetStatus() == WAIT_AUTH )) // M.L 30/04/98
							{
								bDoTimeOut = TRUE;
							}
							else if(res != NULL_RES)  // another owner win in the competition of reserving the pump.
							{

								trs.SetStatus(WAIT_RES);
								m_lAutoState[p] = PUMP_NONE_FIRST;
								CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
								
								if(LOG_BASIC_FLOW_CONTROL)
								{
									sLogMsg.Format("(2)PUMP_READY_FIRST to PUMP_NONE_FIRST");
									m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
								}
							}
						}
					}				
					
					// if no wait trs and reserved by other (PAP, PAK..)
					// start from biginig (check who come first)
					// m_lAutoState[p] = PUMP_NONE_FIRST;
					else if (!m_cPumpArray[p].CanReserveForPrePay())
					{					
						m_lAutoState[p] = PUMP_NONE_FIRST;

						if(LOG_BASIC_FLOW_CONTROL)
						{
							sLogMsg.Format("(3)PUMP_READY_FIRST to PUMP_NONE_FIRST");
							m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
						}
					}							
					break;
				}

				// Act as if wait trs come first
				case PUMP_WAIT_FIRST: 
				//====================================================
				{				
					CPumpTransact nextTrs;
					if(m_cPumpArray[p].GetNextWaitingTrs(&nextTrs))
					{

						if(nextTrs.GetStatus() == WAIT_RES)
						{	
							// if pump status is ready , not reserved 
							// if any trs status == wait_res
							// send reserve pump
							// change the waiting trs status to wait_auth

							// M.L 7.7.98
							// If pump already reserved for pre pay and we have only one 
							// waiting transaction - let the process go.
							//
							if(	(m_cPumpArray[p].CanReserveForPrePay()) ||
								(m_cPumpArray[p].AlreadyReserveForSinglePrePay())
							  )
							{
								bDoReserve = TRUE;

								//4.0.0.52 (3.2.1.32) added log message.
								if(LOG_DETAIL_FLOW_CONTROL)
								{
									sLogMsg.Format("DoAutomaticPrePay, found trs %d with status %d and reservation %d",
												   nextTrs.m_lLinkNumber,
												   m_cPumpArray[p].GetStat().GetStatus(),
												   m_cPumpArray[p].GetStat().GetRes());
									m_cLogger.LogMsg(p+1,LOG_PUMP,sLogMsg);
								}
							}

						}
						else 
						{		
							CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

							CPumpStatus stat = m_cPumpArray[p].GetStat();
							PumpReservation res = m_cPumpArray[p].GetStat().GetRes();

							if (nextTrs.GetStatus() == WAIT_AUTH)
							{						
								if(res == PRE_PAY_AT_POS)
								{
								// if any trs status == wait_auth
								// and pump is reserved for pre pay at pos				
								// change pump status to REQUESTING

									if((stat.GetStatus() == READY) ||
										(stat.GetStatus() == NOZZLE_LEFT_OUT))  //4.0.3.50
									{
										if (stat.GetResExt() !=  RES_EXT_FLEET)  //4.0.10.506
										{
											if(LOG_BASIC_FLOW_CONTROL)
											{
												CString str;
												str.Format("(Auto PrePay), switch to REQUESTING");
												m_cLogger.LogMsg(p+1,LOG_PUMP,str);
											}

 											stat.SetStatus(REQUESTING);
											m_cPumpArray[p].SetStat(stat);
										}
										else
											bDoAuthorize = TRUE ;   //4.0.10.48 

										bChanged = TRUE;

										//Eyal 4.0.0.47 (3.2.0.93) Start
										//Changes made on version 4.0.0.44
										//This point can be reached with a transaction
										//that has been timed out at some stage, or a transaction
										//that has never been timed out.  If a transaction
										//has been timed out, either because no auto authorization
										//has been enabled, or because the transaction timed out, or
										//because the pump was stopped, we would like to fully
										//authorize the transaction.

										if(nextTrs.m_lMisc & MISC_PREPAY_TIMED_OUT)
										{
											if(LOG_DETAIL_FLOW_CONTROL)
											{
												CString sMsg;
												sMsg.Format("DoAutomaticPrepay, found READY, reauthorizing trs no. %d", nextTrs.m_lLinkNumber);
												m_cLogger.LogMsg(p+1,LOG_PUMP,sMsg);
											}
											
											bDoAuthorize = TRUE;
										}
										//Eyal 4.0.0.47 End
									}

									//Eyal 4.0.0.5 start
									//If the pump is already REQUESTING, authorize it.
									//We cannot reach this point if no authorization
									//is allowed on a REQUESTING pump, because the
									//authorization is blockde by AuthorizeAndLimit()
									else if(stat.GetStatus() == REQUESTING)
									{
										if(nextTrs.m_lMisc & MISC_PREPAY_TIMED_OUT)
										{
											if(LOG_DETAIL_FLOW_CONTROL)
											{
												CString sMsg;
												sMsg.Format("DoAutomaticPrepay, found REQUESTING, reauthorizing trs no. %d", nextTrs.m_lLinkNumber);
												m_cLogger.LogMsg(p+1,LOG_PUMP,sMsg);
											}
											
											bDoAuthorize = TRUE;
										}
										bDoAuthorize = TRUE; //4.0.9.507
									}
									//Eyal 4.0.0.5 end
								}
								else if(res != NULL_RES) // another owner win in the competiton of reserving the pump.
								{

									nextTrs.SetStatus(WAIT_RES);
									
									m_lAutoState[p] = PUMP_NONE_FIRST;
									CentralUpdateTrs(p+1,nextTrs.m_lNumber,&nextTrs,FALSE);

								}
								else if(m_cPumpArray[p].CanReserveForPrePay()) // M.L 30/04/98
								{
									bDoTimeOut = TRUE;

								}
							}

							else if(nextTrs.GetStatus() == WAIT_PROGRESS) // M.L remove checking ||(trs.GetStatus() == IN_PROGRESS))
							{
								if(res == PRE_PAY_AT_POS)
								{				
									// if any trs status == wait_progress or in_progress
									// while pump is reserved for pre pay at pos				
									// count time out

									bDoTimeOut = TRUE;

								}
								else  if ((nextTrs.GetStatus() == WAIT_PROGRESS) && (nextTrs.GetLinkFlags() & TRS_LINK_CASH_ACCEPTOR_INFO)) //4.0.1.40
								{
									bDoTimeOut = TRUE;
								}
								else if(res != NULL_RES)
								{
									if(LOG_BASIC_FLOW_CONTROL)
									{
										CString str;
										str.Format("(Auto PrePay), switch back to WAIT_RES");
										m_cLogger.LogMsg(p+1,LOG_PUMP,str);
									}
									nextTrs.SetStatus(WAIT_RES);
									m_lAutoState[p] = PUMP_NONE_FIRST;
									CentralUpdateTrs(p+1,nextTrs.m_lNumber,&nextTrs,FALSE);

									if(LOG_BASIC_FLOW_CONTROL)
									{
										CString str;
										str.Format("(4)PUMP_WAIT_FIRST to PUMP_NONE_FIRST");
										m_cLogger.LogMsg(p+1,LOG_PUMP,str);
									}
								}
							}
						}
						
						// the GPI::AuthorizePump command will ditect 
						// that there is wait_auth trs and :
						// 1. change the trs status to wait_progres
						// 2. return pump to ready
						// 3. set trs time to current time.
						// 4, send authorize and limit instead of authorizePump.
							
					}
					else
					{
						// if none of above 
						// m_lAutoState[p] = PUMP_NONE_FIRST;

						m_lAutoState[p] = PUMP_NONE_FIRST;
					}
					// else wait			

				break;				
				}
			}


			if(bDoReserve)
			{
				CPumpTransact trs;
				m_cPumpArray[p].GetNextWaitingTrs(&trs);
				PumpReservation res = m_cPumpArray[p].GetStat().GetRes(); //4.0.15.501
				CPumpStatus stat = m_cPumpArray[p].GetStat(); ////4.0.15.501


				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Reserve (Auto PrePay) switch to WAIT_AUTH");
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);
				}

				trs.SetStatus(WAIT_AUTH);
				trs.UpdateTime();
				

				// M.L 7.7.98
				// Send command only if pump can be reserved
				if(m_cPumpArray[p].CanReserveForPrePay() &&
					!(m_cPumpArray[p].AlreadyReserveForSinglePrePay() && (res == PRE_PAY_AT_POS))) //4.0.17.500
					/*(stat.GetStatus()  && (res == PRE_PAY_AT_POS))*/
				{
					CMD_STRUCT_RESERVE_PUMP cmdInfo;
					cmdInfo.lRes = PRE_PAY_AT_POS;
					if (trs.m_lResExt == RES_EXT_CASH_ACCEPTOR)  //4.0.10.506
							cmdInfo.lResExt = RES_EXT_CASH_ACCEPTOR;
						else
							cmdInfo.lResExt = trs.GetOnOffer();
					cmdInfo.lResExt = trs.GetOnOffer();
 					SetCommand(CMD_RESERVE_PUMP, trs.GetOnOffer(), p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
				}

				CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
			}


			if(bDoAuthorize)
			{
				CPumpTransact trs;
				m_cPumpArray[p].GetNextWaitingTrs(&trs);

				m_lPrePayReTryReservation[p]= TIME_BETWEEN_RETRYING_RESERVED_PRE_PAID_PUMP;  //4.0.24.351 //4.0.124.355 //4.0.27.60 231255

				if (!(trs.m_lMisc & MISC_PUMP_CHECK_AND_RESERVE))
				{

					// if any trs status == wait_auth
					// and pump is reserved for pre pay at pos
					//		send authorize and limit 
					//		change trs status to wait_progress
					//		and set trs time to current time.
					// if trs status is wait_auth and pump is reserved for other
					//		change trs status back to wait_res
					//		m_lAutoState[p] = PUMP_WAIT_FIRST;			

					PRE_PAY_INFO info;
					if(TrsLinkOperation(REC_READ, &trs, &info))
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Authorize (Auto PrePay), Cant find PrePay TRS link information");
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}
					}
					else
					{
						long lRtc =0;
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Authorize (Auto PrePay), switch to WAIT_PROGRESS");
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}

						trs.SetStatus(WAIT_PROGRESS);
						trs.UpdateTime();

						trs.m_lMisc &= MISC_NOT_PREPAY_TIMED_OUT;

						CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);

						CMD_STRUCT_AUTHORIZE_LIMIT cmdInfo;
						memset( &cmdInfo, 0, sizeof(cmdInfo) );

						cmdInfo.nLevel = info.nLevel;
						cmdInfo.lGradePrice = info.lGradePrice;
						cmdInfo.lMaxValue = info.lMaxValue;
						cmdInfo.lMaxVolume = info.lMaxVolume;
						cmdInfo.lSyncNumber = info.lSyncNumber;
						cmdInfo.lFlags = info.lFlags;

						memset(cmdInfo.lDiscountArray, 0, sizeof(cmdInfo.lDiscountArray));

						if (info.lFlags & LOYALTY_DISCOUNT_DATA)  //4.0.9.507
						{							
							EXTRA_INFO_REC rec;
							memset(&rec, 0 , sizeof(rec));
							rec.info.lIndexNumber = trs.m_lNumber;					
							lRtc = IndexOperation(EXTRA_INFO_FILE , REC_READ, &rec);	
							
							if (!lRtc) 
							{
								memcpy(cmdInfo.lDiscountArray, rec.info.lDiscountArray, sizeof(cmdInfo.lDiscountArray));
								memcpy(cmdInfo.sDiscountType, rec.info.sDiscountType, sizeof(cmdInfo.sDiscountType));  //4.0.6.502
								cmdInfo.lLoyaltyVolumeLimit = a2l(rec.info.sLoyaltyVolumeLimit, sizeof(rec.info.sLoyaltyVolumeLimit)); //4.0.20.450 66977 //4.0.21.501
								cmdInfo.lFlags |= LOYALTY_DISCOUNT_DATA; //4.0.23.270 111746 //4.0.24.60
							}
						}
						else if (info.lFlags & LIMIT_FLEET)
						{
							//4.0.9999.0
							EXTRA_INFO_REC1 rec;
							memset(&rec, 0 , sizeof(rec));
							rec.info.cExtraInfo.lIndexNumber = trs.m_lNumber;					
							lRtc = IndexOperation(EXTRA_INFO_FILE , REC_READ, &rec);
							memset(cmdInfo.lDiscountArray , 0 , sizeof(cmdInfo.lDiscountArray));
							
							if (!lRtc) 
							{

								if(LOG_BASIC_FLOW_CONTROL)
								{	
									CString sMsg;

									sMsg.Format("Fleet Prepay info : discount1=%ld , discount2=%ld", rec.info.cDieselInfo.cItem1.lDiscount, rec.info.cDieselInfo.cItem2.lDiscount);
									m_cLogger.LogMsg(p + 1, LOG_PUMP, sMsg);
								}

								memset(cmdInfo.sDiscountType , ' ' , sizeof(cmdInfo.sDiscountType));
								cmdInfo.lDiscountArray[rec.info.cDieselInfo.cItem1.lGrade -1] = rec.info.cDieselInfo.cItem1.lDiscount;
								cmdInfo.lDiscountArray[rec.info.cDieselInfo.cItem2.lGrade -1] = rec.info.cDieselInfo.cItem2.lDiscount;

								cmdInfo.lTotalAmount  = rec.info.cDieselInfo.cItem1.lTotalAmount; //4.0.10.130

								cmdInfo.lPreviousFueledAmount = rec.info.cDieselInfo.cItemSold1.lValue; //4.0.10.130
								cmdInfo.lGradePrice = (rec.info.cDieselInfo.cItemSold1.lValue)? rec.info.cDieselInfo.cItem2.lGradePrices : rec.info.cDieselInfo.cItem1.lGradePrices; //4.0.10.131

								if (rec.info.cDieselInfo.cItem1.lDiscount || rec.info.cDieselInfo.cItem2.lDiscount)
									cmdInfo.lFlags |= LOYALTY_DISCOUNT_DATA;
							}
						}
						if (info.lFlags & PREPAY_INCLUDES_GRADES_RESTRICTIONS) //4.0.23.270 111746 //4.0.24.60
						{
							EXTRA_INFO_REC rec;
							memset(&rec, 0 , sizeof(rec));
							rec.info.lIndexNumber = trs.m_lNumber;					
							lRtc = IndexOperation(EXTRA_INFO_FILE , REC_READ, &rec);	
							
							if (!lRtc) 
							{
								cmdInfo.lFlags |= PREPAY_INCLUDES_GRADES_RESTRICTIONS; 
								memcpy(cmdInfo.GradeAmountLimit, rec.info.GradeAmountLimit, sizeof(cmdInfo.GradeAmountLimit));  //4.0.23.723 //4.0.25.503 144328
								
							}
						}
						if (info.lFlags & PREPAY_WITH_LOYALTY_PRICE_PROTECTION)
						{
							trs.m_sLoyaltyAutoArm = '1';
							if (TRUE == BuildPriceProtectionDiscounts(p + 1, cmdInfo.lDiscountArray))
							{
								trs.m_sLoyaltyPriceProtection = '1';
							}

							if (LOG_BASIC_FLOW_CONTROL)
							{
								CString sMsg;
								sMsg.Format("DoAutomaticPrePay() - PREPAY_WITH_LOYALTY_PRICE_PROTECTION - LoyaltyAutoArm = %c, LoyaltyPriceProtection = %c", trs.m_sLoyaltyAutoArm, trs.m_sLoyaltyPriceProtection);
								m_cLogger.LogMsg(p + 1, LOG_PUMP, sMsg);
							}
							CentralUpdateTrs(p + 1, trs.m_lNumber, &trs, FALSE);
						}
						SetCommand(CMD_AUTHORIZE_LIMIT, SERVER_POS_NUMBER, p + 1, &cmdInfo, sizeof(CMD_STRUCT_AUTHORIZE_LIMIT));
					}
				}
			}

			if(bDoTimeOut)
			{

				CPumpTransact trs;
				m_cPumpArray[p].GetNextWaitingTrs(&trs);
				CPumpStatus stat = m_cPumpArray[p].GetStat(); //4.0.27.31 merge from 4.0.24.341

				// if any trs status == in_progress or wait_progres
				// and times out
				//		send release pump
				//		change trs status to timeout	
				//		m_lAutoState[p] = PUMP_NONE_FIRST;

				CTime t1 = CTime::GetCurrentTime();
				CTimeSpan ts;

				m_lPrePayReTryReservation[p]= TIME_BETWEEN_RETRYING_RESERVED_PRE_PAID_PUMP;  //4.0.24.351 //4.0.124.355 //4.0.27.60 231255
				ts = t1 - trs.GetTime();

				if ((trs.GetStatus() == WAIT_PROGRESS) && (stat.GetStatus()  !=  OUT_OF_SERVICE))  //4.0.27.31 - Do not timed out on offline pump 4.0.24.341 TD 223847
				{
					BOOL bSecondFleet = FALSE;

					// M.L 12.7.98 change MAX_WAIT_PROGRESS_TIMEOUT into external parametr
					if (((ts.GetTotalSeconds() >= (long)m_dwPrePayAuthorizedTimeOut) || 
						 (bSecondFleet && (ts.GetTotalSeconds() >=  (long)m_dwSecondTrsAuthTimeout))) //4.0.6190.2000
 						 && (!(trs.GetLinkFlags() & TRS_LINK_CASH_ACCEPTOR_INFO))) //342690 ignore prepay timeout for a cash acceptor transactions
					{
						long lRtc;
						int iRetNum = WideCancelTrs(SOURCE_INTERNAL, p+1, trs.m_lNumber, &lRtc);					
		
						if (iRetNum != TRS_CANT_CANCEL) // if not too late
						{
							if(LOG_BASIC_FLOW_CONTROL)
							{
								CString str;
								str.Format("TimeOut on WAIT_PROGRESS !!! (Auto PrePay), switch to WAIT_TIME_OUT (trs %d:%d) ",trs.GetTime().GetMinute(),trs.GetTime().GetSecond());
								m_cLogger.LogMsg(p+1,LOG_PUMP,str);
							}

							//trs.SetStatus(WAIT_TIME_OUT);
							//4.0.11.507
							if (trs.GetLinkFlags() & TRS_LINK_CASH_ACCEPTOR_INFO) //4.0.11.117
							{
								trs.SetStatus(PAID);
								m_cPumpArray[p].IncreaseUnBalancePrePayCounter();  //4.0.11.509
							}
							else
								trs.SetStatus(WAIT_TIME_OUT);


							//Eyal 4.0.0.47 (3.2.0.93)
							//Store time out in trs history
							trs.m_lMisc |= MISC_PREPAY_TIMED_OUT;

							m_lAutoState[p] = PUMP_NONE_FIRST;							
							CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
						}
					}					
				}

				else if(trs.GetStatus() == WAIT_AUTH && !(trs.m_lMisc & MISC_PUMP_CHECK_AND_RESERVE)) // M.L 30/04/98 //4.0.17.20 - TD 26834
				{
					if (ts.GetTotalSeconds() >= MAX_WAIT_AUTH_TIMEOUT)
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("TimeOut on WAIT_AUTH !!! (Auto PrePay), switch to back to WAIT_RES");
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}

						trs.SetStatus(WAIT_RES); // Back to wait res

						CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
						m_lAutoState[p] = PUMP_NONE_FIRST;							
					}					
				}
			}

			if(bChanged) 
				SavePumpInfo(p+1);

			// M.L 1/5/98 START: Change Locking at Automatic PrePay  		
			
			// M.L 1/5/98 END
			Sleep(0);
		}

	}
//	m_cLogger.LogLocationOut("DoAutomaticPrePay()");
}

CCmdInfo CServerMain::GetNextCmdInQ()
{
	CSingleLock slCmdQ( &m_csCmdQ );
	slCmdQ.Lock(INFINITE); // if resource is currently locked - wait infinite time 
						   // until resource is unlocked.	
	return 	(m_cCmdQ.GetTail());	
}

int CServerMain::FindTrsByLinkNumber(CPumpTransact * pTrs)
{
	int iRetNum = 1; // not found	
	int iArraySize;
	CPumpTransact trs;


	if(pTrs->m_lNumber != 0)
	{
		for (int p=0; p< m_lLastValidPump; p++)  //4.0.0.79
		{
			iArraySize = m_cPumpArray[p].GetTrsArraySize();
			
			if(iArraySize)
			{
				for (int i=0; i<iArraySize; i++)
				{
					m_cPumpArray[p].GetTrsByIndex (i,&trs);
					if( (trs.GetLinkFlags() == pTrs->GetLinkFlags()) &&
						(trs.GetLinkNumber() == pTrs->GetLinkNumber()) &&
						(trs.GetStatus() != PAID)  )
						
					{
						iRetNum = 0; // found
						if(pTrs != NULL)
							*pTrs = trs;
						break;
					}
				}
			}
		}
	}	
	return iRetNum;
}


void CServerMain::DoAutomaticOLA__()
{
		if ( OLA_BY_PUMPSRV )
			DoAutomaticOLA();
}
/******************************************************************************
 Description: Treat OLA activities	 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			7/5/2007   11:17		
******************************************************************************/

void CServerMain::DoAutomaticOLA()
{  
	CString sMsg;
	long lResult;

	lResult = 0;

	//4.0.2.33 - removed code limiting OLA retries to remote OLA.

	if (GetIFSFTerminalSrvInUse()) //4.0.19.504 - 47559
		return;
	
	//4.0.2.15
	if(m_cOLASrv && (0 == m_cOLASrv->GetRetryAttempts()))
	{
		//4.0.2.37 OLARetries no longer read from registry
		if(m_cOLASrv->NoMoreRetries())
			return;

		else
			m_cOLASrv->SetNoMoreRetries(TRUE);
	}
	if (_Module.m_server.m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())
	{
		OLA_STAT			ola;
		m_lCheckLoyaltyTimeout += THRD_SLEEP_TIME; // 4.0.23.2100
		if (m_lCheckLoyaltyTimeout >= TIME_BETWEEN_LOYALTY_TIMEOUT_CHECK)  //RFUEL-2187
		{
			for (int p = 0; p < m_lLastValidPump; p++)
			{
				m_cPumpArray[p].GetOlaStat(&ola);
				DoAutomaticLoyaltyTimeout__(p + 1, &ola);
			}

			m_lCheckLoyaltyTimeout = 0;
		}
	}

	for(int p =0; p< m_lLastValidPump; p++)  //4.0.0.79
	{
		OLA_STAT			ola;

		//3.2.1.58
		if (GetOLAThreadState() == OLA_SERVER_WAIT_FOR_KILL)
		{
			_LOGMSG.LogMsg(p+1,LOG_PUMP,"DoAutomaticOLA, OLA state WAIT to KILL", LOG_LEVEL_0);	
			CheckOLA();
		}

		// recreate service if needed
		m_cOLASrv->RecreateService();



		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		//4.0.5.39
		if(m_cOLASrv->Valid())
		{
			//Checking if the pump waits to be logged in
			if(PUMP_WAIT_TO_BE_LOGIN == m_cPumpArray[p].GetPumpLoginOp() )
			{
				//Logging in
				
				lResult = m_cOLASrv->Login(PUMP_LOGIN, p+1);
				if(lResult != 0)
				{
					sMsg.Format("DoAutomaticOLA, tried to perform Login unsuccessfully, Return Code: %d", lResult );
					_LOGMSG.LogMsg(p + 1, LOG_PUMP, sMsg);
				}
				//Setting the pump's login state to PUMP_LOGIN
				m_cPumpArray[p].SetPumpLoginOp(PUMP_LOGIN); 
			}
			else
			{
				//Checking if the pump waits to be logged out
				if(PUMP_WAIT_TO_BE_LOGOUT == m_cPumpArray[p].GetPumpLoginOp() )
				{
					//Logging out 

					lResult = m_cOLASrv->Login(PUMP_LOGOUT, p+1);
					if(lResult != 0)
					{
						sMsg.Format("DoAutomaticOLA, tried to perform Logout unsuccessfully, Return Code: %d", lResult );
						_LOGMSG.LogMsg(p + 1, LOG_PUMP, sMsg);
					}
					//Setting the pump's login state to PUMP_LOGOUT
					m_cPumpArray[p].SetPumpLoginOp(PUMP_LOGOUT);
					
				}
			}
		}
			m_cPumpArray[p].GetOlaStat(&ola);
		
		
			if( OLA_STATE(ola.m_byState) )
			{
				//4.0.18.501
				PAY_AT_PUMP_INFO info;

				m_cPumpArray[p].GetPAPInfo(&info); //4.0.17.0

				switch(OLA_STATE(ola.m_byState))
				{
					case OLA_REQUEST_TO_SEND:
						if (info.CardSaleExtraData3.sWaitForPriceChange != '1')	//4.0.18.501 info.GetXmlByteField(ATT_WAIT_FOR_PRICE_CHANGE) != '1') 
							DoAutoOLARequestToSend(p+1,&ola,&info);
						break;
					case OLA_WAIT_RESPONSE:
						DoAutoOLAWaitResponse(p+1,&ola,&info);
						break;
					case OLA_WAIT_FOR_MORE_INFO:
						DoAutoOLAWaitForMoreInfo(p+1,&ola,&info ,&m_cOLADebitMessageTimeout[TIME_OUT_USUAL_SESSION][p]);		
						break;
	 				case OLA_REQUEST_TO_SEND_MORE:					 
						DoAutoOLARequestToSendMore(p+1,&ola,&info);		
						break;					
					case OLA_SEND_END:
					{						
						OLA_STAT  cPreviousOlaState = ola;
						DoAutoOLASendEnd(p + 1, &ola, &info);
						DoAutoOLAProcessAfterSendEnd(p + 1, cPreviousOlaState, ola, info);
						break;
					}
					case OLA_LOYALTY_START_TICKET://amram
						DoAutoOlaFuelLoyaltyStartTicket(p+1,&ola,&info);
						break;
					case OLA_LOYALTY_WAIT_RESPONSE://amram
					case OLA_LOYALTY_WAIT_END_TICKET_RESPONSE:
						break;												
						
					case OLA_LOYALTY_APPLY_PAYMENT_DISCOUNT:
						// RFUEL-2817 - 
						DoAutoOlaFuelLoyaltyNMPSessionsAfterPayDiscount(p + 1, &ola, &info);
						break;
					case OLA_LOYALTY_ADD_MEMBER_CARD:	//4.0.22.504 69344
						DoAutoOlaFuelLoyaltyAuthorizeLoyalty(p+1,&ola,&info);
						break;
					case OLA_LOYALTY_RUN_QUERY:	//4.0.22.504 69344
						DoAutoOlaFuelLoyaltyRunQuery(p+1,&ola,&info);
						break;
					case OLA_LOYALTY_END_TICKET://amram
						DoAutoOlaFuelLoyaltyEndTicket(p+1,&ola,&info);
						break;
					case OLA_LOYALTY_CANCEL_TICKET_AFTER_START_TICKET://Liat Copient 55286 + Rtaps 59557
						DoAutoOlaFuelLoyaltyCancelTicket(p+1,&ola,&info);
						break;
					case OLA_LOYALTY_START_NMP_BEFORE_FUELING_BEFORE_START_TICKET: //Liat Copient 55286
					case OLA_LOYALTY_START_NMP_BEFORE_FUELING_AFTER_START_TICKET:
						m_cFlowControlManager.HandleNMPSessions(p+1, &ola, &info, TRUE);
						break;
					case OLA_LOYALTY_START_FUELING:
						DoAutoOlaFuelLoyaltyStartFueling(p+1, &ola, &info);
						break;
					case OLA_LOYALTY_WAIT_PHONE_LOOKUP_RESPONSE: //4.0.23.1220 155754 
					case OLA_LOYALTY_WAIT_ADD_MEMBER_INFO_RESPONSE:  //4.0.23.2280 305114 
					case OLA_LOYALTY_WAIT_GET_MEMBER_INFO_RESPONSE:
						break;
				}

			}		
			else   //4.0.2.15
			{
				// use only one session  
				if(UseSingleSession() && 
				  (m_cPumpArray[p].GetStat().GetRes() == NULL_RES))
				{
					if ((!m_cInitDebitHandler.GetWorkingPump()) && 
						(m_cInitDebitHandler.GetStatus(p +1)  == DEBIT_SERVER_REQUEST_TO_START ))  //4.0.3.58					
					{
						PAY_AT_PUMP_INFO	PayAtPumpInfo;
						memset(&PayAtPumpInfo , ' ' , sizeof(PAY_AT_PUMP_INFO));
						m_cDebitInfoArray[p].ConvertPAP2DebitInfo(&PayAtPumpInfo);

						ola.m_byState = OLA_REQUEST_TO_SEND | SESSION_INIT_DEBIT;
						ola.m_lSessionNumber = 0;
						
						m_cInitDebitHandler.SetWorkingPump(p +1);
						m_cInitDebitHandler.SetStatus(p + 1, DEBIT_SERVER_INPROCESS); //4.0.3.58

						m_cDebitInfoArray[p].SetOlaStat(&ola);

						sMsg.Format("init debit for in single session");
						m_cLogger.LogMsg(p+1,LOG_PUMP,sMsg);
					}
				}
			}		
			//4.0.2.15
		

		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
	}

	
	for(int p = 0; p< m_lLastValidPump; p++)  //4.0.0.79
	{
		OLA_STAT			ola;
		PAY_AT_PUMP_INFO	info;	//4.0.18.501
		
		m_cOLASrv->RecreateService();

		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		m_cDebitInfoArray[p].GetOlaStat(&ola);
		m_cDebitInfoArray[p].ConvertDebitInfo2PAP(&info , (long)(p+1));
		
		if( OLA_STATE(ola.m_byState) )
		{
			switch(OLA_STATE(ola.m_byState))
			{//4.0.18.501
				case OLA_REQUEST_TO_SEND:
					DoAutoOLARequestToSend(p+1,&ola,&info);		
					//DoAutoOLARequestToSend(p+1,&ola,&cXmlInterface);		
					break;
				case OLA_WAIT_RESPONSE:
					DoAutoOLAWaitResponse(p+1,&ola,&info);		
					break;
				case OLA_WAIT_FOR_MORE_INFO:
					DoAutoOLAWaitForMoreInfo(p+1,&ola,&info , &m_cOLADebitMessageTimeout[TIME_OUT_BEBIT_SESSION][p]);		
					break;
	 			case OLA_REQUEST_TO_SEND_MORE:					 
					DoAutoOLARequestToSendMore(p+1,&ola,&info);		
					break;					
				case OLA_SEND_END:
					DoAutoOLASendEnd(p+1,&ola,&info);		
					break;					
			}			
		}
		else
		{
			if ((m_cInitDebitHandler.GetStatus(p+1)  == DEBIT_SERVER_REQUEST_TO_START ) &&  //4.0.3.58
				(!UseSingleSession()))
			{
				PAY_AT_PUMP_INFO	PayAtPumpInfo;
				memset(&PayAtPumpInfo , ' ' , sizeof(PAY_AT_PUMP_INFO));
				m_cDebitInfoArray[p].ConvertPAP2DebitInfo(&PayAtPumpInfo);								

				ola.m_byState = OLA_REQUEST_TO_SEND | SESSION_INIT_DEBIT;
				ola.m_lSessionNumber = 0; 				

				m_cInitDebitHandler.SetStatus(p + 1, DEBIT_SERVER_INPROCESS); //4.0.3.58

				m_cDebitInfoArray[p].SetOlaStat(&ola);
			}	
		}
	}

	for(int r = 0; r < MAX_REPORTS; r++)
	{
		OLA_STAT			ola;

		// recreate service if needed 
		m_cOLASrv->RecreateService();

		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
		EnterCriticalSection( &m_csReportArray );

		m_cReportArray[r].GetOlaStat(&ola);

		if( OLA_STATE(ola.m_byState) )
		{			
			//4.0.18.501
			PAY_AT_PUMP_INFO info;

			m_cReportArray[r].GetPAPInfo(&info);

			switch(OLA_STATE(ola.m_byState))
			{					 
				case OLA_REQUEST_TO_SEND:
					DoAutoOLARequestToSend(r+1,&ola,&info);		
					break;
				case OLA_WAIT_RESPONSE:
					DoAutoOLAWaitResponse(r+1,&ola,&info);		
					break;
				case OLA_WAIT_FOR_MORE_INFO:
					DoAutoOLAWaitForMoreInfo(r+1,&ola,&info);		
					break;
				case OLA_REQUEST_TO_SEND_MORE:
					DoAutoOLARequestToSendMore(r+1,&ola,&info);		
					break;					
				case OLA_SEND_END:
					DoAutoOLASendEnd(r+1,&ola,&info);		
					break;					
			}
		}

		LeaveCriticalSection(&m_csReportArray);
	}
}


//4.0.9.508	//4.0.18.501
long CServerMain::DoAutoOlaFuelLoyaltyStartTicket(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;

	trs.Clear();

	if(PUMPSRV_IS_MASTER)
	{
		// Creating a new PAP transaction 
		//-------------------------------
		if(SESSION_TYPE(pOla->m_byState) == (SESSION_AUTHORIZE))
		{//4.0.19.500 55286
			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_LOYALTY_WAIT_RESPONSE);
			m_cPumpArray[p].SetOlaStat(pOla);
			if (m_cFuelLoayaltyPS.IsCopientFlowControlInUse())	//Skip this stage for Copient	//4.0.22.504 69344	//4.0.22.508 74810
			{
				m_cFlowControlManager.StartAfterStartTicketFlowControl(lPumpNumber, pOla);//4.0.22.504 69344 If fail - continue to next NMP
			}
			else
			{
				if (FALSE == (m_cFuelLoayaltyPS.StartTicket(lPumpNumber, *pInfo))) // RFUEL - 1087
				{
					m_cFlowControlManager.StartAfterStartTicketFlowControl(lPumpNumber, pOla);//4.0.22.504 69344 If fail - continue to next NMP	
				}
			}

		}
	}

	m_cLogger.LogMsg(p+1,LOG_PUMP,"DoAutoOlaFuelLoyaltyStartTicket Finish");

	return lRtc;
}

long CServerMain::DoAutoOlaFuelLoyaltyAuthorizeLoyalty(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;

	trs.Clear();

	if(PUMPSRV_IS_MASTER)
	{
		// Creating a new PAP transaction 
		//-------------------------------
		if(SESSION_TYPE(pOla->m_byState) == (SESSION_AUTHORIZE))
		{
			//4.0.19.500 55286

			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_LOYALTY_WAIT_RESPONSE);
			m_cPumpArray[p].SetOlaStat(pOla);

			if (FALSE == (m_cFuelLoayaltyPS.AddMemberCard(lPumpNumber, *pInfo))) // RFUEL - 1087
			{
				CString sMsg;
				sMsg.Format(_T("%s:%d AddMemberCard Failed!"), __FUNCTION__, __LINE__);
				 m_cLogger.LogMsg(sMsg);
				m_cFlowControlManager.StartAfterAddMemberFlowControl(lPumpNumber, pOla, 0);//4.0.22.504 69344 If fail - continue to next NMP
			}
			m_cPumpArray[p].GetOlaStat(pOla);
		}
	}
	m_cLogger.LogMsg(p+1,LOG_PUMP,"DoAutoOlaFuelLoyaltyAuthorizeLoyalty Finish");
	return lRtc;
}


long CServerMain::DoAutoOlaFuelLoyaltyRunQuery(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)//4.0.22.504 69344
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;

	trs.Clear();

	

	if(PUMPSRV_IS_MASTER)
	{
		// Creating a new PAP transaction 
		//-------------------------------
		if(SESSION_TYPE(pOla->m_byState) == (SESSION_AUTHORIZE))
		{
			if(m_cFuelLoayaltyPS.IsNeedToAddMemberInfo(lPumpNumber)) // 4.0.23.2280 305114
			{
				AddMemberInfo(lPumpNumber, pOla, p);
			}
			else
			{
				if (m_cPumpArray[p].GetStat().GetResExt() == RES_EXT_PAK_LOYALTY)  //RFUEL-3195  Pak with loyalty
				{
					m_cFlowControlManager.StartAfterQueryFlowControl(lPumpNumber, *pOla, *pInfo);//4.0.22.504 69344 If fail - continue to next NMP
					m_cLogger.LogMsg(p + 1, LOG_PUMP, "DoAutoOlaFuelLoyaltyRunQuery:: Skip loyalty runQuery for PAK transaction");
				}
				else
				{
					if (m_cFuelLoayaltyPS.RunQuery(lPumpNumber, *pInfo))  // RFUEL - 1087
					{
						pOla->m_byState = OLA_NEW_STATE(pOla->m_byState, OLA_LOYALTY_WAIT_RESPONSE);
						m_cPumpArray[p].SetOlaStat(pOla);
					}
					else
					{
						m_cFlowControlManager.StartAfterQueryFlowControl(lPumpNumber, *pOla, *pInfo);//4.0.22.504 69344 If fail - continue to next NMP
					}
				}
				m_cLogger.LogMsg(p+1,LOG_PUMP,"DoAutoOlaFuelLoyaltyRunQuery Finish");
				
			}
		}
	}
	
	return lRtc;
}

long CServerMain::DoAutoOlaFuelLoyaltyContNMPSessionsAfterAuthPayment(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)	//4.0.22.500, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;
	CString sMsg;

	trs.Clear();

	if (pOla)
	{
		sMsg.Format("DoAutoOlaFuelLoyaltyContNMPSessionsAfterAuthPayment: ola state = 0x%x", pOla->m_byState);
		m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, sMsg);
	}

	if(PUMPSRV_IS_MASTER)
	{
		if (m_cFlowControlManager.IsNMPStartingTime(lPumpNumber))	//only if we were authorizing payment, we need to continue with the flow control
		{
			pOla->m_byState = OLA_LOYALTY_AUTHORIZE_PAYMENT;
			m_cPumpArray[p].SetOlaStat(pOla); 	
			m_cFlowControlManager.SetNMPTime(lPumpNumber,FALSE);
			sMsg.Format("continue flow control with state %s for pump %ld", _LOGMSG.GetStateString(pOla->m_byState), lPumpNumber);
			m_cLogger.LogMsg(sMsg);
			m_cFlowControlManager.HandleNMPSessions(p+1, pOla, pInfo, TRUE);
		}
	}


	return lRtc;
}

long CServerMain::DoAutoOlaFuelLoyaltyNMPSessionsAfterPayDiscount(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{	
	const long PumpIndex = lPumpNumber - 1;
	long				lRtc = 0;
	if (PUMPSRV_IS_MASTER)
	{	
		auto& Pump =_Module.m_server.GetPump(lPumpNumber);
		pOla->m_byState = OLA_NEW_STATE(pOla->m_byState, OLA_LOYALTY_WAIT_RESPONSE);
		Pump.SetOlaStat(pOla);

		if (FALSE == (m_cFuelLoayaltyPS.AddMemberCard(lPumpNumber, *pInfo))) // RFUEL - 1087
		{
			CString sMsg;
			sMsg.Format(_T("%s:%d AddMemberCard Failed!"), __FUNCTION__, __LINE__);
			m_cLogger.LogMsg(sMsg);
			m_cFlowControlManager.StartAfterAddMemberFlowControl(lPumpNumber, pOla, 0);//4.0.22.504 69344 If fail - continue to next NMP
		}

		//{
		//	CString sMsg;
		//	sMsg.Format(_T("%s:%d Loyalty Card Discount Flag setting"), __FUNCTION__, __LINE__);
		//}

		Pump.GetOlaStat(pOla);

		
		// Set discount applied flag only if loyalty card was swiped
		if (_Module.m_server.IsLoyaltycardAuthorized(*pInfo)) {
			SetLoyaltyDiscountApplied(lPumpNumber, LOYALTY_DISCOUNT_APPLIED);

			Pump.SetPAPInfo(pInfo);
		}		
	}

	m_cLogger.LogMsg(lPumpNumber - 1, LOG_PUMP, "DoAutoOlaFuelLoyaltyNMPSessionsAfterPayDiscount Finish");

	return lRtc;
}

//4.0.22.500 70767
long CServerMain::DoAutoOlaFuelLoyaltyStartFueling(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;

	trs.Clear();

	PumpReservation res = m_cPumpArray[p].GetStat().GetRes();

	if((PUMPSRV_IS_MASTER) && (res != PAY_AT_PUMP)) //349003
	{
		pOla->m_byState = OLA_LOYALTY_WAIT_FUELING;
		m_cPumpArray[p].SetOlaStat(pOla);
		m_cFlowControlManager.StartAfterQueryFlowControl(lPumpNumber, *pOla, *pInfo);
	}
	m_cLogger.LogMsg(p+1,LOG_PUMP,"DoAutoOlaFuelLoyaltyStartFueling Finish");
	return lRtc;
}

//4.0.9.508	//4.0.18.501
long CServerMain::DoAutoOlaFuelLoyaltyEndTicket(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	long				lRtc = 0;

	if (PUMPSRV_IS_MASTER)
	{
		if (FALSE == (m_cFuelLoayaltyPS.EndTicket(lPumpNumber, FALSE))) // RFUEL-2184
			pOla->m_byState = SESSION_COMPLETE | OLA_REQUEST_TO_SEND;
		else
			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState, OLA_LOYALTY_WAIT_END_TICKET_RESPONSE);
		m_cPumpArray[p].SetOlaStat(pOla);

	}
	m_cLogger.LogMsg(p + 1, LOG_PUMP, "DoAutoOlaFuelLoyaltyEndTicket Sent successfully");

	return lRtc;
}


//4.0.18.501
long CServerMain::DoAutoOlaFuelLoyaltyCancelTicket(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo) //Liat LPE
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;

	trs.Clear();

	if(PUMPSRV_IS_MASTER)
	{
		// Creating a new PAP transaction 
		//-------------------------------
			m_cFuelLoayaltyPS.CancelTicket(lPumpNumber,FALSE, FALSE); //4.0.23.991 231113 //4.0.28.500
			if (GetOLAInUse() != OLASRV_NOT_CONFIGURED)	//4.0.19.820 66705 //4.0.23.507
				pOla->m_byState = SESSION_COMPLETE | OLA_REQUEST_TO_SEND;
			else
				pOla->m_byState = OLA_NONE;	//4.0.19.821 //4.0.23.507
			m_cPumpArray[p].SetOlaStat(pOla);
			m_cFuelLoayaltyPS.ClearTimer(p);

	}
	m_cLogger.LogMsg(p+1,LOG_PUMP,"DoAutoOlaFuelLoyaltyCancelTicket Finish  successfully");
	return lRtc;
}

//4.0.18.501
long CServerMain::DoAutoOLARequestToSend(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;
	long				lMode = m_cPumpArray[lPumpNumber - 1].GetStat().GetMode();

	// 1. get PAY_AT_PUMP_pInfo->
	// 2. send to OLA
	// 3, set send time 				
	// 4, set status to OLA_WAIT_RESPONSE
	// 5. save pump info to pump file.

	trs.Clear();

	if(PUMPSRV_IS_MASTER)
	{
		m_cOLASrv->m_lQuerySessionResult[p] = 1 ; //4.0.9999.0
		// Creating a new PAP transaction 
		//-------------------------------
		if(
			(SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) ||
			(SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO) ||
			
			((SESSION_TYPE(pOla->m_byState) == SESSION_SALE) &&
			(pInfo->CardSaleInfo.cardData.sTranStatus != CD_VIT_CONFLICT))
																			)	//4.0.18.501
		{
			BOOL bFoundTrs = TRUE;
			char sClockFlags[MAX_FIELD_VAL]; 
			char sFlags[MAX_FIELD_VAL]; 

			memset(sClockFlags,' ',sizeof(sClockFlags));
			memset(sFlags,0,sizeof(sFlags));

			
			if (!m_cPumpArray[p].IsLoyaltyClub() && 
				(ChrAll((char *)pInfo->CardSaleExtraData2.sClockFlags,sizeof(pInfo->CardSaleExtraData2.sClockFlags))) &&
				(!GetOLAFlags(pInfo->CardSaleExtraData2.sFlags ,FL_DO_NOT_OPEN_TRS )) && //4.0.3.26
				!m_cModeArray[lMode-1].PAPPostPayValid()) //4.0.29.10 - TD 264032
			{
				// check that transactionn is not exist in 
				trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());  //4.0.15.500
				if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))
				{	
					// found in stack. PAP transaction use it.
					if (trs.GetStatus() != PAID)
					{
						bFoundTrs =  FALSE;

						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Pump %02ld detect active transaction %ld use transaction number for the current PAP", 
								lPumpNumber, 
								trs.m_lNumber);
							m_cLogger.LogMsg(str);
						}
					}
				}

				if (bFoundTrs)
				{
					trs.m_lNumber			= NewTransactNumber();
					trs.m_sLoyaltyDiscountApplied = ' ';
					trs.m_lActiveReadNumber	= GetActiveReadNumber();
					trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());
					trs.m_lActiveShiftNumber = m_cPumpArray[p].GetShiftNumber();
					trs.SetStatus(WAIT_PROGRESS);	
					trs.m_lPump = lPumpNumber;

					CentralInsertTrs(lPumpNumber, &trs);
				}		
			}			
		}
#ifdef CANCEL_IN_MIDDLE			
		else if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
		{
			// session never started
			pOla->m_byState = OLA_NONE;
		}
#endif
	}								

	
#ifdef CANCEL_IN_MIDDLE			
	if(SESSION_TYPE(pOla->m_byState))
#endif
	{
		if(m_cOLASrv->Valid())
		{
			memset(m_cOLASrv->m_sOlaReqBuff, 0, sizeof(m_cOLASrv->m_sOlaReqBuff));
			memset(m_cOLASrv->m_sOlaReqType, 0, sizeof(m_cOLASrv->m_sOlaReqType));

			BOOL bTrsFound = TRUE;

			if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)     || // )//3.0.1.61
				(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)	|| //  //5.0.0.55
				(SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO))
				
			{	
				//4.0.29.10 - TD 264032
				if (m_cModeArray[lMode-1].PAPPostPayValid() &&
					(SESSION_TYPE(pOla->m_byState) == SESSION_SALE))
				{
					long lTrsNum = m_cPumpArray[lPumpNumber - 1].GetLastUnpaidPAKTrs();
					m_cPumpArray[p].GetTrsByNumber(lTrsNum, &trs);
				}
				else
				{
					m_cProtectedDataHandler.RestoreData(pInfo, trs.m_lNumber);

					trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());
					if(m_cPumpArray[p].GetTrsByLinkNumber(&trs))
					{ // not found 
						bTrsFound = FALSE;
					}
					else if ( trs.m_lMisc & MISC_TRS_PAP_CANCELED )
					{
						//In case this transaction was canceled because the customer
						//manage to end the transaction before his card was approved.

						//Zero all the totals.
						ZeroPAPTotals(&trs,pInfo);
					}
				}
			}
			
			if((bTrsFound) || (m_cPumpArray[p].GetInPAKLoyaltyWithComplete())) //4.0.14.1390 //4.0.21.0 67387
			{
				m_cOLASrv->BuildSessionType(pOla->m_byState,m_cOLASrv->m_sOlaReqType);

				if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO)
				{
					_Module.m_server.m_cOLASrv->BuildGetCustomerInfoRequest(lPumpNumber, (char*)pInfo, m_cOLASrv->m_sOlaReqBuff);
				}
				else if (SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO)
				{
					_Module.m_server.m_cOLASrv->BuildSetCustomerInfoRequest(lPumpNumber, (char*)pInfo, &trs, m_cOLASrv->m_sOlaReqBuff);
				}
				else
					m_cOLASrv->BuildRequest(pOla->m_byState, lPumpNumber, (char *) pInfo, m_cOLASrv->m_sOlaReqBuff, &trs);

				if (m_cPumpArray[p].GetInPAKLoyaltyWithComplete())	//4.0.14.1390 67387 4.0.21.0
					m_cPumpArray[p].ClearPAKLoyaltyWithCompleteFlags();

				GetLocalTime(&pOla->m_cSysTime);
				pOla->m_byCheckCount = 0;


				//After Build Req gets OLSSrv data
				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str,protectedDataStr,sOlaBuffer(m_cOLASrv->m_sOlaReqBuff);
					m_cProtectedDataHandler.RemoveDataFromLog(sOlaBuffer, protectedDataStr);
					_LOGMSG.LogOLAMsg(p + 1, pOla->m_byState, pOla->m_lSessionNumber);
					str.Format(">>> OLA:StartSession ReqType:%.20s, Sending Buffer:", m_cOLASrv->m_sOlaReqType);
					m_cLogger.LogOLABufferMsg(lPumpNumber, LOG_PUMP, str, protectedDataStr);
				}


				//ola12345				
				if (CheckOLA()== OLA_SERVER_ON) 
				{
					m_cOLASrv->m_lOlaRtc = OLASRV_COM_ERROR;
					CallOLA(OLA_REQUEST_TO_SEND,lPumpNumber);
					lRtc = m_cOLASrv->m_lOlaRtc ;
					m_cOLASrv->m_lQuerySessionResult[p]= lRtc;  //4.0.999.0
					
				}
				else
				{
					lRtc = OLASRV_COM_ERROR;
				}				  					

				//4.0.2.16
				if(lRtc != OLASRV_COM_ERROR)
				{
					m_cOLASrv->ResetRetryAttemps();
					m_cOLASrv->ReasetCounter();
				}
									
				pOla->m_lSessionNumber = lRtc;

			}
			else
			{
				pOla->m_lSessionNumber = NO_SESSION;
				// force operation - transaction not found.							
			}
		}

		if(m_cOLASrv->Valid() && (lRtc >= 0 )) // success
		{

			if ((SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO))
			{
				// QC 488450
				if ((ChrAll((char*)pInfo->CardSaleInfo.cardData.sAuthorizeSessionID, sizeof(pInfo->CardSaleInfo.cardData.sAuthorizeSessionID), ' ')) || (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE)) 
				{
					if (pOla->m_lSessionNumber > 9999)
					{
						l2a0(pOla->m_lSessionNumber % 10000, pInfo->CardSaleInfo.cardData.sAuthorizeSessionID, sizeof(pInfo->CardSaleInfo.cardData.sAuthorizeSessionID));
						l2a0(pOla->m_lSessionNumber / 10000, pInfo->CardSaleExtraData2.sAuthorizeSessionID_MSB, sizeof(pInfo->CardSaleExtraData2.sAuthorizeSessionID_MSB));
					}
					else
						l2a(pOla->m_lSessionNumber, pInfo->CardSaleInfo.cardData.sAuthorizeSessionID, sizeof(pInfo->CardSaleInfo.cardData.sAuthorizeSessionID));
				}

				// QC 486714
				if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO)
					l2a(pOla->m_lSessionNumber, pInfo->CardSaleExtraData3.sLoyaltySessionID, sizeof(pInfo->CardSaleExtraData3.sLoyaltySessionID));
			}
			else if ((SESSION_TYPE(pOla->m_byState) == SESSION_SALE) ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) || 
				(SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO))  //4.0.1.38
			{
			  //4.0.3.47 	
			  if (pOla->m_lSessionNumber > 9999)
			  {
			  	l2a0(pOla->m_lSessionNumber %10000 ,pInfo->CardSaleExtraData2.sCompletedSessionID,sizeof(pInfo->CardSaleExtraData2.sCompletedSessionID));		
			  	l2a0(pOla->m_lSessionNumber /10000 ,pInfo->CardSaleExtraData2.sCompletedSessionID_MSB,sizeof(pInfo->CardSaleExtraData2.sCompletedSessionID_MSB));		
			  }
			  else				  
				l2a(pOla->m_lSessionNumber,pInfo->CardSaleExtraData2.sCompletedSessionID,sizeof(pInfo->CardSaleExtraData2.sCompletedSessionID));
			}
			
			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_WAIT_RESPONSE);
			if(LOG_BASIC_FLOW_CONTROL)
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
		}
		else // OLASrv not available OR failed to start session
		{
			if(LOG_DETAIL_FLOW_CONTROL)
			{
				if(!m_cOLASrv->Valid())
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,"OLASrv Not Valid !");
				else
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,"Failed to StartSession");
			}
			
			if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL)   ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)		||	//3.0.1.61  //4.0.5.37
				(SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO))
			{			
				if(LOG_BASIC_FLOW_CONTROL)
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber, "Retry !!!" );
			}
			else
			{
				if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.7.151
				{
					CPumpTransact trs(p+1);
			
					SendCardInfoResult(pOla->m_byState,p+1, CD_MORE_DATA_REQUIRED, pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData, &trs);

					CString str;
					str.Format("DoAutoOLARequestToSend, CD_MORE_DATA_REQUIRED - pump number=%ld ", p+1);
					m_cLogger.LogMsg(str);

				}
				else 

				//4.0.5.12
				if( (SESSION_TYPE(pOla->m_byState) != SESSION_INIT_DEBIT) &&
					(SESSION_TYPE(pOla->m_byState) != SESSION_SHIFT_DEBIT)) 
				{
	
					SendSwipeResult(pOla->m_byState,p+1,CD_NOT_OK,CD_DECLINE_USEALT, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
					m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
				}
				//4.0.5.12

				pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_SEND_END);								
				if(LOG_BASIC_FLOW_CONTROL)
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
			}					
		}
	}
	
	if (lRtc == OLASRV_COM_ERROR)
	{
		pInfo->CardSaleExtraData2.sSessionOffLine = 'Y' ;
	}

	if( (SESSION_TYPE(pOla->m_byState) == SESSION_GENERATE_REPORT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT) )
	{
		m_cReportArray[p].SetOlaStat(pOla);
		m_cReportArray[p].SetPAPInfo(pInfo);
	}
	else if((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
	{
		m_cDebitInfoArray[p].SetOlaStat(pOla);
		m_cDebitInfoArray[p].ConvertPAP2DebitInfo(pInfo);
	}
	else
	{		
		m_cPumpArray[p].SetPAPInfo(pInfo);
		m_cPumpArray[p].SetOlaStat(pOla);
		SavePumpInfo(p+1); // save ola stat.
	}

	return lRtc;
}

long CServerMain::DoAutoOLAWaitResponse(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	USES_CONVERSION; 
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;


	// 1. read OLA request from file
	// 2, if time to get info - try to find it
	// 3. if found - 
	//		save result
	//		set status to NO_OLA_REQUEST
	//		send result 				
	// 4. if response is need more info -  
	//			set status to OLA_WAIT_FOR_MORE_INFO
	// 5, if not found - do nothing 
	// 6. if time out - no response, 
	//			on non hot pump - send reject
	//			on hot pump - ???								

	BOOL bSavePumpInfo = FALSE;
	BOOL bTimeOut = FALSE;
	BOOL bEndSession = FALSE;				
	BOOL bInMiddleCancel = FALSE;  //3.2.1.22

	SYSTEMTIME curSysTime;
	GetLocalTime(&curSysTime);		
	CTime curTime(curSysTime);

	if(pOla->m_byCheckCount == 0)
	{
		pOla->m_byCheckCount = 1;					
		GetLocalTime(&pOla->m_cSysTime);  //4.0.8.60
	}

	long lSecToCheck = (long)pOla->m_byCheckCount;				
	lSecToCheck --;
	lSecToCheck *= (long)m_dwOLACheckingInterval;

	if(SubSystemTime(curSysTime,pOla->m_cSysTime) >= (DWORD)lSecToCheck)
	{
		bSavePumpInfo = TRUE;

		BSTR	sOutBuffer = SysAllocString(L" ");				//4.0.25.80 TD 142857

		lRtc = OLASRV_COM_ERROR;
		m_cOLASrv->m_lOlaRtc =OLASRV_COM_ERROR;

		if(m_cOLASrv->Valid())
		{	
			//ola12345 
			m_cOLASrv->m_lSessionId = pOla->m_lSessionNumber;
			m_cOLASrv->m_pbsrOlaBuffer = sOutBuffer;
			if (CheckOLA()== OLA_SERVER_ON) 
			{
				CallOLA(OLA_WAIT_RESPONSE,lPumpNumber);
				lRtc = m_cOLASrv->m_lOlaRtc ;
				sOutBuffer = m_cOLASrv->m_pbsrOlaBuffer; 
				m_cOLASrv->m_lQuerySessionResult[p]= lRtc;  //4.0.999.0
			}
			else
			{
				lRtc = OLASRV_COM_ERROR;
			}

			//4.0.2.16
			if(lRtc != OLASRV_COM_ERROR)
				m_cOLASrv->ResetRetryAttemps();
			
		}


		if(m_cOLASrv->Valid())
		{	
			// Construct _bstr_t by attaching BSTR, and dont copy 

			_bstr_t sTmpBuffer(sOutBuffer,false);

			// Distructor of _bstr_t calls SysFreeString()... 
			// for the attached BSTR

			if(LOG_BASIC_FLOW_CONTROL)
			{
				if( (SESSION_TYPE(pOla->m_byState) == SESSION_GENERATE_REPORT) ||
					(SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT) )
				{	
					CString str;
					str.Format(">>> OLA:QuerySession %ld for Report %ld, Rtc %ld  (Received buffer size: %ld)",pOla->m_lSessionNumber,p,lRtc,sTmpBuffer.length());
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);	
				}
				else
				{	
					CString str;
					str.Format(">>> OLA:QuerySession %ld, Rtc %ld  (Received buffer size: %ld)",pOla->m_lSessionNumber,lRtc,sTmpBuffer.length());
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);
				}
			}

			switch(lRtc)
			{
				case OLASRV_PROCESS_NOT_FINISHED:
				//-------------------------------
				{
					pOla->m_byCheckCount++;
					bSavePumpInfo = FALSE;
					BYTE byMaxOLAChecking = (BYTE)(m_dwOLAResponseTimeOut / m_dwOLACheckingInterval);
					if(pOla->m_byCheckCount >= byMaxOLAChecking)
					{
						if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
							(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL)   ||
							(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)     || //  ) //3.0.1.61
							(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)  || //5.0.0.55
							(SESSION_TYPE(pOla->m_byState) == SESSION_CLOCK)    || 
							(SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)	|| //5.0.0.55 //4.0.3.21
							(SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO))

						{
							pOla->m_byCheckCount = 0;
							GetLocalTime(&pOla->m_cSysTime);
							if(LOG_BASIC_FLOW_CONTROL)
								m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber, "Retry !!!" );
						}
						else
							bTimeOut = TRUE;						 									
					}
					else if(SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE)
					{		
						DoHotPumping(lPumpNumber,sTmpBuffer);
					}

					UpdateEncryptionKeys(/*lPumpNumber*/0,sTmpBuffer);

					break;
				}
				case OLASRV_NEED_MORE_PARAMS:
				//-------------------------------
				{										
				
					CString strOutBuff((const char *)sTmpBuffer);  // TD 379474

//3.2.1.11
#ifdef CANCEL_IN_MIDDLE		
					//3.2.1.22
					if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)  //3.2.1.22
					{
						bInMiddleCancel = TRUE;
					}
					else  // //3.2.1.22
#endif				
//3.2.1.11						
					{
						CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

						CPumpStatus pumpStat = m_cPumpArray[lPumpNumber -1].GetStat();
						long lMisc = pumpStat.GetMisc();

						lMisc |= MISC_NEED_MORE_PARAM;	
						pumpStat.SetMisc(lMisc);
						m_cPumpArray[lPumpNumber -1].SetStat(pumpStat);
					}

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str, protectedDataStr;
						m_cProtectedDataHandler.RemoveDataFromLog(strOutBuff, protectedDataStr);
						str.Format(">>> OLA:QuerySession %ld, (len = %ld) ",pOla->m_lSessionNumber, protectedDataStr.GetLength());
						m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
					}

					//Parsing input string
					long lFlags = (long)m_cOLASrv->ParseData(lRtc,&strOutBuff,pInfo , NULL , pOla->m_byState, lPumpNumber); //4.0.16.503

					// currently PumpSrv make no use of the flags 
					// returned from ParseData 
					// Convert layer should collect all '?' (required)
					// fileds and build the appropriate request from 
					// site controller

#ifdef CANCEL_IN_MIDDLE			
					if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
					{				
						bEndSession = TRUE;								

						if((lFlags & REQUIRED_PROMPT_REWARDS)	|| 
							(lFlags & REQUIRED_VOUCHER_NUMBER)	||
							(lFlags & REQUIRED_KEY_CODE)	)
						{						
							// in this case end session will be followed by Complete
							// Session Type = SESSION_CANCEL_AUTH
						}
						else
						{	
							// Switch back to Session Authorize - in this case 
							// "end session" will NOT be followed by Complete
							pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
							if(LOG_BASIC_FLOW_CONTROL)
								m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
						}

					}
					else
#endif
					{

						if (pInfo->CardSaleExtraData3.sReSend == 'Y')  //4.0.5.36	//4.0.18.501
						{
							pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_REQUEST_TO_SEND_MORE);								
							if(LOG_BASIC_FLOW_CONTROL)
								m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
							pOla->m_byCheckCount = 0;
							pInfo->CardSaleExtraData3.sReSend=' ';  

							if(LOG_BASIC_FLOW_CONTROL)
							{	
								CString str, protectedDataStr;
								m_cProtectedDataHandler.RemoveDataFromLog(strOutBuff, protectedDataStr);
								str.Format(">>> Resend OLA data :QuerySession %ld, (len = %ld) ",pOla->m_lSessionNumber, protectedDataStr.GetLength());
								m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
							}
						
						}
						else
						{
							pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_WAIT_FOR_MORE_INFO);
							if(LOG_BASIC_FLOW_CONTROL)
								m_cLogger.LogOLAMsg(p + 1, pOla->m_byState, pOla->m_lSessionNumber);
							pOla->m_byCheckCount = 0;
							
							UpdateDebitTimeOutParmeters(lPumpNumber , pOla, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData); //4.0.0.66 //4.0.5.0
							
							if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
								(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
							{
								m_cDebitInfoArray[p].ConvertPAP2DebitInfo(pInfo);							
								SendDebitResult(p+1 , pOla->m_lSessionNumber);
							}
							else if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.6.507
							{
								CPumpTransact tmpTrs(p+1);
								SendCardInfoResult(pOla->m_byState,p+1, CD_MORE_DATA_REQUIRED, pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData, &tmpTrs);
							}
							else														
							{
								//4.0.3.44
								if (pInfo->CardSaleExtraData2.sDeclinedLoyaltyPrompt == DECLINE_PAYMENT_CARD) 
								{
									SendSwipeResult(pOla->m_byState,p+1,CD_MORE_DATA_REQUIRED, pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
								}
								else
									SendSwipeResult(pOla->m_byState,p+1,CD_MORE_DATA_REQUIRED,CD_READY, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
								//4.0.3.44

							}

						}

					}
					break;
				}

				case OLASRV_PROCESS_FINISHED:
				//-------------------------------
				{
					CString strOutBuff((const char *)sTmpBuffer);  // TD 379474
					char	ReportText[REPORT_TEXT_LENGTH] = {' '};
			 		long	lLen = 0;
					long lFlag= a2l(pInfo->CardSaleExtraData3.sFlags1,sizeof(pInfo->CardSaleExtraData3.sFlags1));//4.0.12.501

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str,protectedDataStr;
						m_cProtectedDataHandler.RemoveDataFromLog(strOutBuff, protectedDataStr);
						if( (SESSION_TYPE(pOla->m_byState) == SESSION_GENERATE_REPORT) ||
							(SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT) )
						{	
							
							str.Format(">>> OLA:QuerySession %ld for Report %ld, Received buffer:",pOla->m_lSessionNumber,p);
							m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
						}
						else if( SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)					
						{	
							str.Format(">>> OLA:QuerySession %ld for init Debit... %ld, Received buffer:",pOla->m_lSessionNumber,p);
							m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
						}
						else if(SESSION_TYPE(pOla->m_byState) == SESSION_REPORT_PRICE_CHANGE)  //4.0.10.50  
						{
							str.Format(">>> OLA:QuerySession %ld Pric change  %ld, Received buffer:",pOla->m_lSessionNumber,p);
							m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);

						}
						else if((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) )
						{	
							str.Format(">>> OLA:QuerySession %ld for Debit... %ld, Received buffer:",pOla->m_lSessionNumber,p);
							m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
						}

						else
						{	
							str.Format(">>> OLA:QuerySession %ld, Received buffer:",pOla->m_lSessionNumber);   //4.0.5.13									
							m_cLogger.LogOLABufferMsg(p+1,LOG_PUMP,str,(LPCTSTR)protectedDataStr);
						}

						
					}


					CPumpTransact tmpTrs(p+1);
					//Parsing input string
					if( (SESSION_TYPE(pOla->m_byState) == SESSION_RECEIPT_AUTH) ||
						(SESSION_TYPE(pOla->m_byState) == SESSION_GET_RECEIPT)	)
					{						
						m_cOLASrv->ParseData(lRtc,&strOutBuff,pInfo,&tmpTrs, 0, lPumpNumber); //4.0.16.503
					}
					else if(SESSION_TYPE(pOla->m_byState) == SESSION_REPORT_PRICE_CHANGE)  //4.0.10.50
					{

					}
					else if ( SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT )
					{
						m_cOLASrv->ParseReportData(&strOutBuff, pInfo, ReportText ,&lLen);
					}
					else  if (SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)   // RFUEL-856 (RFUEL-3313)
					{

						CString str;
						str.Format(">>> OLA:QuerySession %ld Got canceld request , flag=%.7s", pOla->m_lSessionNumber, pInfo->CardSaleExtraData3.sFlags1);
						m_cLogger.LogMsg(p + 1, LOG_PUMP, str);
						bEndSession = TRUE;

						break;
					}
					else
					{
						m_cOLASrv->ParseData(lRtc,&strOutBuff,pInfo,NULL ,pOla->m_byState, lPumpNumber); //4.0.16.503
						
						if((m_bPresentCardName)&&
							(SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE))//4.0.10.1000
						{
							CPumpTransact trs;
							CPumpTransact tmpTrs(p+1);
							BOOL bRetCode = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_OLA_NUMBER,&trs);
							if(bRetCode)
							{
								InsertTrsToShortCardArr(&trs,pInfo->CardSaleInfo.cardData.sCardName);
							}
						}
					}
					

					if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
						(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)     ||//  )//3.0.1.61
						(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)  || //5.0.0.55
						(SESSION_TYPE(pOla->m_byState) == SESSION_CLOCK)    ||
						(SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)	|| //5.0.0.55 //4.0.3.21
						(SESSION_TYPE(pOla->m_byState) == SESSION_SET_CUSTOMER_INFO))

					{
						tmpTrs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());
						m_cPumpArray[p].GetTrsByLinkNumber(&tmpTrs);
					}

					// do not return any result 2 Cl
					if ((SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)   //3.2.0.9
						||(SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT))
					{
						bEndSession = TRUE;
						break;
					}

					if(pInfo->CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK)
					//==============================================
					{
#ifdef CANCEL_IN_MIDDLE
						if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
						{
							// do nothing,
							// bEndSession is flaged ON at the end of the case
							// end session will be followed by complete
						}
						else
#endif
							
						{
							//4.0.2.23 // TD 241956 4.0.28.500
// 							if (pInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_DELAYED_PREPAY)
// 							{
// 								CDelayedPrePay  cDelayedPrePay; 																
// 								cDelayedPrePay.CreateNewPrePay(p+1 , pInfo);
// 							}//4.0.2.23
// 							else 

							if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT)
							{
								PrintReport( a2l(&pInfo->CardSaleExtraData2.sOriginTrans, sizeof(pInfo->CardSaleExtraData2.sOriginTrans)), a2l(pInfo->CardSaleInfo.cardData.sDeviceNumber,sizeof(pInfo->CardSaleInfo.cardData.sDeviceNumber)), ReportText, 0L ,lLen);
								m_cReportArray[p].SetRequestStatus(RS_EMPTY);

							}
							else if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.3.21
							{								
								SendCardInfoResult(pOla->m_byState,p+1, CD_OK, CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&tmpTrs);
								CString str;
								str.Format("Call SendCardInfoResult method with CD_OK CD_APPROVE_OK. ");
								m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
							
							}
							else if( (SESSION_TYPE(pOla->m_byState) == SESSION_RECEIPT_AUTH) ||
									 (SESSION_TYPE(pOla->m_byState) == SESSION_GET_RECEIPT)  ||
								 	 (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE)     ||
						 			 ((SESSION_TYPE(pOla->m_byState) == SESSION_SALE)&& (!(lFlag & FL_SALE_REC)))	|| //)//3.0.1.61 4.0.12.501
 									 (SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)		|| //5.0.0.55
									 (SESSION_TYPE(pOla->m_byState) == SESSION_CLOCK) ) //5.0.0.55  //4.0.3.21

							{
								if (tmpTrs.m_lMisc & MISC_TRS_PAP_CANCELED)
								{
									
									m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber);
									
									SendReceipt(pOla->m_byState,p+1, CD_NOT_OK, CD_DECLINE_USEALT, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&tmpTrs);

								}
								else
									SendReceipt(pOla->m_byState,p+1, CD_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&tmpTrs);

							}
							else if( IsNozzleRestrict(lPumpNumber,pOla,pInfo) )
							{
								//Since the card was approved, but none of the grade that was valid are being use
								//at the current pump.
								//Then, don't approve and do zero competion.
								pInfo->CardSaleInfo.cardData.sTranStatus = CD_DECLINE_NO_NOZZLE;
								SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);

								m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &tmpTrs);
								
#ifdef CANCEL_IN_MIDDLE
								pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_CANCEL_AUTH);
#endif
							}
							else if ( m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() != AUTHORIZED &&
									  m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() != DISPENSING)
							{
								
								CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

								CPumpStatus pumpStat = m_cPumpArray[lPumpNumber -1].GetStat();
								long lMisc = pumpStat.GetMisc();
								
								long lPreAuthorizedAmount = ConvertStringsToLong(pInfo->CardSaleInfo.cardData.sAuthAmt,sizeof(pInfo->CardSaleInfo.cardData.sAuthAmt),pInfo->CardSaleInfo.extraData.sAuthAmt_Msb   ,sizeof(pInfo->CardSaleInfo.extraData.sAuthAmt_Msb)) * 10; //3.2.0.73 //4.0.5.25			    
								long lPreAuthorizedVolume = a2l(pInfo->CardSaleExtraData2.sVolumeLimit, sizeof(pInfo->CardSaleExtraData2.sVolumeLimit));  //3.2.0.69 
								
								if (IsValidPAPAmount(lPumpNumber , lPreAuthorizedAmount, pInfo->CardSaleInfo.cardData.sTranType , lPreAuthorizedVolume))
								{
									pInfo->CardSaleInfo.cardData.sTranStatus = CD_DECLINE_AMOUNT;
									SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
									m_cPumpArray[lPumpNumber -1].SetMiscCardNotAuthorized();	 //4.0.7.508									
								}
								else
								{
									//4.0.3.25 //4.0.3.26
									BOOL bSendOK = TRUE;
									
									//4.0.9.503
									if ((m_cServerInfo.GetWaitForPriceChangeAckFlags()) &&
										(m_cPumpArray[p].GetPriceChangeStatus()) && 
										m_cPumpArray[p].GetDieselPumpFlags())  //4.0.10.591
									{
										pInfo->CardSaleExtraData3.sWaitForPriceChange ='1';

										if(LOG_BASIC_FLOW_CONTROL)
										{	
											CString str;
											str.Format("Pump %02d is mark as pending price change ",lPumpNumber);
											_LOGMSG.LogMsg(str);
										}
									}

									if( (PUMPSRV_IS_MODE_MASTER) &&
										(m_cModeArray[(m_cPumpArray[p].GetStat().GetMode())-1].PAPNotValid()) )
									{		
										// Is it Avi transaction
										if (a2l(pInfo->CardSaleExtraData2.sMediaMasterType , sizeof(pInfo->CardSaleExtraData2.sMediaMasterType))== CARD_TYPE_AVI)
										{											
											if ((m_cModeArray[(m_cPumpArray[p].GetStat().GetMode())-1].PayAVINotValid()))												
											{
												bSendOK = FALSE;
											}											
										}	// Is it Avi Attendant transaction
										else if (a2l(pInfo->CardSaleExtraData2.sMediaMasterType , sizeof(pInfo->CardSaleExtraData2.sMediaMasterType))== CARD_TYPE_AVI_LOYALTY)  //4.0.8.503
										{
											if(LOG_BASIC_FLOW_CONTROL)
											{
												CString str;
												str.Format("Detect AVI as loyalty  transaction");
												m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
											}	
										}
										else if ((pInfo->CardSaleInfo.extraData.sAttandantSession  != '1') && (m_cPumpArray[p].GetStat().GetResExt() !=RES_EXT_ATTENDANT))  // 4.0.9.501
										{
											if(LOG_BASIC_FLOW_CONTROL)
											{
												CString str;
												str.Format("Not allowed PAP");
												m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
											}	

											bSendOK = FALSE;
										}																														
									}											

									if (bSendOK)
									{	
										long lMediaMasterType = a2l(pInfo->CardSaleExtraData2.sMediaMasterType,sizeof(pInfo->CardSaleExtraData2.sMediaMasterType));  //MarikDebug //4.0.24.60 113751
										if((!memcmp(&pInfo->CardSaleInfo.cardData.sAccountNumber, 
											&pInfo->CardSaleInfo.extraData.sLoyalId, 
											sizeof(pInfo->CardSaleInfo.extraData.sLoyalId)))&& (lMediaMasterType == CARD_TYPE_LOYALTY_AND_CREDIT)) //4.0.23.410 121090 && (lMediaMasterType != CARD_TYPE_LOYALTY_AND_CREDIT))	//4.0.23.20 77534 //4.0.23.300 113751 //4.0.24.90 TD 319058
										{
											memset(&pInfo->CardSaleInfo.cardData.sClubCardTrack2Data, ' ', sizeof(pInfo->CardSaleInfo.cardData.sClubCardTrack2Data));
											memset(&pInfo->CardSaleInfo.extraData.sLoyalId, ' ', sizeof(pInfo->CardSaleInfo.extraData.sLoyalId));
											m_cPumpArray[lPumpNumber -1].SetPAPInfo(pInfo);	//4.0.20.40
											if(LOG_BASIC_FLOW_CONTROL)
											{
												CString str;
												str.Format("LoyaltyId and ClubCardTrack2 were cleared for payment");
												m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
											}	
										}
									}
									if(m_cProtectedDataHandler.EncodeForTrs(OLA_LOYALTY_AUTHORIZE_PAYMENT, pInfo) != TRUE)						//4.0.23.0 TD 76407
									{											
										bSendOK = FALSE;
									}
											
									if (bSendOK)
									{
										//Copient 55286
										if (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag() && m_cFlowControlManager.GetInitFlag() )//4.0.22.500&& m_cFuelLoayaltyPS.IsPaymentFirstInFlow())
										{
											m_cPumpArray[lPumpNumber -1].SetPAPInfo(pInfo);	//4.0.20.40
											m_cFlowControlManager.SetNMPTime(lPumpNumber, TRUE);
										}
										else
										{
											SendSwipeResult(pOla->m_byState,p+1, CD_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
										}
										lMisc |= MISC_APPROVED_PAP;	
										pumpStat.SetMisc(lMisc);
										m_cPumpArray[lPumpNumber -1].SetStat(pumpStat);
										
										//4.0.3.46 start - updates the Trs reservation and link number

										if (GetOLAFlags(pInfo->CardSaleExtraData2.sFlags , FL_PAK_TO_PAP))
										{
											BOOL bFound = FALSE;
											CPumpTransact cTrs;
											long lSeqNum = 0;
											bFound = m_cPumpArray[p].GetCurrentTrs(&cTrs);
											if(!bFound)
											{
												lSeqNum =  m_cPumpArray[p].GetPAPSeqNumber();
												cTrs.SetLink(TRS_LINK_OLA_NUMBER,lSeqNum);
												cTrs.m_lRes = PAY_AT_PUMP;
												CentralUpdateTrs(p+1, cTrs.m_lNumber,&cTrs,FALSE);
											}
										}//4.0.3.46 - end

										if (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE)   //4.0.23.273?
										{
											//pInfo->CardSaleExtraData3.sPaymnetCardApproved = '1';
											long lTmp = a2l(pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1)) + FL_PAP_PAYMENT_ACCEPTED;
											l2a(lTmp, pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1));

											m_cPumpArray[lPumpNumber - 1].SetPAPInfo(pInfo);	//4.0.20.40
										}
										else if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO)
										{
											long lTmp = a2l(pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1)) + FL_PAP_LOYALTY_ACCEPTED;
											l2a(lTmp, pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1));
											pInfo->CardSaleInfo.extraData.sForceCompleteZero = 'Y';  //4.0.23.278?
											m_cPumpArray[lPumpNumber - 1].SetPAPInfo(pInfo);	//4.0.20.40
										}
									}
									else
									{										
										m_cPumpArray[lPumpNumber -1].SetMiscCardNotAuthorized();	// 4.0.7.508									
										SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
									}
									//4.0.3.25
								}
							}							
							else 
							{	
								if(LOG_BASIC_FLOW_CONTROL)
								{
									CString str;
									str.Format("Pump was Hot Authorized. Do nothing");
									m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
								}
								// testing to eran  3.1.1.72
								SendSwipeResult(pOla->m_byState,p+1, CD_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
								// testing to eran  3.1.1.72
							}
						}
					}
					else // Not Approved - if(pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK)
					//================================================
					{ 
						PAY_AT_PUMP_INFO  cTmpInfo;
						m_cPumpArray[p].GetPAPInfo(&cTmpInfo);

						// !!!!!!!!!! Special Patch
						// detect Network failure after Approval and PromptRewards = Y .. which 
						// result with CD_DECLINE_ERROR 
						if (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) // TD 357023
						{
							if (pInfo->CardSaleInfo.cardData.sGRPrompt == 'Y' && (pInfo->CardSaleInfo.cardData.sTranStatus == CD_DECLINE_ERROR))
								pInfo->CardSaleInfo.cardData.sTranStatus = CD_DECLINE_GR;								
	  					    //3.2.0.64
							else if(pInfo->CardSaleInfo.extraData.sForceCompleteZero == 'Y') 
								pInfo->CardSaleInfo.cardData.sTranStatus = CD_FORCE_COMPLETION_ZERO;								
							//3.2.0.64
						}
						else if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT)   //4.0.6.507
						{
							PrintReport( a2l(&pInfo->CardSaleExtraData2.sOriginTrans, sizeof(pInfo->CardSaleExtraData2.sOriginTrans)), a2l(pInfo->CardSaleInfo.cardData.sDeviceNumber,sizeof(pInfo->CardSaleInfo.cardData.sDeviceNumber)), ReportText, 0L ,lLen);
							m_cReportArray[p].SetRequestStatus(RS_EMPTY);
						}											
						
						if ( IsPumpHotAuthorized(lPumpNumber,pOla->m_byState) )
						{
							if ( !StopHotAuthorizedPump(lPumpNumber) )
							{
								SendSwipeResult(pOla->m_byState,lPumpNumber,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);

							}
						}
						else if ((SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO) && (pInfo->CardSaleInfo.cardData.sTranStatus == CD_DECLINE_INVALID_LOYALTY_CARD)) // RFUEL-569
						{
							_Module.m_server.m_cFlowControlManager.SetPumpSrvAddMemberCardRes(lPumpNumber, LOYALTY_STATE_UNAVALIABLE_ERROR);
							CString sLogMsg;
							sLogMsg.Format("Loyalty card is invalid!", lPumpNumber);
							_Module.m_server.m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, sLogMsg);

						}
						else //__Decline
						{
							BOOL bSetMisc = TRUE;

							//4.0.0.75
							if (SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)	
							{
								//4.0.1.0
								pInfo->CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;
								SendReceipt(pOla->m_byState,p+1, CD_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&tmpTrs);
							}
							else if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.3.21
							{
								SendCardInfoResult(pOla->m_byState,p+1, CD_NOT_OK,CD_APPROVE_OK, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&tmpTrs);
							}
							else if(SESSION_TYPE(pOla->m_byState) == SESSION_REPORT_PRICE_CHANGE)  //4.0.10.50
							{
								// do nothing
							}
							
							else
							{
								long ClubType = a2l(pInfo->CardSaleExtraData6.sClubType, sizeof(pInfo->CardSaleExtraData6.sClubType));

								//4.0.3.45
								if (GetOLAFlags(pInfo->CardSaleExtraData2.sFlags , FL_PAK_TO_PAP))
								{
									SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
									
									CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

									CPumpStatus pumpStat = m_cPumpArray[p].GetStat();
									long lMisc = pumpStat.GetMisc();
									lMisc |=MISC_PAK_TO_PAP_FAILED;
									pumpStat.SetMisc(lMisc);
									m_cPumpArray[p].SetStat(pumpStat);
									
									pInfo->CardSaleInfo.cardData.sTranStatus = CD_TYPE_PAK_TO_PAP_DECLINE;
									m_cMemPumpArray[p].SetMemPumpInfo(pInfo ,&tmpTrs);
								}
								else if ((SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO) && (ClubType == CLUB_TYPE_PUNCHH) && (pInfo->CardSaleExtraData4.sLoyaltyEntryMethod == 'A')) // CR 501164
								{
									if (LOG_BASIC_FLOW_CONTROL)
									{
										CString str;
										str.Format("Pump = %ld Handle punch Loyalty sTranStatus=%c", p + 1, pInfo->CardSaleInfo.cardData.sTranStatus);
										m_cLogger.LogMsg(p + 1, LOG_PUMP, str);
									}
									HandlePunchhAlternateIDfailure(p + 1, pOla, pInfo);  // CR 501164
									bSetMisc = FALSE;

									// _Module.m_server.m_cFlowControlManager.StartAfterAddMemberFlowControl(lPumpNumber,&ola,lMemberRes);
								}
								else if ((pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) && (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) && (m_cFuelLoayaltyPS.GetLoyaltySrvInUse() == EPSILON))
								{
									GetCustInfoRetryRequest(*pInfo, lPumpNumber, *pOla);
								}
								else
								{
									SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
								}

								//4.0.2.13 If session type is COMPLETE, it is pointless to raise
								//this MISC, since the card has been authorized.
								if ((bSetMisc) && (SESSION_TYPE(pOla->m_byState) != SESSION_COMPLETE))
								{
									m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber);
								}
								else if(SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE)
								{									
									_LOGMSG.LogMsg("DoAutoOLAWaitResponse, CD_NOT_OK on COMPLETE!!!");
								}
							}
						}
						
						//4.0.10.504
						trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());
						m_cPumpArray[p].GetTrsByLinkNumber(&trs);

						// !!!!!!!!!! Special Patch
						if ((SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE)&& (trs.m_lResExt != RES_EXT_FLEET)) //4.0.10.16	 
						{
							pInfo->CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;
						}

#ifdef CANCEL_IN_MIDDLE
												
						if ((!GetOLAFlags(pInfo->CardSaleExtraData3.sFlags1 , FL_CANCEL_REC,sizeof(pInfo->CardSaleExtraData3.sFlags1))) &&  //4.0.8.511
							(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH))
						{								
							// Switch back to Session Authorize - in this case 
							// "end session" will NOT be followed by Complete
							pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);
							if(LOG_BASIC_FLOW_CONTROL)
		 						m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
						}
#endif						
					}

					bEndSession = TRUE;
					break;
				}								

				case OLASRV_GENERAL_ERROR:
				case OLASRV_CONVERT_LAYER_ERROR:
				case OLASRV_UNKNOWN_SESSION_ID:
				case OLASRV_NOT_SUPPORTED:
				case OLASRV_NO_HOST:
				default:
				//-------------------------------
				{
					PAY_AT_PUMP_INFO  cTmpInfo;
					m_cPumpArray[p].GetPAPInfo(&cTmpInfo);

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str;
						str.Format("OLA:(Session %ld, Seq %.5s) OLA_WAIT_RESPONSE, GENERAL_ERROR  ",pOla->m_lSessionNumber, pInfo->CardSaleInfo.cardData.sTranNbr); 
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
					

		//			if(sesion == Authorize)
		//				__Decline
	
					if ( IsPumpHotAuthorized(lPumpNumber,pOla->m_byState) )
					{
						if ( !StopHotAuthorizedPump(lPumpNumber) )
						{
							SendSwipeResult(pOla->m_byState,lPumpNumber,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);							
						}
					}
					else if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
						(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
					{

					}
					else if(SESSION_TYPE(pOla->m_byState) == SESSION_REPORT_PRICE_CHANGE)  //4.0.10.50
					{

					}
					else  if (SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)	
					{
						pInfo->CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;

						SendSwipeResult(p+1, CD_FORCE_OK);
					}
					else //__Decline
					{
						GetDeclineErrorFromOla(lRtc,pInfo);//4.0.8.240 amram
						m_cMemPumpArray[p].SetMemPumpInfo(pInfo ,&trs); //4.0.8.240 amram
						
						m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);

						if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.7.151
						{
							CPumpTransact trs(p+1);
							SendCardInfoResult(pOla->m_byState,p+1, CD_NOT_OK, pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&trs);
						}
						else
							SendSwipeResult(pOla->m_byState,p+1,CD_NOT_OK,CD_DECLINE_USEALT,(CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);				

					}

					// !!!!!!!!!! Special Patch
					if(SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE)	
					{
						pInfo->CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;

						trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());					
						if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))
						{
							if (trs.m_lResExt == RES_EXT_FLEET)    //4.0.10.184
							{
								pInfo->CardSaleInfo.cardData.sTranStatus = ' ';
							}

						}

					}

#ifdef CANCEL_IN_MIDDLE			

					if ((!GetOLAFlags(pInfo->CardSaleExtraData3.sFlags1 , FL_CANCEL_REC,sizeof(pInfo->CardSaleExtraData3.sFlags1))) &&  //4.0.8.511
						(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH))
					{								
						// Switch back to Session Authorize - in this case 
						// "end session" will NOT be followed by Complete
						pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
						if(LOG_BASIC_FLOW_CONTROL)
							m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
					}
#endif

					bEndSession = TRUE;
					break;
				}
			}
		}
		else // OLASRV_COM_ERROR:
		{
			if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL)   ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)     ||  //)//3.0.1.61
				(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)  || //5.0.0.55				
				(SESSION_TYPE(pOla->m_byState) == SESSION_CLOCK)    ||
				(SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY) ) //5.0.0.55
			{			
				pOla->m_byCheckCount = 0;
				GetLocalTime(&pOla->m_cSysTime);

				if(LOG_BASIC_FLOW_CONTROL)
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber, "Retry !!!" );
			}
			else
			{
				// 121200 marik
				if ( IsPumpHotAuthorized(lPumpNumber,pOla->m_byState) )
				{
					if ( !StopHotAuthorizedPump(lPumpNumber) )
					{
						SendSwipeResult(pOla->m_byState,lPumpNumber,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);						
					}
				}
				else if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
					(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
				{

				}
				else if(SESSION_TYPE(pOla->m_byState) == SESSION_REPORT_PRICE_CHANGE)  //4.0.10.50
				{

				}				

				else
				{
					m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
					if (SESSION_TYPE(pOla->m_byState) == SESSION_INQUIRY)  //4.0.11.504
					{
						SendCardInfoResult(pOla->m_byState,p+1, CD_NOT_OK, pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData,&trs);
					}

					SendSwipeResult(pOla->m_byState,p+1,CD_NOT_OK,CD_DECLINE_USEALT, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
				}

#ifdef CANCEL_IN_MIDDLE			

				if ((GetOLAFlags(pInfo->CardSaleExtraData2.sFlags , FL_CANCEL_REC)) &&  //4.0.8.511
					(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH))
				{								
					// Switch back to Session Authorize - in this case 
					// "end session" will NOT be followed by Complete
					pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
					if(LOG_BASIC_FLOW_CONTROL)
						m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);					
				}
#endif

				bEndSession = TRUE;
			}
		}
	}
		
	
	if(bTimeOut)
	{			
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("OLA: (Session %ld, Seq %ld) OLA_WAIT_RESPONSE, TIMEOUT ",pOla->m_lSessionNumber, pInfo->CardSaleInfo.cardData.sTranNbr); 
			m_cLogger.LogMsg(p+1,LOG_PUMP,str);
		}

		//4.0.7.506		
		if ( IsPumpHotAuthorized(lPumpNumber,pOla->m_byState) )
		{
			if ( !StopHotAuthorizedPump(lPumpNumber) )
			{
				SendSwipeResult(pOla->m_byState,lPumpNumber,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);						
			}
		}
		// In case of Receipt info failed due to timeout 
		// there is no use to get into another session 
		else if(SESSION_TYPE(pOla->m_byState) == SESSION_RECEIPT_AUTH)
			pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);

		//In case we are waiting for GR response, send CD_DECLINE_GR to CL,
		//This will cause zero competion when we will reach to SEND_END.
		else if((pInfo->CardSaleInfo.cardData.sGRPrompt != ' ') &&
				(pInfo->CardSaleInfo.cardData.sGRPrompt != 0))
		{
			m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
			SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_DECLINE_GR, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);			
		}
		// 3.2.0.64
		else if((pInfo->CardSaleInfo.extraData.sForceCompleteZero != ' ') &&
			    (pInfo->CardSaleInfo.extraData.sForceCompleteZero != 0))
		{
			m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
			SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_FORCE_COMPLETION_ZERO, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);			
		}
		else if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
			(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))

		{

		}			
		// 3.2.0.64
		else
		{
			m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
			SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_DECLINE_NOHOST, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
		}
		
#ifdef CANCEL_IN_MIDDLE			
		if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
		{								
			// Switch back to Session Authorize - in this case 
			// "end session" will NOT be followed by Complete
			pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
			if(LOG_BASIC_FLOW_CONTROL)
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
			
			SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_DECLINE_NOHOST, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);	//4.0.9.511								 
			
		}
#endif
		
		bEndSession = TRUE;
	}
	
	if(bEndSession)
	{
		pOla->m_byCheckCount = 0;
		pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_SEND_END);		
	}

	if (lRtc == OLASRV_COM_ERROR)
	{
		pInfo->CardSaleExtraData2.sSessionOffLine = 'Y' ;
	}


	if( (SESSION_TYPE(pOla->m_byState) == SESSION_GENERATE_REPORT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT) ) 
	{
		m_cReportArray[p].SetOlaStat(pOla);
		m_cReportArray[p].SetPAPInfo(pInfo);
	}
	else if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
	{
		m_cDebitInfoArray[p].SetOlaStat(pOla);
		m_cDebitInfoArray[p].ConvertPAP2DebitInfo(pInfo);
	}
	else
	{
//3.2.1.11
#ifdef CANCEL_IN_MIDDLE	
		//3.2.1.22
		if(bInMiddleCancel && (lRtc == OLASRV_NEED_MORE_PARAMS))
		{
			PAY_AT_PUMP_INFO InfoTmp;
			
			m_cPumpArray[p].GetPAPInfo(&InfoTmp);
			InfoTmp.CardSaleInfo.cardData.sTranStatus = pInfo->CardSaleInfo.cardData.sTranStatus;

			memcpy(InfoTmp.CardSaleInfo.cardData.sReferenceNumber,pInfo->CardSaleInfo.cardData.sReferenceNumber, sizeof(InfoTmp.CardSaleInfo.cardData.sReferenceNumber)); //3.2.1.311
			m_cPumpArray[p].SetPAPInfo(&InfoTmp);

			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("OLA: (Session %ld, Seq %.5s) Cancel in middle need more Param,  sTranStatus=%d ",pOla->m_lSessionNumber, pInfo->CardSaleInfo.cardData.sTranNbr, InfoTmp.CardSaleInfo.cardData.sTranStatus); 
				m_cLogger.LogMsg(p+1,LOG_PUMP,str);
			}

			if (GetOLAFlags(pInfo->CardSaleExtraData3.sFlags1 ,FL_CANCEL_REC,sizeof(pInfo->CardSaleExtraData3.sFlags1)))     //4.0.8.502
			{	
				SendSwipeResult(pOla->m_byState,lPumpNumber,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);	
			}


		}
		else
		//3.2.1.22
#endif	
		{
			m_cPumpArray[p].SetPAPInfo(pInfo);				
		}
//3.2.1.11

		m_cPumpArray[p].SetOlaStat(pOla); 

		if(bSavePumpInfo)
		{
			CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
			SQLPumpSrvFile.SaveRealTimeInfo(p + 1, __FUNCTION__, __LINE__);
		}
	}

	return lRtc;
}

long CServerMain::DoAutoOLAWaitForMoreInfo(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo, OLA_DEBIT_MESSAGES_TIME_OUT_INFO *pDebitTimeout)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;
	BOOL				bEndSession = FALSE;
	BOOL				bTimeOutSession = FALSE;   //4.0.0.66

	// Wait for User to enter required pInfo->
	// Check timeout for site controller....
	// close transaction/session in case of time out....

#ifdef CANCEL_IN_MIDDLE
	if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
	{								
		__int64 lFlags = CheckRequiredParam((CARD_SALE_ALL3 *)&pInfo->CardSaleInfo);

		if((lFlags & REQUIRED_PROMPT_REWARDS)	|| 
			(lFlags & REQUIRED_VOUCHER_NUMBER)	||
			(lFlags & REQUIRED_KEY_CODE)	)
		{						
			// in this case end session will be followed by Complete
			// Session Type = SESSION_CANCEL_AUTH
			pInfo->CardSaleInfo.cardData.sTranStatus = CD_DECLINE_GR;
		
		}
		else if (pInfo->CardSaleInfo.cardData.sTranStatus == CD_FORCE_COMPLETION_ZERO)
		{			
			pInfo->CardSaleInfo.cardData.sTranStatus = CD_FORCE_COMPLETION_ZERO;	//3.2.0.66			
		}
		else
		{	
			// Log Declined record

			m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
			
			// Switch back to Session Authorize - in this case   //4.0.15.290
			// "end session" will NOT be followed by Complete
			pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
			
			
			// this is not a decline , this is cancel by user - therfore there will be no 
			// logging.
			if (pInfo->CardSaleInfo.cardData.sTranStatus == CD_FORCE_COMPLETION_ZERO) //4.0.28.500 - TD 237976
				SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_FORCE_COMPLETION_ZERO, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
			else
				SendSwipeResult(pOla->m_byState,p+1, CD_NOT_OK,CD_DECLINE_ERROR, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
			
			
			if(LOG_BASIC_FLOW_CONTROL)
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
		}
		bEndSession = TRUE;
	}
#endif

	if (pDebitTimeout)		// 4.0.0.66
	{
		if (pDebitTimeout->lInterval)
		{
			SYSTEMTIME curSysTime;
			GetLocalTime(&curSysTime);		
			CTime curTime(curSysTime);
			CTime sendTime(pDebitTimeout->cSysTime);		
			CTimeSpan ts;
			ts = curTime - sendTime;

			if (ts.GetTotalSeconds() >= pDebitTimeout->lInterval)
			{
				CString sMsg;
				sMsg.Format("OLA message waiting timeout=%ld !!!!!!!", pDebitTimeout->lInterval);
				bTimeOutSession = TRUE;
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,sMsg);				
			}
		}
	}

	if(bEndSession || bTimeOutSession) //4.0.0.66
	{

		if (bEndSession)
		{
			pOla->m_byCheckCount = 0;					
			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_SEND_END);
		}
		else if (bTimeOutSession)   //4.0.0.66
		{

			pOla->m_byCheckCount = 0;	
			pInfo->CardSaleExtraData2.sPinPadResult = '1';			
			memset(pInfo->CardSaleExtraData2.sToken, ' ' , 2);			
			pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_REQUEST_TO_SEND_MORE);
		}
				
		if (lRtc == OLASRV_COM_ERROR)
		{
			pInfo->CardSaleExtraData2.sSessionOffLine = 'Y' ;
		}
		
		if((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
			(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
		{
			m_cDebitInfoArray[p].SetOlaStat(pOla);
			m_cDebitInfoArray[p].ConvertPAP2DebitInfo(pInfo);
		}
		else
		{
			m_cPumpArray[p].SetOlaStat(pOla); 
			m_cPumpArray[p].SetPAPInfo(pInfo);				

			SQLPumpSrvFile.SavePAPInfo(p + 1, __FUNCTION__, __LINE__);

			SavePumpInfo(p+1); // save ola stat.
		}				
	}
	

	return lRtc;
}

long CServerMain::DoAutoOLARequestToSendMore(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	USES_CONVERSION; 
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;


	// 1. get PAY_AT_PUMP_pInfo->
	// 2. send to OLA
	// 3, set send time 				
	// 4, set status to OLA_WAIT_RESPONSE
	// 5. save pump info to pump file.

	if(m_cOLASrv->Valid())
	{
		memset(m_cOLASrv->m_sOlaReqBuff,0,sizeof(m_cOLASrv->m_sOlaReqBuff));

		m_cOLASrv->BuildRequest(pOla->m_byState,p+1,(char *)pInfo,m_cOLASrv->m_sOlaReqBuff,NULL);

		GetLocalTime(&pOla->m_cSysTime);
		pOla->m_byCheckCount = 0;					

		if(LOG_BASIC_FLOW_CONTROL)
		{	
			CString str,strNew,strOutBuff(m_cOLASrv->m_sOlaReqBuff);

			m_cProtectedDataHandler.RemoveDataFromLog(strOutBuff, strNew);	
			
			str.Format(">>> OLA:AddParams, Session %d ", pOla->m_lSessionNumber);
			m_cLogger.LogOLABufferMsg(p+1, LOG_PUMP, str, (LPCTSTR)strNew);
		}

		lRtc = OLASRV_COM_ERROR;
		m_cOLASrv->m_lOlaRtc = lRtc;

		m_cOLASrv->m_lSessionId = pOla->m_lSessionNumber;
		
		if (CheckOLA()== OLA_SERVER_ON) 
		{
			CallOLA(OLA_REQUEST_TO_SEND_MORE,lPumpNumber);
			lRtc = m_cOLASrv->m_lOlaRtc ;
			m_cOLASrv->m_lQuerySessionResult[p]= lRtc;  //4.0.999.0
		}
		else
		{
			lRtc = OLASRV_COM_ERROR;
		}
	
		lRtc = m_cOLASrv->m_lOlaRtc;		

		//4.0.2.16
		if(lRtc != OLASRV_COM_ERROR)
			m_cOLASrv->ResetRetryAttemps();
	}

	if(m_cOLASrv->Valid() && (lRtc == 0 ))
	{					
		pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_WAIT_RESPONSE);											

		if(LOG_BASIC_FLOW_CONTROL)
			m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
	}
	else // OLASrv not available OR addparams return error
	{
		//if(session == Authorize)
		//	__decline
		
		if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
			(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
		{

		}
		else						
		{
			m_cCommonFunction.HandleMiscCardNotAuthorized(lPumpNumber, pInfo, &trs);
			SendSwipeResult(pOla->m_byState,p+1,CD_NOT_OK,CD_DECLINE_USEALT, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
		}

		if(LOG_DETAIL_FLOW_CONTROL)
		{
			if(!m_cOLASrv->Valid())
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,"OLASrv Not Valid !");
			else
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,"Failed to AddParam");
		}

#ifdef CANCEL_IN_MIDDLE			
		if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH)
		{								
			// Switch back to Session Authorize - in this case 
			// "end session" will NOT be followed by Complete
			pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);	
			if(LOG_BASIC_FLOW_CONTROL)
				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
		}
#endif

		pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_SEND_END);								
	}

	if (lRtc == OLASRV_COM_ERROR)
	{
		pInfo->CardSaleExtraData2.sSessionOffLine = 'Y' ;
	}

	if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
	{
		m_cDebitInfoArray[p].SetOlaStat(pOla);
		m_cDebitInfoArray[p].ConvertPAP2DebitInfo(pInfo);
	}
	else
	{
		m_cPumpArray[p].SetPAPInfo(pInfo);
		SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);
  
		m_cPumpArray[p].SetOlaStat(pOla); 
		SavePumpInfo(p+1); // save ola stat.
	}

	return lRtc;
}

long CServerMain::DoAutoOLASendEnd(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	CSQLPumpSrvFile  & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
	long				p = lPumpNumber - 1;
	CPumpTransact		trs(lPumpNumber);
	long				lRtc = 0;
	long lInternalCancelFlag = 0; //4.0.14.420
	//RECEIPT_INFO ReceiptInfo; //4.0.30.0 270322
	BOOL    bCancelInTheMiddleOfAuthorize = FALSE; // TD 357023	4.0.23.1970
	
	BYTE sTmpTrack2[TRACK_2_DATA_SIZE] = {0};//4.0.9.503 to save the track2 before the change
	
			//using for the gpi reprint 
	long lFlag = a2l(pInfo->CardSaleExtraData3.sFlags1,sizeof(pInfo->CardSaleExtraData3.sFlags1));//4.0.12.501

	trs.Clear();	

	//After Build Req gets OLSSrv data
// 	if (LOG_BASIC_FLOW_CONTROL)
// 	{
// 		_LOGMSG.LogOLAMsg(p + 1, pOla->m_byState, pOla->m_lSessionNumber);
// 		CString protectedDataStr, sLogMsg;
// 		m_cProtectedDataHandler.RemoveDataFromLog(CString(m_cOLASrv->m_sOlaReqBuff), protectedDataStr);
// 
// 		sLogMsg.Format("ReqType:%.20s, OutBuffer:%s", m_cOLASrv->m_sOlaReqType, protectedDataStr);
// 		m_cLogger.LogMsg(p + 1, LOG_PUMP, sLogMsg);
// 	}


	if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_SALE)     ||  //) //3.0.1.61
		(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)  ) //4.0.0.76 
	

	{
		trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());					

		if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))					
		{
			if ( trs.m_lMisc & MISC_TRS_PAP_CANCELED )
			{
				//In case this transaction was canceled because the customer
				//manage to end the transaction before his card was approved.
				//we need to zero all the totals.
				//and leave the pump status as UNPAID, because it's PAK now.
				ZeroPAPTotals(&trs,pInfo);
			}
			else if(PUMPSRV_IS_MASTER)
			{
				trs.m_lStatus = PAID;
				CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
			}
		}
		else
		{//4.0.14.1390 67387 4.0.21.0 If we're in PAK with loyalty and force complete, it's ok when there's no trs
			if (!(a2l(&(pInfo->CardSaleExtraData4.sInPAKLoyaltyWithComplete), sizeof(pInfo->CardSaleExtraData4.sInPAKLoyaltyWithComplete))))	
			{
				lRtc = 1;
				if(LOG_ERROR)
					m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber,"Faild on update trs to PAID !");						
			}
		}
	}
	if(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL)
	{
		trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());					
	}

	
	if( (SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL)   ||
		((SESSION_TYPE(pOla->m_byState) == SESSION_SALE && (pInfo->CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK)) 
		&&(!(lFlag & FL_SALE_REC))) || //) //3.0.1.61 //4.0.5.42 4.0.5.49 4.0.12.501
		(SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)  || //5.0.0.55
		(SESSION_TYPE(pOla->m_byState) == SESSION_CLOCK)) //5.0.0.55

	{

		if  ((trs.m_lResExt == RES_EXT_FLEET) && 
			 (pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) && 
			 (trs.m_lRoundedValue)) //4.0.9.509			 //4.0.10.16  //4.0.10.811
		{

			CPumpTransact cTmpTrs;
			cTmpTrs = trs;

			cTmpTrs.SetLink(TRS_NO_LINK,0);
			cTmpTrs.SetOnOffer(0);
			cTmpTrs.SetStatus(UNPAID);
			cTmpTrs.m_lRes = PAY_AT_KIOSK;			
			
			if (!(cTmpTrs.m_lMisc  & MISC_TRS_PAP_CANCELED))
				cTmpTrs.m_lMisc |= MISC_TRS_PAP_CANCELED;
			
			CentralUpdateTrs(lPumpNumber,cTmpTrs.m_lNumber,&cTmpTrs,FALSE);

			//4.0.10.16
			long lRtc1 = IndexOperation(PUMP_OLA_TEMP_FILE,REC_INSERT, &trs, pInfo);
			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("Diesel transaction was convert to PAK, trs=%ld,record was save Rtc=%ld" ,trs.m_lNumber , lRtc1);
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);

			}										

		}
		//4.0.7.506
		else if (CheckOLAReportRequird(trs , pInfo))			
		{
		//	3.	Change Trs Link number into new OLA Index number .
			pInfo->CardSaleInfo.lIndexNumber = NewOLAIndex();						
			trs.SetLink(TRS_LINK_OLA_NUMBER, pInfo->CardSaleInfo.lIndexNumber);	

			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format(">>> Force Operation : New OLA Index Number - %ld (Trs %ld, Value %ld, Volume %ld, Grade %d, GradePrice %ld) ",pInfo->CardSaleInfo.lIndexNumber,trs.m_lNumber,trs.m_lRoundedValue,trs.m_lRoundedVolume, trs.m_nGrade,trs.m_lGradePrice); 
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
			}						
			
			if (!IsShiftChangeInProgress())  //4.0.14.508
				trs.m_lActiveShiftNumber = m_cPumpArray[p].GetShiftNumber();
			
			//copy the track2
			memcpy(sTmpTrack2,pInfo->CardSaleInfo.cardData.sTrack2Data,sizeof(pInfo->CardSaleInfo.cardData.sTrack2Data));

			// QC 490652
			if ((pInfo->CardSaleInfo.cardData.sEntryMethod == ' ') || (pInfo->CardSaleInfo.cardData.sEntryMethod == 'M'))
				pInfo->CardSaleInfo.cardData.sEntryMethod = 'S';

			//4.0.27.500 merge from 4.0.124.353 178811 start 
			long lGrade = trs.m_nGrade;
			long lGradePos = GetGradePositionRestrection(lGrade, lPumpNumber);

			if (lGradePos > 0)  
			{
				lGradePos = lGradePos -1;
			}

			// RFUEL-4260, on we changed the discount logic,
			// now we have Loyalty and Payment discount.  Logic modified to take both discounts in the logic
			// To pass it properly to xml, the value must be 0 prefixed
			long lGasLoyaltyDiscountPerGallon = a2l(pInfo->CardSaleExtraData2.sDiscountPerGrade[lGradePos].sDiscount,sizeof(pInfo->CardSaleExtraData2.sDiscountPerGrade[lGradePos].sDiscount));
			long lGRDiscountPerGallon = a2l(pInfo->CardSaleInfo.cardData.sGRDiscountPerGallon, sizeof(pInfo->CardSaleInfo.cardData.sGRDiscountPerGallon));
			long lTenderDiscount = 0;			
			long lTotalDiscount = 0;

			if (GetOLAInUse() == OLASRV_EPSILON_DISCOUNT) 
			{
				lTenderDiscount = GetTenderDiscount(*pInfo);
				lTotalDiscount = (lTenderDiscount + lGasLoyaltyDiscountPerGallon);
			}
			else 
			{
				lTenderDiscount = 0;
				lTotalDiscount = lGasLoyaltyDiscountPerGallon;
			}

			if ((lGRDiscountPerGallon == 0) && (lTotalDiscount > 0))
			{						
				l2a0(lTotalDiscount, pInfo->CardSaleInfo.cardData.sGRDiscountPerGallon, sizeof(pInfo->CardSaleInfo.cardData.sGRDiscountPerGallon));
				if(LOG_BASIC_FLOW_CONTROL)
				{											
					CString str;
					str.Format("Discount per gallon was copied from discount array - GRDiscountPerGallon=%ld LoyaltyDiscount=%d TenderDiscount=%d", lTotalDiscount,
						lGasLoyaltyDiscountPerGallon, 
						lTenderDiscount);
					_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
				}		
			}
			else {
				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("DISCOUNT GRDiscountPerGallon=%ld LoyaltyDiscount=%d TenderDiscount=%d", 
						lTotalDiscount,
						lGasLoyaltyDiscountPerGallon,
						lTenderDiscount);
					_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, str);
				}
			}
			//4.0.27.500 - merge from 4.0.124.353 178811 end 

			//encrypt the account end delete track1,track2
			m_cProtectedDataHandler.GenerateIndex(pInfo, FALSE, trs.m_lNumber);		//4.0.22.501	TD 72716
			
			//UnMaskAccountNumberOnSessionComplete( lPumpNumber , pOla->m_byStat); // TD 332389

		//	4. insert to OLA file	
			//4.0.18.501
			lRtc = TrsLinkOperationEx(REC_INSERT,&trs, pInfo);   //4.0.21.0 67387							

			// insert info to receipt file
			if (lRtc == OK)
			{
				if ((trs.m_lRoundedValue ) || 
					IsNeedSaveZeroCompleteData(pOla->m_byState, trs.m_lRoundedValue ,trs.m_lRoundedVolume , pInfo->CardSaleInfo.cardData.sTranType))
				{
					CReceiptInfo ReceiptInfo;
					_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(&trs, pInfo, ReceiptInfo);//4.0.9.503

					long lRtc1 = CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

				}
				//Add by Yaron Ctrl Events
				m_cEventManager.AddEvent(CTRL_EVENT_PAP_TRS,0);

			}
		}

		if ((SESSION_TYPE(pOla->m_byState) != SESSION_CLOCK) && 
			(SESSION_TYPE(pOla->m_byState) != SESSION_INQUIRY))   //4.0.3.21 //4.0.3.22		//4.0.0.82
		{
			//copy the orginal track2 for the reprint from pos pump

			memcpy(pInfo->CardSaleInfo.cardData.sTrack2Data,sTmpTrack2,sizeof(sTmpTrack2));
			//m_cMemPumpArray[p].SetMemPumpInfo(pInfo ,&trs,&ReceiptInfo); //4.0.30.0 270322
			m_cMemPumpArray[p].SetMemPumpInfo(pInfo, &trs);
			
		}

		if(LOG_BASIC_FLOW_CONTROL)
		{											
			CString str;
			str.Format("SetMemPumpInfo step 4 Authorize by OLA ");
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
		}		


		if(lRtc)
		{
			if(LOG_LOGIC_ERROR)
			{
				CString str;
				str.Format("Insert Operation to OLAFile (After Force) Failed !!!  Trs %d, SeqNumber %d, lRtc %d", trs.m_lNumber,m_cPumpArray[p].GetPAPSeqNumber(), lRtc ); 
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str,LOG_LEVEL_1);
			}						
		}
	}


	if(LOG_BASIC_FLOW_CONTROL)
		m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);

	if( m_cOLASrv->Valid()&& (pOla->m_lSessionNumber >= 0))
	{
		lRtc = OLASRV_COM_ERROR;
		m_cOLASrv->m_lOlaRtc = lRtc;

		//ola12345	
		m_cOLASrv->m_lSessionId = pOla->m_lSessionNumber;
		if (CheckOLA()== OLA_SERVER_ON) 
		{
			m_cOLASrv->m_lSessionResult = m_cOLASrv->m_lQuerySessionResult[p];  
			if (m_cOLASrv->GetEndSessionEx())	//4.0.9.509
				CallOLA(OLA_SEND_ENDEX,lPumpNumber);				
			else
				CallOLA(OLA_SEND_END,lPumpNumber);
			lRtc = m_cOLASrv->m_lOlaRtc ;
		}
		else
		{
			lRtc = OLASRV_COM_ERROR;
		}

		//4.0.2.16
		if(lRtc != OLASRV_COM_ERROR)
			m_cOLASrv->ResetRetryAttemps();
	}	
	
	// We are here as a result of timeout in Authorization wait for response, (response for GR) 
	// and after we send PAPSwipeResult with CD_DECLINE_GR we need to send complete, 
	// changing the session type to SESSION_CANCEL_AUTH , will force completeion 
	// latter in this function .
	if( (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) && ((pInfo->CardSaleInfo.cardData.sTranStatus == CD_DECLINE_GR) || 
		 (pInfo->CardSaleInfo.cardData.sTranStatus == CD_FORCE_COMPLETION_ZERO))) //3.2.0.64
	{
		pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState, SESSION_CANCEL_AUTH);

		/***************************************************************************************************/
		//Special treatment for Egift in case of Force complite zero: need to update invoice number: TD 240021
		/***************************************************************************************************/
		if ((a2l(pInfo->CardSaleExtraData2.sMediaMasterType,sizeof(pInfo->CardSaleExtraData2.sMediaMasterType)) == CARD_TYPE_PREPAID_CASH) &&
			(pInfo->CardSaleInfo.extraData.sForceCompleteZero == 'Y'))
		{	
			long lInvoiceNumber = 0;
			GetReceiptCounter(&lInvoiceNumber, 0, 0);
			l2a(lInvoiceNumber,pInfo->CardSaleExtraData2.sInvoiceNumber,sizeof(pInfo->CardSaleExtraData2.sInvoiceNumber));

			CString strTmp;
			strTmp.Format("Cancel Auth - Call GetReceiptCounter, Receipt number = %ld. (InvoiceNumber)", lInvoiceNumber ); 																	
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);	
		}
	}

	BYTE by = SESSION_TYPE(pOla->m_byState);

	//Get the PumpSrv internal flags:  //TD 39439
	lInternalCancelFlag = GetOLAFlags(pInfo->CardSaleExtraData3.sFlags1 ,FL_CANCEL_REC,sizeof(pInfo->CardSaleExtraData3.sFlags1));

	CString strTmp;
	strTmp.Format("lInternalCancelFlag =  %ld", lInternalCancelFlag);
	m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, strTmp);

	
	if (	(
			(SESSION_TYPE(pOla->m_byState) == SESSION_GET_CUSTOMER_INFO) &&
			(pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK)) 
			||
			((SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) &&
			((pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) ||
			(lInternalCancelFlag)))
		)  //TD 39439
	{
		//failed on card authorization 
		trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());

		if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))
		{	
			if(PUMPSRV_IS_MASTER)
			{
				if (trs.m_lMisc & MISC_TRS_PAP_CANCELED)
				{
					if ( (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) && (m_cPumpArray[p].GetStat().GetStatus() == READY) )
						SendSwipeResult(pOla->m_byState,p+1,CD_FORCE_NOT_OK,pInfo->CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&pInfo->CardSaleInfo.cardData);
				}
				else
				{
					if (lInternalCancelFlag) //TD 39439
					{
						CString strTmp;
						strTmp.Format("Clearing transaction #%ld." , trs.m_lNumber); 																	
						_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, strTmp);			
					}

					long lTmp = a2l(pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1));
					//long BOOL	 bCanRemoved = (lTmp & FL_PAP_LOYALTY_ACCEPTED) || ((lTmp & FL_PAP_LOYALTY_ACCEPTED) && 

					if ((lTmp & FL_PAP_LOYALTY_ACCEPTED) || (lTmp & FL_PAP_PAYMENT_ACCEPTED))  //4.0.23.278?
					{
						pInfo->CardSaleInfo.cardData.sTranStatus = CD_FORCE_COMPLETION_ZERO;
					}

					else //if ((!(lTmp & FL_PAP_LOYALTY_ACCEPTED)) || (!(lTmp & FL_PAP_LOYALTY_ACCEPTED)))  //4.0.23.273?
					{
						//4.0.25.30 merge from 4.0.17.1260 TD 128663 
						if ((OLAByController() != 2) && 
							(FALSE == m_cPumpArray[p].IsZeroCompletionNeededForPAP())) //4.0.24.140 130693
						{
							m_cShiftLog.LogTrs(&trs, TRUE, FALSE);
							m_cPumpArray[p].ClearTrs(trs.m_lNumber);
							if (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())	//4.0.23.1300 310599
							{
								if (LOG_BASIC_FLOW_CONTROL)
								{
									CString str;
									str.Format(">>> Clear OLA SessionId %ld , state=%d ", pOla->m_lSessionNumber, pOla->m_byState);
									m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
								}
								m_cFuelLoayaltyPS.CancelTicket(lPumpNumber);
								m_cPumpArray[p].ClearOlaStat();   //Clear OLA state . 4.0.23.2805
								m_cPumpArray[p].GetOlaStat(pOla);   //Clear OLA state . 4.0.23.2805
							}
						}
					}
					//else  if (lTmp & FL_PAP_LOYALTY_ACCEPTED)   //4.0.23.278?
					//{
					//	pInfo->CardSaleInfo.cardData.sTranStatus = CD_FORCE_COMPLETION_ZERO;
					//}
				}
			}
		}
		else if(FALSE == m_cPumpArray[p].GetInProgressWaitProgressTrs(&trs))//4.0.3.37
		{
			if(PUMPSRV_IS_MASTER)
			{
				m_cShiftLog.LogTrs(&trs, TRUE,FALSE);
				m_cPumpArray[p].ClearTrs(trs.m_lNumber);
			}
		}
	}


	if( (SESSION_TYPE(pOla->m_byState) == SESSION_RECEIPT_AUTH) &&
		(pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) )
	{					
		pOla->m_lSessionNumber = 0; 
		pOla->m_byCheckCount = 0;
		pOla->m_byState = OLA_REQUEST_TO_SEND | SESSION_AUTHORIZE;
		if(LOG_BASIC_FLOW_CONTROL)
			m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
		m_cPumpArray[p].SetOlaStat(pOla); 
	}

#ifdef CANCEL_IN_MIDDLE			
	else if ( SESSION_TYPE(pOla->m_byState) == SESSION_CANCEL_AUTH ) 
	{	
		// 		if ((_Module.m_server.GetFlowControlType() == DYNAMIC_PAP_FLOW) && 		
		// 			(a2l(pInfo->CardSaleExtraData3.sLoyaltySessionID, sizeof(pInfo->CardSaleExtraData3.sLoyaltySessionID))&& 
		// 			(pInfo->CardSaleInfo.cardData.sTranStatus != 'A') )) //4.0.23.273?
		// 		{
		// 
		// 			if(LOG_BASIC_FLOW_CONTROL)
		// 				m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber, "update ends session");
		// 			   pInfo->CardSaleInfo.cardData.sTranStatus = CD_FORCE_COMPLETION_ZERO;
		// 			   pOla->m_byState = OLA_SEND_END + SESSION_AUTHORIZE ;
		// 			   	m_cPumpArray[p].SetOlaStat(pOla); 
		// 			   //pOla->m_byState = SESSION_NEW_TYPE(pOla->m_byState,SESSION_AUTHORIZE);
		// 		}
		// 		else 
					bCancelInTheMiddleOfAuthorize = DoCancelInTheMiddleOfAuthorize(pInfo, pOla, p, trs); // TD 357023	4.0.23.1970	
	}
#endif
	else
	{

		if (lRtc == OLASRV_COM_ERROR)
		{
			pInfo->CardSaleExtraData2.sSessionOffLine = 'Y' ;
		}

		if (SESSION_TYPE(pOla->m_byState) == SESSION_GENERATE_REPORT)
		{
			m_cReportArray[p].ClearOlaStat();
			m_cReportArray[p].SetRequestStatus(RS_SENT);

		}
		else if ((SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT) || 
			(SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT))
		{
			m_cDebitInfoArray[p].ClearOlaStat();
			m_cDebitInfoArray[p].ClearDebitInfo();

			if (SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)
				m_cInitDebitHandler.SetStatus(p+1,DEBIT_SERVER_IDLE) ; //4.0.3.58
		}
		else if (SESSION_TYPE(pOla->m_byState) == SESSION_GET_REPORT)
		{
			m_cReportArray[p].ClearOlaStat();

		}
		else
		{
			m_cPumpArray[p].ClearOlaStat();
		}
	}
	
	if (SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)
	{
		long lAlarmRetCode = 0;

		if (pInfo->CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK)
			lAlarmRetCode = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,
			SUB_OLA,
			INIT_DEBIT_SUCCESSFUL,
			p + 1,
			ALARM_ON,
			p + 1,
			0);
		else
			lAlarmRetCode = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,
			SUB_OLA,
			INIT_DEBIT_FAILED,
			p + 1,
			ALARM_ON,
			p + 1,
			0);
	}

	// 3.2.0.76
	if (((SESSION_TYPE(pOla->m_byState) == SESSION_SALE) ||	
		 (SESSION_TYPE(pOla->m_byState) == SESSION_CAPTURE)) && //5.0.0.55			
		(trs.m_lResExt == RES_EXT_ATTENDANT))
	{
		CPumpTransact cTmpTrs;
		cTmpTrs = trs;

		// Fail to Sale Attend transaction.
		if ((pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) && 
			(SESSION_TYPE(pOla->m_byState) == SESSION_SALE))   //4.0.0.75
		{
				cTmpTrs.SetOnOffer(0);
				cTmpTrs.SetStatus(UNPAID);						
				CentralUpdateTrs(lPumpNumber,cTmpTrs.m_lNumber,&cTmpTrs,FALSE);

		}
		else
		{
			cTmpTrs.SetLink(TRS_LINK_ATTEND,0);
			lRtc = TrsLinkOperation(REC_DELETE , &cTmpTrs, NULL);
			if (lRtc)
			{
				CString strTmp;
				strTmp.Format("Fail !!! Delete  Attend record=%ld form ExtaInfo Rtc=%d" , cTmpTrs.m_lNumber , lRtc); 																	
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);								
			}										
		}
	}
	//3.2.0.76
	///////////////////////////////////////////////////////////////////
	//3.2.1.44
	else if (SESSION_TYPE(pOla->m_byState) == SESSION_SALE) 
	{
		
		if ((pInfo->CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) && 
			(trs.m_lMisc & MISC_VIT_CONFLICT)) 
		{

			CPumpTransact cTmpTrs;
			cTmpTrs = trs;
			cTmpTrs.SetOnOffer(0);
			cTmpTrs.SetStatus(UNPAID);											
			cTmpTrs.SetLink(0,0);
			cTmpTrs.m_lRes = PAY_AT_KIOSK;			


			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("Sale xxx=%c,ResExt=%ld, Misc=%ld, sTranStatus[%x]",pInfo->CardSaleInfo.cardData.sTranType, cTmpTrs.m_lResExt ,trs.m_lMisc ,pInfo->CardSaleInfo.cardData.sTranStatus);
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
			}


			//4.0.2.27
			if (trs.m_lMisc  & MISC_ORIGINAL_ATTENDANT_TRS)
			{
				cTmpTrs.m_lResExt = RES_EXT_ATTENDANT;
				cTmpTrs.m_lMisc &= MISC_NOT_ORIGINAL_ATTENDANT_TRS;
			}

			else
				cTmpTrs.m_lResExt = NULL_RES_EXT;  //4.0.1.0 //4.0.2.251

			CentralUpdateTrs(lPumpNumber,cTmpTrs.m_lNumber,&cTmpTrs,FALSE);		
			//4.0.2.27
		}
		else if ((pInfo->CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK) &&	//4.0.22.440 133580 //4.0.25.501
			(trs.m_lMisc & MISC_VIT_CONFLICT))
		{
			//Delete extra info record if exists 4.0.22.231 97935
			EXTRA_INFO_REC ExtraInfoRec;
			memset(&ExtraInfoRec , 0, sizeof(EXTRA_INFO_REC));

			ExtraInfoRec.info.lIndexNumber = trs.m_lNumber;
			long lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);

			if (!lRtc)
			{
				//Delete record.
				lRtc = IndexOperation(EXTRA_INFO_FILE, REC_DELETE, &ExtraInfoRec);

				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Remove extra info record in avi conflict after SALE session. Found extra info data for trs number %ld, record removed status %ld  ",trs.m_lNumber, lRtc);
					_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, str);
				}

			}	
			
		}

	}

	//3.2.1.44
	if(SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE)
	{

		InsertToPaidQDX(trs);//4.11.503

		if( FALSE == bCancelInTheMiddleOfAuthorize ) // TD 357023	4.0.23.1970
		{
			// if there was cancel in the middle of authorize do not clear the tracks so would be able to send it in the complete session
			memset(&pInfo->CardSaleInfo.cardData.sTrack1Data , ' ' , sizeof(pInfo->CardSaleInfo.cardData.sTrack1Data));  //4.0.23.1710
			memset(&pInfo->CardSaleInfo.cardData.sTrack2Data , ' ' , sizeof(pInfo->CardSaleInfo.cardData.sTrack2Data));
		}

		if(m_cPumpArray[p].IsForceZeroPakCompletionOn())
		{
			// delete ash2000 and clear trs num
			long lTrsNumber = m_cPumpArray[p].GetPapToPakTrsNum(); 
			if(lTrsNumber != NULL_TRS_NUM)
			{
				if (m_cPumpArray[lPumpNumber -1].IsSavedDataInAsh2000Qdx()) //4.0.25.50 118124
					DeleteFromAsh2000Qdx(lTrsNumber); 

				m_cPumpArray[p].SetPapToPakTrsNum(-1);

				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("PAK Loylty Trs with PAK Force Completion, Deleted Record from Ash2000Qdx. trs number=%d",lTrsNumber);
					m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
				}
			}
			else
			{
				m_cLogger.LogMsg("PAK Loylty Trs with PAK Force Completion, Found illegal Trs number! Record in Ash2000Qdx was not deleted.",LOG_LEVEL_1);
			}

			ClearDiscountsInfo(lPumpNumber, pInfo); //4.0.28.503 - TD 263766
			
		} // TD 256101
	}
	//automatically strat  //4.0.5.12 
	if (m_cDebitInfoArray[p].GetPendingInitDebitSession())
	{										
		CString strTmp;
		
		 m_cInitDebitHandler.SetStatus(p + 1, DEBIT_SERVER_REQUEST_TO_START);
		strTmp.Format("Start init debit pending session Pump = %ld", p); 																	
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);								

		m_cDebitInfoArray[p].SetPendingInitDebitSesssion(FALSE);

		strTmp.Format("Clear waiting pending Pump=%ld", p); 																	
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);								


	}
	//4.0.5.12 

	if( (SESSION_TYPE(pOla->m_byState) != SESSION_GENERATE_REPORT) &&
		(SESSION_TYPE(pOla->m_byState) != SESSION_GET_REPORT) )
	{
		m_cPumpArray[lPumpNumber-1].SetPAPInfo(pInfo);  //4.0.17.502 (Merge 4.0.14.850)
		SQLPumpSrvFile.SavePAPInfo(p + 1, __FUNCTION__, __LINE__);
		SavePumpInfo(p+1); // save ola stat.
	}

	return lRtc;
}


// Refactored - pulled out of the switch statment, created a new function call
long CServerMain::DoAutoOLAProcessAfterSendEnd(long lPumpNumber, OLA_STAT& PreviousOLA, OLA_STAT& ola, PAY_AT_PUMP_INFO& info)
{
	CPump& Pump = _Module.m_server.GetPump(lPumpNumber);

	// RFUEL-569
	if ((ola.m_byState & SESSION_GET_CUSTOMER_INFO) && (info.CardSaleInfo.cardData.sTranStatus != CD_APPROVE_OK) &&
		(_Module.m_server.m_cFlowControlManager.GetPumpSrvAddMemberCardRes(lPumpNumber) == LOYALTY_STATE_UNAVALIABLE_ERROR))
	{
		ola.m_byState = OLA_NEW_STATE(ola.m_byState, OLA_WAIT_CONTROLLER_MSG);
		Pump.SetOlaStat(&ola);
		OpenNeedMoreParam(info, lPumpNumber, info.CardSaleInfo.cardData.sResultMsg, 1, NMP_DEFAULT_TIMEOUT, ONMP_OpenYesNoKeys, 0, PT_BOOL);
	}
	else if ((ola.m_byState & SESSION_GET_CUSTOMER_INFO) &&
		(info.CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK))   //4.0.23.2735
	{
		if (_Module.m_server.m_cFlowControlManager.GetPumpSrvAddMemberCardRes(lPumpNumber) == LOYALTY_STATE_PUNCHH_ERROR) {
			m_cFlowControlManager.HandlePunchhNMPAlternateIDRetry(lPumpNumber, &ola, &info);
		}
		else
		{
			//RFUEL-2817
			if (IsLoyaltyDiscountApplied(lPumpNumber)) {

				// Apply the payment/tender discount to nozzle discount matrix if any
				ApplyPaymentCardDiscount(lPumpNumber, info);

				// Copy the discount to sTenderDiscount 
				CopyPaymentDiscountToTenderDiscount(info);

				// Set DiscountPerGallon to 0 (empty)
				SetPaymentDiscount(info, 0);

				// Update PAPInfo 
				Pump.SetPAPInfo(&info);

				m_cFlowControlManager.StartAfterQueryFlowControl(lPumpNumber, ola, info);
			}
			else
			{
				if (GetOLAInUse() == OLASRV_EPSILON_DISCOUNT)
				{
					long lTmp = a2l(info.CardSaleExtraData3.sFlags1, sizeof(info.CardSaleExtraData3.sFlags1));

					if (lTmp & FL_PAP_LOYALTY_ACCEPTED)
					{
						lTmp = lTmp - FL_PAP_LOYALTY_ACCEPTED;
						l2a(lTmp, info.CardSaleExtraData3.sFlags1, sizeof(info.CardSaleExtraData3.sFlags1));
						info.CardSaleInfo.extraData.sForceCompleteZero = ' ';
						m_cPumpArray[lPumpNumber - 1].SetPAPInfo(&info);
					}

				}
				m_cFlowControlManager.StartAfterAddMemberFlowControl(lPumpNumber, &ola, 0);//4.0.22.504 69344 If fail - continue to next NMP								
			}
		}
	}
	else if (SESSION_TYPE(ola.m_byState) == SESSION_GET_CUSTOMER_INFO)  //4.0.23.27??
	{
		ola.m_byState = OLA_NEW_STATE(ola.m_byState, OLA_LOYALTY_SWIPE_LOYALTY);
		Pump.SetOlaStat(&ola);
		m_cLogger.LogOLAMsg(lPumpNumber, ola.m_byState, ola.m_lSessionNumber);
	}
	else if (ola.m_byState & SESSION_SET_CUSTOMER_INFO)
	{
		long lTmp = a2l(info.CardSaleExtraData3.sFlags1, sizeof(info.CardSaleExtraData3.sFlags1));  //4.0.23.278?

		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("Pump %02d SESSION_SET_CUSTOMER_INFO - Flag=%.x, ola state=%.x  ", lPumpNumber, lTmp, ola.m_byState);
			m_cLogger.LogMsg(str);
		}

		if ((lTmp & FL_PAP_PAYMENT_ACCEPTED))
		{
			// send complete for payment;
			ola.m_byState = SESSION_COMPLETE | OLA_REQUEST_TO_SEND;
			Pump.SetOlaStat(&ola);
			m_cFlowControlManager.SetNMPTime(lPumpNumber, FALSE);

		}
		else
		{
			if (OLA_STATE(ola.m_byState) == OLA_SEND_END)
			{
				CPumpTransact cTemptrs;
				if (FALSE == Pump.GetInProgressWaitProgressTrs(&cTemptrs))//4.0.3.37
				{
					if (PUMPSRV_IS_MASTER)
					{
						m_cShiftLog.LogTrs(&cTemptrs, TRUE, FALSE);
						Pump.ClearTrs(cTemptrs.m_lNumber);

						CPumpStatus stat = Pump.GetStat();
						stat.SetRes(NULL_RES, NULL_RES_EXT);
						Pump.SetStat(stat);
					}
				}

				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Pump %02d SESSION_SET_CUSTOMER_INFO - Trs removed=%ld  ", lPumpNumber, cTemptrs.m_lNumber);
					m_cLogger.LogMsg(str);
				}
				_Module.m_server.SendSwipeResult(ola.m_byState, lPumpNumber, CD_FORCE_NOT_OK, info.CardSaleInfo.cardData.sTranStatus, (CARD_SALE_ALL3 *)&info.CardSaleInfo.cardData);
			}
		}
	}


	const bool bAuthorizedApproved = (SESSION_TYPE(PreviousOLA.m_byState) == SESSION_AUTHORIZE) && (info.CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK);
	if (bAuthorizedApproved) {//4.0.23.273?												
							  // Moves the Current State to the Next State
		DoAutoOlaFuelLoyaltyContNMPSessionsAfterAuthPayment(lPumpNumber, &ola, &info);	//4.0.22.500 70767						
	}

	return 0L;
}
bool CServerMain::DumpPaymentCardDiscount(long PumpNumber, const PAY_AT_PUMP_INFO& Info) {
	const long lPaymentCardDiscount = this->GetPaymentDiscount(Info);
	
	if (LOG_DETAIL_FLOW_CONTROL) {
		LogStream Log;
		long lGRDiscount = GetPaymentDiscount(Info);
		long lTenderDiscount = GetTenderDiscount(Info);

		Log << "GRDiscount=" << lGRDiscount << " TenderDiscount=" << lTenderDiscount << std::ends;
		m_cLogger.LogMsg(Log);


		// Add the Payment discount to each loyalty matrix of discount for each grade
		for (int GradeIndex = 0; GradeIndex < MAX_GRADES; GradeIndex++) {
			// SWK		
			long lDiscount = GetLoyaltyDiscount(Info, PumpNumber, GradeIndex);
			Log << "Grade = " << GradeIndex + 1 << " Discount=" << lDiscount << std::ends;

			m_cLogger.LogMsg(Log);
		}
	}
	return 0;
}

//RFUEL-2817
bool CServerMain::ApplyPaymentCardDiscount(long lPumpNumber, PAY_AT_PUMP_INFO& Info) {
	const long lPaymentCardDiscount = this->GetPaymentDiscount(Info);
	const bool bApplyDiscount = lPaymentCardDiscount > 0;

	if (bApplyDiscount)
	{
		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("%s Discount Applied=%c Adding to Discount Matrix", __FUNCTION__, IsLoyaltyDiscountApplied(lPumpNumber) ? '1' : ' ');
			m_cLogger.LogMsg(str);
		}

		// Add the Payment discount to each loyalty matrix of discount for each grade
		for (int GradeIndex = 0; GradeIndex < MAX_GRADES; GradeIndex++) {
			FinalLoyaltyDiscount(Info, lPumpNumber, GradeIndex, lPaymentCardDiscount);
		}
		
//		DumpPaymentCardDiscount(lPumpNumber, Info);
	}

	return bApplyDiscount;
}


//RFUEL-2817
void CServerMain::CopyPaymentDiscountToTenderDiscount(PAY_AT_PUMP_INFO& Info) 
{
	// Copy the discount to sTenderDiscount 
	constexpr size_t DISCOUNT_SIZE = sizeof(Info.CardSaleExtraData6.sTenderDiscount);
	BYTE* pTenderDiscount = &Info.CardSaleExtraData6.sTenderDiscount[0];
	BYTE* pGRDiscountPerGallon = &Info.CardSaleInfo.cardData.sGRDiscountPerGallon[0];
	std::memcpy(pTenderDiscount, pGRDiscountPerGallon, DISCOUNT_SIZE);

	if (LOG_BASIC_FLOW_CONTROL)
	{
		const std::string sDiscount = std::string(pTenderDiscount, pTenderDiscount + sizeof(Info.CardSaleInfo.cardData.sGRDiscountPerGallon));
		CString str;
		str.Format("%s Copying pGRDiscountPerGallon to sTenderDiscount.  Value is %s",
			__FUNCTION__, sDiscount.c_str());
		m_cLogger.LogMsg(str);
	}
}


//RFUEL-2817
void CServerMain::CopyTenderDiscountToPaymentDiscount(PAY_AT_PUMP_INFO& Info)
{
	// Copy the discount to sTenderDiscount 
	constexpr size_t DISCOUNT_SIZE = sizeof(Info.CardSaleInfo.cardData.sGRDiscountPerGallon);
	BYTE* pTenderDiscount = &Info.CardSaleExtraData6.sTenderDiscount[0];
	BYTE* pGRDiscountPerGallon = &Info.CardSaleInfo.cardData.sGRDiscountPerGallon[0];
	std::memcpy(pGRDiscountPerGallon, pTenderDiscount, DISCOUNT_SIZE);

	if (LOG_BASIC_FLOW_CONTROL)
	{
		const std::string sDiscount = std::string(pGRDiscountPerGallon, pGRDiscountPerGallon + sizeof(Info.CardSaleInfo.cardData.sGRDiscountPerGallon));
		CString str;
		str.Format("%s Copying sTenderDiscount to pGRDiscountPerGallon. Value is %s",
			__FUNCTION__, sDiscount.c_str());
		m_cLogger.LogMsg(str);
	}
}

__int64 CServerMain::CheckRequiredParam(CARD_SALE_ALL3 *pCardData)
{

	__int64 lFlags = 0;

	if (pCardData->CardSaleAll.data.sOdometer[0]	== '?') 
		lFlags += REQUIRED_ODOMETER;
	if (pCardData->CardSaleAll.data.sFullVehicleId[0] == '?') 
		lFlags += REQUIRED_CAR_REGISTRATION;
	if (pCardData->CardSaleAll.data.sPINBlock[0]	== '?') 
		lFlags += REQUIRED_PIN;
	if(pCardData->CardSaleAll.data.sReturnTank	== '?') 
		lFlags += REQUIRED_RETURN_TANK;
	if(pCardData->CardSaleAll.data.sDriverId[0] == '?') 
		lFlags += REQUIRED_DRIVER_ID;
	if (pCardData->CardSaleAll.data.sGRPrompt == '?') 
		lFlags += REQUIRED_PROMPT_REWARDS;
	if(pCardData->CardSaleAll.data.sGRVoucherNumber[0]	== '?') 
		lFlags +=REQUIRED_VOUCHER_NUMBER;
	if(pCardData->CardSaleAll.data.sGRKeyCode[0]	== '?') 
		lFlags += REQUIRED_KEY_CODE;
	if(pCardData->CardSaleAll.data.sTrack2Data[0] == '?')		
		lFlags += REQUIRED_PAYMENT_CARD;
	if(pCardData->CardSaleAll.data.sGeneralID[0] == '?')		
		lFlags += REQUIRED_GENERAL_ID;
	if( (pCardData->CardSaleAll.data.sTranType >= '1') || (pCardData->CardSaleAll.data.sTranType <= '9'))		
		lFlags += REQUIRED_MEDIA_TYPE;

	if (pCardData->CardSaleAll.data.sTranType == '?')  //4.0.23.1150 //4.0.29.501 291147
		lFlags += REQUIRED_MEDIA_TYPE;

	//4.0.15.502
	if(pCardData->extData3.sPONumber[0] == '?')	
		lFlags += REQUIRED_PO_NUMBER_PARAM;

// husky start
	if (pCardData->extData2.sUnit[0] == '?')
		lFlags += REQUIRED_UNIT;
	if( pCardData->extData2.sTripNumber[0] == '?')
		lFlags += REQUIRED_TRIP_NUMBER;
	if (pCardData->extData2.sCustomerReference[0] == '?')
		lFlags += REQUIRED_CUSTOMER_REFERENCE;
	if(pCardData->extData2.sTractorHub[0] == '?')
		lFlags += REQUIRED_TRACTOR_HUB;
	if(pCardData->extData2.sTrailerNumber[0] == '?')
		lFlags += REQUIRED_TRAILER_NUMBER;
	if(pCardData->extData2.sTrailerHub[0] == '?')
		lFlags += REQUIRED_TRAILER_HUB;
	if(pCardData->CardSaleAll.extData.sTotalAmt[0] == '?')
		lFlags += REQUIRED_TRANS_AMOUNT;

	if (( pCardData->extData2.sDeclinedLoyaltyPrompt >= '1') && ( pCardData->extData2.sDeclinedLoyaltyPrompt <= '3'))
		lFlags += REQUIRED_DECLINE_LOYALTY_PROMTE;

	
	if ( pCardData->extData2.sPassCode [0] == '?')
		lFlags += REQUIRED_PASS_CODE;	


	if (pCardData->CardSaleAll.extData.sRedeemPoints == '?')
		lFlags += REQUIRED_REDEED_POINT_ACTION;
	
	if (pCardData->CardSaleAll.extData.sConfirmPrompt == '?')
		lFlags += REQUIRED_CONFIRM_PROMPT_ACTION;

	if(pCardData->CardSaleAll.data.sClubCardTrack2Data[0] == '?') 
		lFlags += REQUIRED_PAYMENT_LOYALTY_CARD;

	

	if (pCardData->extData3.sParamResult[0] == '?')
		lFlags += REQUIRED_PARAM_RESULT_DATA;


	if (pCardData->extData3.sRemoteID[0] == '?')
		lFlags += REQUIRED_REMOTE_ID;

	if (pCardData->extData3.sLogicShiftNumber[0] == '?')
		lFlags += REQUIRED_LOGIC_SHIFT_NUMBER;	
		
	if (pCardData->CardSaleAll.data.sAuthNumber[0] == '?')
		lFlags += REQUIRED_AUTHORIZATION_NUMBER;

	if (pCardData->extData3.sCombinedCardSelect == '?')
		lFlags += REQUIRED_CnP_PARAM;

	if (pCardData->extData3.sCVMResult[0] == '?')
		lFlags += REQUIRED_CnP_PARAM;
	
	if (pCardData->extData3.sTermResponseCode[0] == '?')
		lFlags += REQUIRED_CnP_PARAM;

	if (pCardData->extData5.ExtraEMVDataReq == '?')
		lFlags += REQUIRED_MORE_EMV_DATA;

	// husky end
	return lFlags;

}

//4.0.18.501 ex was removed
long CServerMain::ConstructAndSaveCardData(long lFlags, long lPumpNumber, long lSeqNumber, CARD_SALE_ALL3 * pCardData , long lVersion, BOOL bPAPInfoUpdate )
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();
	PAY_AT_PUMP_INFO info;     //4.0.5.0
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&info);


	switch(lFlags)
	{
		case SWIPE_REQUEST:		
		case SWIPE_RECEIPT_CHECK:
		{
			memset(&info.CardSaleInfo.extraData,' ',sizeof(CARD_SALE_EXTRA_DATA) );	
			info.CardSaleInfo.lIndexNumber	= 0; // will be set to Index number at the PAPReadyTrs
												 
			if (info.CardSaleExtraData5.sLoyaltyAutoArm == '1') // QC 502830
			{
				pCardData->extData5.sLoyaltyAutoArm = info.CardSaleExtraData5.sLoyaltyAutoArm;
			}
						
			memcpy(&info.CardSaleInfo.cardData	 ,pCardData , sizeof(CARD_SALE_ALL3));

			info.CardSaleInfo.cardData.sTranStatus = CD_READY;
			info.CardSaleInfo.cardData.sIsStoreAndForward = 'F';

			if(lFlags == SWIPE_REQUEST)
			{
				DWORD dwTmp = GetLimit(PRICE_LEVEL_CREDIT,lPumpNumber);
				l2a(dwTmp,info.CardSaleInfo.cardData.sRequestAmt,sizeof(info.CardSaleInfo.cardData.sRequestAmt));
				l2a(SURCHARGE_AMOUNT_FOR_PRE_AUTH,info.CardSaleInfo.cardData.sSurchargeAmt,sizeof(info.CardSaleInfo.cardData.sSurchargeAmt));
			}
		}
		break;

		case SWIPE_EXTRA_INFO:			
		{
			info.CardSaleInfo.cardData.sTranStatus = CD_READY;

			//4.0.13.506 
			//If m_bExpectAllDetailsInNeedMoreParam is on - copy all of the parameters.
			if (m_bExpectAllDetailsInNeedMoreParam)
			{
				memcpy(&info.CardSaleInfo.cardData,&pCardData->CardSaleAll.data,sizeof(info.CardSaleInfo.cardData));
				memcpy(&info.CardSaleInfo.extraData,&pCardData->CardSaleAll.extData,sizeof(info.CardSaleInfo.extraData));//4.0.20.53 64295
				memcpy(&info.CardSaleExtraData2,&pCardData->extData2,sizeof(info.CardSaleExtraData2));
				memcpy(&info.CardSaleExtraData3,&pCardData->extData3,sizeof(info.CardSaleExtraData3));
				memcpy(&info.CardSaleExtraData4,&pCardData->extData4,sizeof(info.CardSaleExtraData4));	//46512	4.0.18.507
				memcpy(&info.CardSaleExtraData5,&pCardData->extData5,sizeof(info.CardSaleExtraData5));	//46512 4.0.18.507
				memcpy(&info.CardSaleExtraData6,&pCardData->extData6,sizeof(info.CardSaleExtraData6));	//46512 4.0.18.507
			}
			else
			{
				if(info.CardSaleInfo.extraData.sConfirmPrompt == '?')	//4.0.14.1530 68304 4.0.22.0
				{
					info.CardSaleInfo.extraData.sConfirmPrompt = pCardData->CardSaleAll.extData.sConfirmPrompt;
					info.CardSaleExtraData2.sDisplayOLAResultMessage = pCardData->extData2.sDisplayOLAResultMessage;
				}

				if(info.CardSaleInfo.cardData.sDriverId[0] == '?')
				{
					memcpy(info.CardSaleInfo.cardData.sDriverId,pCardData->CardSaleAll.data.sDriverId,sizeof(info.CardSaleInfo.cardData.sDriverId));
					memcpy(info.CardSaleExtraData3.sDriverId_MSB,pCardData->extData3.sDriverId_MSB,sizeof(info.CardSaleExtraData3.sDriverId_MSB)); //4.0.5.42
					memcpy(info.CardSaleExtraData4.sDriverId_MSB2,pCardData->extData4.sDriverId_MSB2,sizeof(info.CardSaleExtraData4.sDriverId_MSB2)); //4.0.23.370 117473 //4.0.24.90
				}
				
				if(info.CardSaleInfo.cardData.sOdometer[0] == '?')	//4.0.0.43
				{									
					memcpy(info.CardSaleInfo.cardData.sOdometer,pCardData->CardSaleAll.data.sOdometer,sizeof(info.CardSaleInfo.cardData.sOdometer));
					memcpy(info.CardSaleInfo.extraData.sOdometerExt,pCardData->CardSaleAll.extData.sOdometerExt,sizeof(info.CardSaleInfo.extraData.sOdometerExt));
					memcpy(&info.CardSaleExtraData4.sOdometerExt2,&pCardData->extData4.sOdometerExt2,sizeof(info.CardSaleExtraData4.sOdometerExt2)); //4.0.22.511 74797
				}

				//4.0.22.511 74797 start
				if(info.CardSaleExtraData4.sJob[0] == '?')
				{
					memcpy(info.CardSaleExtraData4.sJob,pCardData->extData4.sJob,sizeof(info.CardSaleExtraData4.sJob));
				}

				if(info.CardSaleExtraData4.sDepartment[0] == '?')
				{
					memcpy(info.CardSaleExtraData4.sDepartment,pCardData->extData4.sDepartment,sizeof(info.CardSaleExtraData4.sDepartment));
				}

				if(info.CardSaleExtraData4.sLicense[0] == '?')
				{
					memcpy(info.CardSaleExtraData4.sLicense,pCardData->extData4.sLicense,sizeof(info.CardSaleExtraData4.sLicense));
				}

				if(info.CardSaleExtraData3.sCustomerID[0] == '?')
				{
					memcpy(info.CardSaleExtraData3.sCustomerID, pCardData->extData3.sCustomerID, sizeof(info.CardSaleExtraData3.sCustomerID));
					memcpy(info.CardSaleExtraData4.sCustomerIDExt, pCardData->extData4.sCustomerIDExt, sizeof(info.CardSaleExtraData4.sCustomerIDExt)); //4.0.23.500 74797
				}
				//4.0.22.511 74797 end

				if((info.CardSaleInfo.cardData.sPINBlock[0] == '?') || 
					(!ChrAll((char*)pCardData->CardSaleAll.data.sPINBlock, sizeof(pCardData->CardSaleAll.data.sPINBlock))))
				{
					memcpy(info.CardSaleInfo.cardData.sPINBlock, pCardData->CardSaleAll.data.sPINBlock, sizeof(info.CardSaleInfo.cardData.sPINBlock));
					memcpy(info.CardSaleInfo.cardData.sExtendPIN, pCardData->CardSaleAll.data.sExtendPIN, sizeof(info.CardSaleInfo.cardData.sExtendPIN));  //2.9.1.4
				}
				if(info.CardSaleInfo.cardData.sReturnTank == '?')
					info.CardSaleInfo.cardData.sReturnTank = pCardData->CardSaleAll.data.sReturnTank;
				if(info.CardSaleInfo.cardData.sFullVehicleId[0] == '?')
					memcpy(info.CardSaleInfo.cardData.sFullVehicleId, pCardData->CardSaleAll.data.sFullVehicleId, sizeof(info.CardSaleInfo.cardData.sFullVehicleId));

				if(info.CardSaleInfo.cardData.sTrack2Data[0] == '?')
				{
					memcpy(info.CardSaleInfo.cardData.sTrack2Data,pCardData->CardSaleAll.data.sTrack2Data,sizeof(info.CardSaleInfo.cardData.sTrack2Data));

					//4.0.12.518
					// In case we got account number from Cl2PumpSrv (tesco) Overwrite it .
					if (!ChrAll((char *)pCardData->CardSaleAll.data.sAccountNumber,sizeof(pCardData->CardSaleAll.data.sAccountNumber)))
						memcpy(info.CardSaleInfo.cardData.sAccountNumber,pCardData->CardSaleAll.data.sAccountNumber,sizeof(info.CardSaleInfo.cardData.sAccountNumber));	//4.0.12.508
				}
				if(info.CardSaleInfo.cardData.sGRPrompt == '?')
					info.CardSaleInfo.cardData.sGRPrompt = pCardData->CardSaleAll.data.sGRPrompt;
				if(info.CardSaleInfo.cardData.sGRVoucherNumber[0] == '?')
					memcpy(info.CardSaleInfo.cardData.sGRVoucherNumber,pCardData->CardSaleAll.data.sGRVoucherNumber,sizeof(info.CardSaleInfo.cardData.sGRVoucherNumber));
				if(info.CardSaleInfo.cardData.sGRKeyCode[0] == '?')
					memcpy(info.CardSaleInfo.cardData.sGRKeyCode,pCardData->CardSaleAll.data.sGRKeyCode,sizeof(info.CardSaleInfo.cardData.sGRKeyCode));
				if(info.CardSaleInfo.cardData.sGeneralID[0] == '?')
					memcpy(info.CardSaleInfo.cardData.sGeneralID,pCardData->CardSaleAll.data.sGeneralID,sizeof(info.CardSaleInfo.cardData.sGeneralID));
				if((info.CardSaleInfo.cardData.sTranType <= '9') && (info.CardSaleInfo.cardData.sTranType >= '1'))
				{
					memcpy(info.CardSaleInfo.cardData.sTrack2Data,pCardData->CardSaleAll.data.sTrack2Data,sizeof(info.CardSaleInfo.cardData.sTrack2Data));
					info.CardSaleInfo.cardData.sTranType = pCardData->CardSaleAll.data.sTranType;
				}

				if(info.CardSaleInfo.cardData.sTranType  == '?')  //4.0.23.1150 //4.0.29.501 291147
					info.CardSaleInfo.cardData.sTranType = pCardData->CardSaleAll.data.sTranType;

				// Loyalty pass before Payment.  //4.0.3.38			
				if	(info.CardSaleInfo.cardData.sTranType ==  'X')
				{			
					info.CardSaleInfo.cardData.sTranType = pCardData->CardSaleAll.data.sTranType;
				}		

				//4.0.15.502
				if(info.CardSaleExtraData3.sPONumber[0] == '?')
					memcpy(info.CardSaleExtraData3.sPONumber,pCardData->extData3.sPONumber,sizeof(info.CardSaleExtraData3.sPONumber));


				// start husky 
				if (info.CardSaleExtraData2.sUnit[0] == '?')
					memcpy(info.CardSaleExtraData2.sUnit,pCardData->extData2.sUnit,sizeof(info.CardSaleExtraData2.sUnit));


				if( info.CardSaleExtraData2.sTripNumber[0] == '?')
					memcpy(info.CardSaleExtraData2.sTripNumber,pCardData->extData2.sTripNumber,sizeof(info.CardSaleExtraData2.sTripNumber));
				
				if (info.CardSaleExtraData2.sCustomerReference[0] == '?')
				{
					memcpy(info.CardSaleExtraData2.sCustomerReference,pCardData->extData2.sCustomerReference,sizeof(info.CardSaleExtraData2.sCustomerReference));
					memcpy(info.CardSaleExtraData4.sCustomerReferenceExt, pCardData->extData4.sCustomerReferenceExt, sizeof(info.CardSaleExtraData4.sCustomerReferenceExt)); //4.0.22.511 74797
				}

				if(info.CardSaleExtraData2.sTractorHub[0] == '?')
					memcpy(info.CardSaleExtraData2.sTractorHub,pCardData->extData2.sTractorHub,sizeof(info.CardSaleExtraData2.sTractorHub));

				if(info.CardSaleExtraData2.sTrailerNumber[0] == '?')
					memcpy(info.CardSaleExtraData2.sTrailerNumber,pCardData->extData2.sTrailerNumber,sizeof(info.CardSaleExtraData2.sTrailerNumber));

				if(info.CardSaleExtraData2.sTrailerHub[0] == '?')
					memcpy(info.CardSaleExtraData2.sTrailerHub,pCardData->extData2.sTrailerHub,sizeof(info.CardSaleExtraData2.sTrailerHub));

				if(info.CardSaleInfo.extraData.sTotalAmt[0] == '?')
				{
					memcpy(info.CardSaleInfo.extraData.sTotalAmt,pCardData->CardSaleAll.extData.sTotalAmt,sizeof(info.CardSaleInfo.extraData.sTotalAmt));
					memcpy(info.CardSaleInfo.extraData.sTotalAmt_Msb,pCardData->CardSaleAll.extData.sTotalAmt_Msb,sizeof(info.CardSaleInfo.extraData.sTotalAmt_Msb));//4.0.3.34
				}
				
				if (( info.CardSaleExtraData2.sDeclinedLoyaltyPrompt >= '1') && ( info.CardSaleExtraData2.sDeclinedLoyaltyPrompt <= '3'))
				{
					info.CardSaleExtraData2.sDeclinedLoyaltyPrompt = pCardData->extData2.sDeclinedLoyaltyPrompt;
					info.CardSaleExtraData2.sDeclinedLoyaltyResponse = pCardData->extData2.sDeclinedLoyaltyResponse;
				}

				if ( info.CardSaleExtraData2.sPassCode[0] == '?')
				{				
					memcpy(info.CardSaleExtraData2.sPassCode,pCardData->extData2.sPassCode,sizeof(info.CardSaleExtraData2.sPassCode));
				}

				//3.1.1.1
				if ( pCardData->extData2.sPinPadAction != ' ')
				{
					memcpy(info.CardSaleExtraData2.sCalculatedMAC ,pCardData->extData2.sCalculatedMAC ,sizeof(info.CardSaleExtraData2.sCalculatedMAC));
					memcpy(&(info.CardSaleExtraData2.sPinPadResult) ,&(pCardData->extData2.sPinPadResult) ,sizeof(info.CardSaleExtraData2.sPinPadResult));
				}
				
				memcpy(&(info.CardSaleExtraData2.sAccountType),&(pCardData->extData2.sAccountType),sizeof(info.CardSaleExtraData2.sAccountType));

				memcpy(info.CardSaleInfo.cardData.sClubCardTrack2Data,pCardData->CardSaleAll.data.sClubCardTrack2Data,sizeof(info.CardSaleInfo.cardData.sClubCardTrack2Data));				//3.1.1.73
				
				memcpy(info.CardSaleInfo.extraData.sLoyalId, pCardData->CardSaleAll.extData.sLoyalId,sizeof(info.CardSaleInfo.extraData.sLoyalId));	//3.2.0.21
				
				memcpy(info.CardSaleInfo.cardData.sReserved ,  pCardData->CardSaleAll.data.sReserved, sizeof(info.CardSaleInfo.cardData.sReserved));				//4.0.0.80
				info.CardSaleInfo.cardData.sEntryMethod =  pCardData->CardSaleAll.data.sEntryMethod;
								
				memcpy(info.CardSaleExtraData2.sBarCode,  pCardData->extData2.sBarCode, sizeof(info.CardSaleExtraData2.sBarCode));//4.0.2.231
								
				memcpy(info.CardSaleExtraData2.sChargeTo,  pCardData->extData2.sChargeTo, sizeof(info.CardSaleExtraData2.sChargeTo));//4.0.2.231
				
				info.CardSaleInfo.extraData.sRedeemPoints = pCardData->CardSaleAll.extData.sRedeemPoints;//4.0.2.231
							
				if(info.CardSaleInfo.cardData.sClubCardTrack2Data[0] == '?')//4.0.5.26
					memcpy(info.CardSaleInfo.cardData.sClubCardTrack2Data,pCardData->CardSaleAll.data.sClubCardTrack2Data,sizeof(info.CardSaleInfo.cardData.sClubCardTrack2Data));

				if(info.CardSaleExtraData3.sParamResult[0] == '?')   //4.0.5.41
				{
					memcpy(info.CardSaleExtraData3.sParamResult,pCardData->extData3.sParamResult,sizeof(info.CardSaleExtraData3.sParamResult));
					memcpy(info.CardSaleExtraData5.sParamResultExt,pCardData->extData5.sParamResultExt,sizeof(info.CardSaleExtraData5.sParamResultExt)); //4.0.28.502 255727

					memset(info.CardSaleInfo.cardData.sResultMsg,' ',sizeof(info.CardSaleInfo.cardData.sResultMsg));  //4.0.23.1161
					
					 //4.0.23.1203
					memset(info.CardSaleExtraData3.sPromptType,' ',sizeof(info.CardSaleExtraData3.sPromptType));   //4.0.23.1203
					memset(info.CardSaleExtraData3.sPromptMinLen,' ',sizeof(info.CardSaleExtraData3.sPromptMinLen));
					memset(info.CardSaleExtraData3.sPromptMaxLen,' ',sizeof(info.CardSaleExtraData3.sPromptMaxLen));
					memset(info.CardSaleExtraData3.sParamIndex,' ',sizeof(info.CardSaleExtraData3.sParamIndex));				
					memset(info.CardSaleExtraData2.sMessageTimeOut,' ',sizeof(info.CardSaleExtraData2.sMessageTimeOut));
					info.CardSaleExtraData2.sDisplayOLAResultMessage = ' '; 
										
					//4.0.23.1203
				}
				
				if(info.CardSaleExtraData3.sRemoteID[0] == '?')   //4.0.5.41
					memcpy(info.CardSaleExtraData3.sRemoteID,pCardData->extData3.sRemoteID,sizeof(info.CardSaleExtraData3.sRemoteID));

				if(info.CardSaleExtraData3.sLogicShiftNumber[0] == '?')   //4.0.5.42
					memcpy(info.CardSaleExtraData3.sLogicShiftNumber,pCardData->extData3.sLogicShiftNumber,sizeof(info.CardSaleExtraData3.sLogicShiftNumber));

				if(info.CardSaleInfo.cardData.sAuthNumber[0] == '?')   //4.0.6.502
					memcpy(info.CardSaleInfo.cardData.sAuthNumber,pCardData->CardSaleAll.data.sAuthNumber,sizeof(info.CardSaleInfo.cardData.sAuthNumber));
				
				if(info.CardSaleExtraData2.sZipCode[0] == '?')   //4.0.7.502
					memcpy(info.CardSaleExtraData2.sZipCode,pCardData->extData2.sZipCode,sizeof(info.CardSaleExtraData2.sZipCode));			

				if(info.CardSaleExtraData4.sExtendedZipCode[0] == '?')   				//46512
					memcpy(info.CardSaleExtraData4.sExtendedZipCode,pCardData->extData4.sExtendedZipCode,sizeof(info.CardSaleExtraData4.sExtendedZipCode));			

				// 4.0.12.515
				memcpy(info.CardSaleExtraData3.sCVMResult , pCardData->extData3.sCVMResult, sizeof(info.CardSaleExtraData3.sCVMResult));
				info.CardSaleExtraData3.sCombinedCardSelect = pCardData->extData3.sCombinedCardSelect;
				memcpy(info.CardSaleExtraData3.sTermResponseCode , pCardData->extData3.sTermResponseCode, sizeof(info.CardSaleExtraData3.sTermResponseCode));
				// end husky
			}
		}
		break;

		case SWIPE_VIT_CONFLICT: //3.0.0.8
		{			
			memset(&info.CardSaleInfo.extraData,' ',sizeof(CARD_SALE_EXTRA_DATA) );	
			info.CardSaleInfo.lIndexNumber	= 0; // will be set to Index number at the PAPReadyTrs
						
			memcpy(&info.CardSaleInfo.cardData	 ,pCardData , sizeof(CARD_SALE_ALL3));
			
			info.CardSaleInfo.cardData.sTranStatus = CD_VIT_CONFLICT;
		}
		break;

		case SWIPE_CANCEL:				
		case SWIPE_RECEIPT_UPDATE:
		case SWIPE_FORCE:
				
		break;
	}

	memcpy(info.CardSaleInfo.cardData.sMID , "001", 3);
	l2a(lPumpNumber,info.CardSaleInfo.cardData.sPumpNumber,sizeof(info.CardSaleInfo.cardData.sPumpNumber));
	l2a(lSeqNumber,info.CardSaleInfo.cardData.sTranNbr,sizeof(info.CardSaleInfo.cardData.sTranNbr));
	
	m_cPumpArray[lPumpNumber-1].SetPAPInfo(&info);
			
	long lRtc = 0;			//4.0.19.502 39254 

	SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);

	
	return lRtc;
}

void CServerMain::SendSwipeResult(long lPumpNumber, long lAnswer)
{
	PAY_AT_PUMP_INFO savedInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&savedInfo);

	CMD_STRUCT_PAP_SWIPE_RESULT3_EX cmdInfo;     //4.0.5.0
	cmdInfo.lDeviceNumber = 0; // not supprted (OPT)
	cmdInfo.lSeqNumber = a2l(savedInfo.CardSaleInfo.cardData.sTranNbr,sizeof(savedInfo.CardSaleInfo.cardData.sTranNbr));	
	cmdInfo.lAnswer =  lAnswer; // CD_OK;	

	//4.0.27.45 - remove the use of xml:
	cmdInfo.data     = savedInfo.CardSaleInfo.cardData;
	cmdInfo.extData  = savedInfo.CardSaleInfo.extraData;
	cmdInfo.extData2 = savedInfo.CardSaleExtraData2;
	cmdInfo.extData3 = savedInfo.CardSaleExtraData3;;	
	cmdInfo.extData4 = savedInfo.CardSaleExtraData4;	
	cmdInfo.extData5 = savedInfo.CardSaleExtraData5;
	cmdInfo.extData6 = savedInfo.CardSaleExtraData6;

	if (GetOLAFlags(savedInfo.CardSaleExtraData2.sFlags ,FL_PAP_AS_THIRD_REC) ||
		(GetOLAFlags(savedInfo.CardSaleExtraData3.sFlags1 ,FL_CANCEL_REC,sizeof(savedInfo.CardSaleExtraData3.sFlags1)))) //TD 40180 - Ella 4.0.16.503
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA3;   //3.0.0.0 STRUCT_IS_CARD_SALE_DATA;	
	else
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA2;   //3.0.0.0 STRUCT_IS_CARD_SALE_DATA;

	SetCommand(CMD_SWIPE_RESULT, 
		SERVER_POS_NUMBER, 
		lPumpNumber,
		&cmdInfo,
		sizeof(CMD_STRUCT_PAP_SWIPE_RESULT3_EX));

}

//4.0.14.500	//4.0.18.501
void CServerMain::SendSwipeResult(long lPumpNumber, long lAnswer,unsigned char	sTranStatus, CARD_SALE_ALL3* pData)
{
#if _ENCOR_DEBUG
	CString sMsg;
	sMsg.Format(_T("%s:%d Set - lAnswer = %d"), __FUNCTION__, __LINE__, lAnswer);
	_LOGMSG.LogMsg(sMsg);
#endif

	CMD_STRUCT_PAP_SWIPE_RESULT3_EX cmdInfo; 
	cmdInfo.lDeviceNumber = 0; // not supprted (OPT)
	cmdInfo.lSeqNumber = a2l(pData->CardSaleAll.data.sTranNbr,sizeof(pData->CardSaleAll.data.sTranNbr));	
	cmdInfo.lAnswer =  lAnswer; // CD_OK;

			
	//4.0.27.45 - remove the use of xml:
	cmdInfo.data     = pData->CardSaleAll.data;
	cmdInfo.extData  = pData->CardSaleAll.extData;
	cmdInfo.extData2 = pData->extData2;
	cmdInfo.extData3 = pData->extData3;	
	cmdInfo.extData4 = pData->extData4;	
	cmdInfo.extData5 = pData->extData5;
	cmdInfo.extData6 = pData->extData6;

	char sFlagsVal[MAX_FIELD_VAL]; 
	memset(sFlagsVal,0,sizeof(sFlagsVal));
	memcpy(&sFlagsVal, pData->extData2.sFlags, sizeof(pData->extData2.sFlags));

	//Start Ella TD 40180 - 4.0.16.503
	char sFlags1Val[MAX_FIELD_VAL]; 
	memset(sFlags1Val,0,sizeof(sFlags1Val));
	memcpy(&sFlags1Val, pData->extData3.sFlags1, sizeof(pData->extData3.sFlags1));
	//End 

	if (GetOLAFlags((BYTE*)sFlagsVal,FL_PAP_AS_THIRD_REC) || GetOLAFlags((BYTE*)sFlags1Val,FL_CANCEL_REC,sizeof(sFlags1Val)))//Ella TD 40180 - 4.0.16.503 //4.0.23.508
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA3;   //3.0.0.0 STRUCT_IS_CARD_SALE_DATA;
	else
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA2;   //3.0.0.0 STRUCT_IS_CARD_SALE_DATA;

	SetCommand(CMD_SWIPE_RESULT, 
		SERVER_POS_NUMBER, 
		lPumpNumber,
		&cmdInfo,
		sizeof(CMD_STRUCT_PAP_SWIPE_RESULT3_EX));
}


//4.0.14.500
void CServerMain::SendSwipeResult(short byOlaStat, long lPumpNumber, long lAnswer,unsigned char	sTranStatus, CARD_SALE_ALL3* pData)
{
	long lFinalAnswer = lAnswer;
	//Check if the trs was sale if so we send CD_OK
	long lFlag= a2l(pData->extData3.sFlags1,sizeof(pData->extData3.sFlags1));//4.0.12.501

	if( (SESSION_TYPE(byOlaStat) == SESSION_RECEIPT_AUTH)	||
		(SESSION_TYPE(byOlaStat) == SESSION_GENERATE_REPORT)||
		(SESSION_TYPE(byOlaStat) == SESSION_GET_REPORT)		)
	{
		return;
	}
	else if (SESSION_TYPE(byOlaStat) == SESSION_GET_RECEIPT)
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_RECEIPT;
		else
			lFinalAnswer = CD_NO_RECEIPT;
	}					
	else if (SESSION_TYPE(byOlaStat) == SESSION_RECEIPT_UPDATE)
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_RECEIPT_UPDATE_OK;
		else
			lFinalAnswer = CD_RECEIPT_UPDATE_NOT_OK;

	}
	else if (((SESSION_TYPE(byOlaStat) == SESSION_SALE)  && (OLA_STATE(byOlaStat) != OLA_WAIT_FOR_MORE_INFO)) &&	//4.0.0.76
			(lFlag & FL_SALE_REC))//4.0.12.501
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_OK;
		else
			lFinalAnswer = CD_NOT_OK;

	}
	else if( ((SESSION_TYPE(byOlaStat) == SESSION_COMPLETE) && (OLA_STATE(byOlaStat) != OLA_WAIT_FOR_MORE_INFO))||
			 (SESSION_TYPE(byOlaStat) == SESSION_CANCEL)   ||
			 ((SESSION_TYPE(byOlaStat) == SESSION_SALE)  && (OLA_STATE(byOlaStat) != OLA_WAIT_FOR_MORE_INFO))  ||	//4.0.0.76
			 (SESSION_TYPE(byOlaStat) == SESSION_CAPTURE)  || //5.0.0.55			 
			 ((SESSION_TYPE(byOlaStat) == SESSION_CLOCK) && (OLA_STATE(byOlaStat) != OLA_WAIT_FOR_MORE_INFO))) //4.0.5.41			 			 
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_FORCE_OK;
		else
			lFinalAnswer = CD_FORCE_NOT_OK;
	}

	if (sTranStatus == CD_DECLINE_DSS_ERROR)	//4.0.20.501 TD 60236
	{
		pData->CardSaleAll.data.sTranStatus = CD_DECLINE_DSS_ERROR;
	}

//4.0.26.502 153441	pData->CardSaleAll.data.sTranStatus = sTranStatus;  //4.0.14.930 //4.0.22.506 75407
	
#ifdef CANCEL_IN_MIDDLE			
	if(SESSION_TYPE(byOlaStat) != SESSION_CANCEL_AUTH)
#endif
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format(">>> OLA SwipeResult: ");
			switch(lFinalAnswer)
			{
				case CD_OK:
					str+= "OK";
					break;
				case CD_NOT_OK:
					str+= "NOT_OK";
					break;
				case CD_MORE_DATA_REQUIRED:
					str+= "MORE_DATA_REQUIRED";
					break;
				case CD_RECEIPT:
					str+= "RECEIPT";
					break;
				case CD_NO_RECEIPT:
					str+= "NO_RECEIPT";
					break;
				case CD_FORCE_OK:
					str+= "FORCE_OK";
					break;
				case CD_FORCE_NOT_OK:
					str+= "FORCE_NOT_OK";
					break;
				case CD_RECEIPT_UPDATE_OK:
					str+= "RECEIPT_UPDATE_OK";
					break;
				case CD_RECEIPT_UPDATE_NOT_OK:
					str+= "RECEIPT_UPDATE_NOT_OK";
					break;


			}
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
		}	
	}
	
	
	if((SESSION_TYPE(byOlaStat) == SESSION_AUTHORIZE) || (SESSION_TYPE(byOlaStat) == SESSION_CANCEL_AUTH))
	{
		if(OLALogDeclineReq())
		{
			//We need to log declined card only if they were decline, and not if the
			//user canceled the transaction (unless it was already approved)
			
			//Make sure the transaction wasn't cancelled while we were waiting for the customer to entry more data.
			//and that the card wasn't approved yet (in case of Gas Reward)
			if ((OLA_STATE(byOlaStat) != OLA_WAIT_FOR_MORE_INFO) && (sTranStatus != CD_READY))
			{
				//Check that the transaction was cancelled
				if((lAnswer == CD_NOT_OK)&&(sTranStatus != CD_DECLINE_GR ) && (sTranStatus != CD_FORCE_COMPLETION_ZERO)) //3.2.0.64
				{	
					//4.0.18.501
					LogDeclinedCard(lPumpNumber,(CARD_SALE_ALL3 *)&pData->CardSaleAll.data);
				}
			}
		}
	}

	// if pumpsrv is master - then ther should be a WAIT_PROGRESS transaction 
	// and the sequence number is the transaction number.


#ifdef CANCEL_IN_MIDDLE			
	if(SESSION_TYPE(byOlaStat) != SESSION_CANCEL_AUTH)
#endif
	{

		//4.0.5.0
		SendSwipeResult(lPumpNumber, lFinalAnswer,sTranStatus, pData);

	}
}

long CServerMain::LogDeclinedCard(long lPumpNumber,CARD_SALE_ALL3 *pData)
{
	PAY_AT_PUMP_INFO info;
	CPumpTransact	trs(lPumpNumber);						
	trs.m_lActiveShiftNumber = GetActiveShiftNumber();
	
	memcpy(&info.CardSaleInfo.cardData ,&pData->CardSaleAll.data , sizeof(CARD_SALE_ALL3));
	memset(&info.CardSaleInfo.extraData,' ',sizeof(info.CardSaleInfo.extraData));

	
	//	1. Change Trs Link number into new OLA Index number .
	//4.0.18.501
	info.CardSaleInfo.lIndexNumber = NewOLAIndex();				
	trs.SetLink(TRS_LINK_OLA_NUMBER, info.CardSaleInfo.lIndexNumber);		
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format(">>> Declined OLA Request, OLA Index %ld ", info.CardSaleInfo.lIndexNumber);
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}						

	m_cProtectedDataHandler.GenerateIndex(&info, TRUE, lPumpNumber);		//4.0.22.501	TD 72716	

	//	2. insert to OLA file								
	//4.0.18.501
	long lRtc = TrsLinkOperationEx(REC_INSERT,&trs, &info);  							
	long lRtc1 = OK;
	// insert info to receipt file
	if (lRtc == OK)
	{
		CReceiptInfo ReceiptInfo;
		RECEIPT_REC_EX_DATA cExData;
		memset(&cExData,0,sizeof(cExData));

		
		_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(&trs, &info, ReceiptInfo);//4.0.9.503
		long lRtc1 = CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

		//Add by Yaron Ctrl Events
		if (lRtc1 == OK)
		{
			m_cEventManager.AddEvent(CTRL_EVENT_PAP_TRS,0);
		}
	}

	if(lRtc)
	{
		if(LOG_LOGIC_ERROR)
		{
			CString str;
			str.Format("Declined OLA: Insert Operation to OLAFile Failed !!! SeqNumber %d, lRtc %d",info.CardSaleInfo.cardData.sTranNbr, lRtc ); 
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str,LOG_LEVEL_1);
		}
	}

	return lRtc;
}



void CServerMain::SendReceipt(	short byOlaStat,
								long lPumpNumber, 
								long lAnswer,
								unsigned char sTranStatus, 
								CARD_SALE_ALL3  *pData,
								CPumpTransact *pTrs)
{
	long lFinalAnswer = lAnswer;

	if ((SESSION_TYPE(byOlaStat) == SESSION_RECEIPT_AUTH) ||
		(SESSION_TYPE(byOlaStat) == SESSION_GET_RECEIPT) )
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_RECEIPT;
		else
			lFinalAnswer = CD_NO_RECEIPT;
	}					
	else if (SESSION_TYPE(byOlaStat) == SESSION_RECEIPT_UPDATE)
	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_RECEIPT_UPDATE_OK;
		else
			lFinalAnswer = CD_RECEIPT_UPDATE_NOT_OK;

	}
	else if( (SESSION_TYPE(byOlaStat) == SESSION_COMPLETE) ||
			 (SESSION_TYPE(byOlaStat) == SESSION_CANCEL)   ||
			 (SESSION_TYPE(byOlaStat) == SESSION_SALE)     ||  //) //3.0.1.61
 			 (SESSION_TYPE(byOlaStat) == SESSION_CAPTURE)  || //5.0.0.55
			 (SESSION_TYPE(byOlaStat) == SESSION_CLOCK) ) //5.0.0.55

	{
		if(lAnswer == CD_OK)
			lFinalAnswer = CD_FORCE_OK;
		else
			lFinalAnswer = CD_FORCE_NOT_OK;
	}


	pData->CardSaleAll.data.sTranStatus = sTranStatus;
	

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("OLA Send Receipt: ");
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}	
	
	CMD_STRUCT_PAP_SWIPE_RECEIPT3_EX cmdInfo;
	
	memset(&cmdInfo , ' ', sizeof(CMD_STRUCT_PAP_SWIPE_RECEIPT3_EX));  
	cmdInfo.lDeviceNumber = 0; // not supprted (OPT)
	cmdInfo.lSeqNumber = a2l(pData->CardSaleAll.data.sTranNbr,sizeof(pData->CardSaleAll.data.sTranNbr));
	cmdInfo.lAnswer = lFinalAnswer;

	pTrs->GetTag(&cmdInfo.trs,2);	

	//4.0.27.45 - remove the use of xml:
	cmdInfo.data     = pData->CardSaleAll.data;
	cmdInfo.extData  = pData->CardSaleAll.extData;
	cmdInfo.extData2 = pData->extData2;
	cmdInfo.extData3 = pData->extData3;	
	cmdInfo.extData4 = pData->extData4;	
	cmdInfo.extData5 = pData->extData5;	
	cmdInfo.extData6 = pData->extData6;	

	if (GetOLAFlags(pData->extData2.sFlags ,FL_PAP_AS_THIRD_REC))
		cmdInfo.lFlags	= STRUCT_IS_RECEIPT_DATA3;
	else
		cmdInfo.lFlags	= STRUCT_IS_RECEIPT_DATA;

	SetCommand(CMD_SWIPE_RECEIPT, 
			SERVER_POS_NUMBER, 
			lPumpNumber,
			&cmdInfo,
			sizeof(CMD_STRUCT_PAP_SWIPE_RECEIPT3_EX));

}


BOOL CServerMain::ModeSchemeProcess__()
{

	BOOL bRet;
	__try
	{
		bRet = ModeSchemeProcess();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::ModeSchemeProcess")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::ModeSchemeProcess()", LOG_LEVEL_0);	

		exit(1);
	}   
	
	return bRet;
}


// Return 
// TRUE	- if in middle of process
// FALSE	- not in middle of operation
BOOL CServerMain::ModeSchemeProcess()
{
	BOOL	bRetCode = FALSE;
	CString sModeTable;
	CString sStr;

	if(m_cServerInfo.GetRequiredModeProcessFlags())
	{
		m_cServerInfo.SetRequiredModeProcessFlags(FALSE);
		long p = 1;
		for(p ; p <= m_lLastValidPump; p++)
		{
			DWORD dwManualModaValue = 0;
			BOOL  bInManualMode = FALSE;

			long lIndexChange = 0;
			long lIndex = 0;
			long lNewMode = 0;
			long lNewServiceMode = 0;
			long lCurrServiceMode = 0;

			//4.0.9.800
			long lNewPriceLevelManual = 0;
			long lCurrPriceLevelManual = m_cPumpArray[p-1].GetPriceLevel();

			dwManualModaValue = m_lPumpsManualModeArray[p-1];
			
			if ( dwManualModaValue )
				bInManualMode = TRUE; //we are in manual mode 
			
			lIndex = GenerateModeSchemeIndex(p , 1); 	
			
			lIndexChange = lIndex;
			
			lNewMode = m_cModeSchemeArray[lIndex].GetMode();


			if ((m_dwSysOnManualModes) && dwManualModaValue)
			{			
				DWORD dwTmp;
				
				sModeTable.Format("Modes\\Mode%02ld",dwManualModaValue);

				m_cParam.LoadParam((LPCSTR)sModeTable, "ModeService",&dwTmp,(DWORD)0,TRUE); 
				lNewServiceMode = dwTmp;

				m_cParam.LoadParam((LPCSTR)sModeTable, "PriceLevel",&dwTmp,(DWORD)0,TRUE); 
				lNewPriceLevelManual = dwTmp;

				m_cPumpArray[p-1].SetPriceLevel(lNewPriceLevelManual);
				m_cPumpArray[p-1].SetModeService(lNewServiceMode);//amram 4.0.10.505

			}
			
		
			lNewMode = m_cModeSchemeArray[lIndex].GetMode();
				
			for(long s=2; s <= MAX_MODE_SCHEME; s++)    
			{ 
				SYSTEMTIME sysTime;
				GetLocalTime(&sysTime);
					
				lIndex = GenerateModeSchemeIndex(p , s); 
				
				if(m_cModeSchemeArray[lIndex].Active(sysTime))
				{  
					lNewMode = m_cModeSchemeArray[lIndex].GetMode();     
					lIndexChange = lIndex;
				}
			}

			//setting the new mode to the one that was set manualy
			if(dwManualModaValue)
			{
				lNewMode =  dwManualModaValue;
				bInManualMode = FALSE;
			}
				
			lCurrServiceMode = m_cPumpArray[p-1].GetModeSchemeServiceMode();				//4.0.6.501

			if (!(m_dwSysOnManualModes && dwManualModaValue))  //4.0.9.509
			{
				lNewServiceMode = m_cModeSchemeArray[lIndexChange].GetPumpServiceMode();
			
				//4.0.6.508
				// if service mode is not define used the Full service as default.
				if (!lNewServiceMode) 
				{
					CString sLogMsg , str , sTable("Pumps\\Pump");
					char sNumber[8];
					DWORD dwTmp = lNewServiceMode;
					
					memset(sNumber,0,sizeof(sNumber));
						
					sprintf_s(sNumber, _countof(sNumber),"%02d",p);
					str = sTable + sNumber;
					m_cParam.LoadParam((LPCSTR)str, "ServiceMode",&dwTmp,dwTmp, FALSE);
						
					/*There is a different between the value of self service
					in the pump level then in the schememode. In the Pump
					level the self is 0 and in the scheme self is 2.*/
					if(dwTmp == SELF_SERVICE_MODE)
						lNewServiceMode = MODE_SHCEME_SELF_SERVICE;
					else if(dwTmp == FULL_SERVICE_MODE)
						lNewServiceMode = MODE_SHCEME_FULL_SERVICE;  
				}
			}

			//4.0.6.501				
			m_cPumpArray[p-1].SetCurentServiceFee(m_cModeSchemeArray[lIndexChange].GetServiceFeeSet());
			m_cPumpArray[p-1].SetModeSchemeServiceMode(lNewServiceMode);

			if ((!PumpNotInWorkingState(p)) ||  
				(m_cPumpArray[p-1].GetStat().GetStatus() == COMMS_TERMINATED)) //4.0.15.500
			{	
				if(lNewMode != m_cPumpArray[p-1].GetStat().GetMode() || (lCurrServiceMode != lNewServiceMode )||  //4.0.9.509
						(lCurrPriceLevelManual != lNewPriceLevelManual))
				{
					//check if pump valid
					if(!IsPumpReadyForModeChange(p-1))//4.0.9.506 //amram
					{
						m_cLogger.LogMsg(p,LOG_PUMP,"ModeSchemeProcess:New Mode can't change because the pump not valid ");
					}
					else
					{
										
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;

							if(!m_dwSysOnManualModes)
								str.Format("New Mode %d, (current mode %d), New ServiceMode %d, (current ServiceMode %d)",lNewMode,m_cPumpArray[p - 1].GetStat().GetMode(),lNewMode,lCurrServiceMode);
							else
								str.Format("New Mode %d, (current mode %d),  New ServiceMode %d, (current ServiceMode %d) New PriceLevel %d, (current PriceLevel %d)",lNewMode,m_cPumpArray[p - 1].GetStat().GetMode(),lNewServiceMode,lCurrServiceMode,lNewPriceLevelManual,lCurrPriceLevelManual);	

							m_cLogger.LogMsg(p,LOG_PUMP,str);
						}
						
						//4.0.3.49 - only if reached to conclusion that need to change mode
						if(m_cModeArray[lNewMode-1].IsNeedToLockPump())
						{
							m_cLogger.LogMsg(p,LOG_PUMP,"ModeSchemeProcess:New Mode has no valid Trs types");
							StartLockPumpByMode(p);
						}
						else
						{
							StartUnLockPumpByMode(p);
						}

						
						// If Pump service mode  define in mode scheme, send the service mode in new method
						if (m_cPumpArray[p-1].GetModeSchemeServiceMode() || PUMPSRV_IS_MODE_MASTER2)
						{
							CString sTable;
							char sKey1[8];
							DWORD dwServiceMode = 0;

							sTable = "Pumps\\Pump";
							memset(sKey1,0,sizeof(sKey1));
							sprintf_s(sKey1, _countof(sKey1),"%02d",p);
							sTable += sKey1;
							
							if(m_dwSysOnManualModes)
							{	
								CMD_STRUCT_MODE3 cmdInfo;
								cmdInfo.lMode = lNewMode;
								cmdInfo.lPriceLevel = lNewPriceLevelManual;
								cmdInfo.lServiceMode = lNewServiceMode;
								cmdInfo.lServiceFee = m_cPumpArray[p-1].GetCurrentServiceFee();
								cmdInfo.lFlags = m_cModeArray[lNewMode-1].GetFlags(); //4.0.14.500

								//4.0.20.504 - TD 65134
								if (p == m_lLastValidPump)
								{
									cmdInfo.lFlags |= MODE_DEF_END_OF_LIST;
									if(LOG_BASIC_FLOW_CONTROL)
									{
										m_cLogger.LogMsg(p,LOG_PUMP,"Send MODE_DEF_END_OF_LIST flag to CL on the last valid pump");
									}
								}
							
								SetCommand(CMD_SET_PUMP_MODE3, SERVER_POS_NUMBER, p,&cmdInfo,sizeof(CMD_STRUCT_MODE3));	

								//4.0.24.70 - TD 106064
								if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse()) // CR 444830
								m_cGPIEventMgr.AddSetPumpMode(p,lNewMode,lNewServiceMode,cmdInfo.lServiceFee,lNewPriceLevelManual,0);

								dwServiceMode	= (cmdInfo.lServiceMode == MODE_SHCEME_FULL_SERVICE) ? FULL_SERVICE_MODE :SELF_SERVICE_MODE;	
							
								m_cParam.SaveParam((char *)((LPCTSTR)sTable) ,"ServiceMode" ,dwServiceMode);
								m_cParam.SaveParam((char *)((LPCTSTR)sTable) ,"PriceLevelDefault" ,lNewPriceLevelManual);//TD 16857 4.0.10.53	
								m_cPumpArray[p-1].SetPriceLevelDefault(lNewPriceLevelManual);//4.0.11.509

							}
							else
							{
								CMD_STRUCT_MODE2 cmdInfo;
								cmdInfo.lMode = lNewMode;
								cmdInfo.lServiceMode = m_cPumpArray[p-1].GetModeSchemeServiceMode();
								cmdInfo.lServiceFee = m_cPumpArray[p-1].GetCurrentServiceFee();
								cmdInfo.lFlags = m_cModeArray[lNewMode-1].GetFlags(); //4.0.14.500

								//4.0.20.504 - TD 65134
								if (p == m_lLastValidPump)
								{
									cmdInfo.lFlags |= MODE_DEF_END_OF_LIST;
									if(LOG_BASIC_FLOW_CONTROL)
									{
										m_cLogger.LogMsg(p,LOG_PUMP,"Send MODE_DEF_END_OF_LIST flag to CL on the last valid pump");
									}
									
									m_bWasModeUpdated = TRUE; //4.0.25.41 - TD 122535
								}
								
								SetCommand(CMD_SET_PUMP_MODE2, SERVER_POS_NUMBER, p,&cmdInfo,sizeof(CMD_STRUCT_MODE2));	

								//4.0.24.70 - TD 106064
								if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse())// CR 444830
								{
									long lPriceLevel = m_cPumpArray[p-1].GetPriceLevel();
									m_cGPIEventMgr.AddSetPumpMode(p,lNewMode,cmdInfo.lServiceMode,cmdInfo.lServiceFee, lPriceLevel, 0);
								}

								dwServiceMode	= (cmdInfo.lServiceMode == MODE_SHCEME_FULL_SERVICE) ? FULL_SERVICE_MODE :SELF_SERVICE_MODE;	
								
								m_cParam.SaveParam((char *)((LPCTSTR)sTable) ,"ServiceMode" ,dwServiceMode);
							}		

							CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);
						
							CPumpStatus stat = m_cPumpArray[p - 1].GetStat();	
							stat.SetServiceMode((long)dwServiceMode);
							m_cPumpArray[p -1].SetStat(stat);
						}
						else
						{
							CMD_STRUCT_MODE cmdInfo;
							cmdInfo.lMode = lNewMode;
							SetCommand(CMD_SET_PUMP_MODE, SERVER_POS_NUMBER, p,&cmdInfo,sizeof(CMD_STRUCT_MODE));						
						}
					}
				}				
			}
		}

 		if((m_bControllerManagePumpMode2 && !m_bWasModeUpdated))
		{
			BOOL	bPumpValid = TRUE;;
			//check if pumps ready
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

			while(p < GetLastValidPump())  
			{
				bPumpValid = IsPumpReadyForModeChange(p);
				if(!bPumpValid)
				{
					m_cLogger.LogMsg(p,LOG_PUMP,"ModeSchemeProcess:New Mode can't change because the pump not valid ");
					break;
				}
				p++;
			}
			if(bPumpValid)
			{				
				if(!m_dwSysOnManualModes)			//4.0.9.800
					SendPumpMode2Events();
				else
					SendPumpMode3Events();

				m_bWasModeUpdated = TRUE;
			}
		}
	}	
	return bRetCode;		
}

BOOL CServerMain::ShiftChangeProcess__()
{
	BOOL bRet;

	__try
	{
		bRet = ShiftChangeProcess();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::ShiftChangeProcess")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::ShiftChangeProcess()", LOG_LEVEL_0);	

		exit(1);
	}   

	return bRet;
}


// Return 
//		TRUE	- if in middle of shift process
//		FALSE	- not in middle of any shift operation
BOOL CServerMain::ShiftChangeProcess()
{
	BOOL bRetCode = FALSE; 

	if(m_cServerInfo.GetRequiredShiftProcessFlags())
	{
		bRetCode = TRUE;

		switch(m_cServerInfo.GetServerStatus())
		{
			case UNLOCK:
			//-----------------------------------------------------------------------------------
			{
				HandleShiftStateUnlock(); //4.0.29.0 - TD 241916
			}
			break;

			case STARTED:
			case WAIT_LOCK:
			//-----------------------------------------------------------------------------------
			{
				HandleShiftStateStarted(); //4.0.29.0 - TD 241916
			}
			break;

			case LOCKED:
			//-----------------------------------------------------------------------------------
			{
				HandleShiftStateLocked(); //4.0.29.0 - TD 241916
			}
			break;

			case WAIT_RESPONSE:
			//-----------------------------------------------------------------------------------
			{
				HandleShiftStateWaitResponse(); //4.0.29.0 - TD 241916
			}
			break;

			case RESPONSE_RECEIVED: // changed by GCI:TankReading or (if not requested) by fnishing pump totals 
			//-----------------------------------------------------------------------------------
			{
				HandleShiftStateResponseReceived(); //4.0.29.0 - TD 241916
			}
			break;
		}
	}	


	return bRetCode;
}



BOOL CServerMain::PriceChangeProcess__()
{
	BOOL bRet; 
	__try 
	{
		bRet = PriceChangeProcess();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::PriceChangeProcess")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::PriceChangeProcess()", LOG_LEVEL_0);	

		exit(1);
	}   

	return bRet;
}


// Return 
//		TRUE	- if in middle of price change process
//		FALSE	- not in middle of price change operation
BOOL CServerMain::PriceChangeProcess()
{
	BOOL bRetCode = FALSE; 

	if(m_cServerInfo.GetRequiredPriceChangeFlags())
	{
		bRetCode = TRUE;

		switch(m_cServerInfo.GetServerStatus())
		{
		case UNLOCK:
			//-----------------------------------------------------------------------------------
			{
				HandlePriceChangeUnlock();
			}
			break;

		case STARTED:
		case WAIT_LOCK:
			//-----------------------------------------------------------------------------------
			{
				HandlePriceChangeWaitLock();
			}
			break;

		case LOCKED:
			//-----------------------------------------------------------------------------------
			{
 // CR_475695_Start
				if (TRUE == m_cPriceChangeFlags.IsRequiredTotals())		
				{
					BOOL bTankTotalsReadingDone = FALSE;
					BOOL bPumpTotalsReadingDone = FALSE;
					bPumpTotalsReadingDone = PriceChangeReadPumpTotals();
					
					if(TRUE == bPumpTotalsReadingDone)
					{
						
						bTankTotalsReadingDone = PriceChangeTankReadTotals();
					}
					
					if(bTankTotalsReadingDone)
					{
						SendGradePrice(0);
						SetServerLockStatus(RESPONSE_RECEIVED);
					}
				}
				else // with out Totals
				{
						HandlePriceChangeLocked();
				}
				//CR_475695_End
			}
			break;

		case WAIT_RESPONSE:
			//-----------------------------------------------------------------------------------
			{
				SetServerLockStatus(WAIT_LOCK);	
			}
			break;

		case RESPONSE_RECEIVED: 
			//-----------------------------------------------------------------------------------
			{
				//CR_475695_Start
				m_cPriceChangeFlags.SetPriceChangeTanksReadState(PChange_Tanks_NO_TOTALS_REQUEST);
				m_cPriceChangeFlags.SetPriceChangelPumpTotalsRequestState(PChange_NO_TOTALS_REQUEST);
				//CR_475695_End
				HandlePriceChangeResponseReceived();
			}
			break;
		}
	}	

	return bRetCode;
}




// return 
// 0 - in progress
// 1 - done 
// 2 - cant start  
int CServerMain::DoAutomaticReadTotal(long lPumpNumber, BOOL bLock)
{
	long p = lPumpNumber - 1 , lMisc = 0 , lAlarmRetCode = 0;
	int  iOperationDone = 0; // in progress

	if((LOG_DETAIL_FLOW_CONTROL ) & 0) //4.0.3.1
	{	
		CString str;
		str.Format("DoAutomaticReadTotal: bLock=%d " ,bLock);
		m_cLogger.LogMsg(p+1,LOG_PUMP,str);
	}


	//4.0.7.505
	PumpStatus pumpStat = m_cPumpArray[p].GetStat().GetStatus();
	
	if(pumpStat == UNKNOWN_STATUS || pumpStat == COMMS_TERMINATED)
		iOperationDone = 1;
	else
	{
		switch(m_cPumpArray[p].GetLockStatus())
		{
			case UNLOCK:
			case STARTED:
				m_cPumpArray[p].m_lWaitCounter = 0;//4.0.6.501
			case WAIT_LOCK:
			{
				if(bLock)
					iOperationDone = 2; // cant start..
				else
				{
					m_cPumpArray[p].SetLockStatus(LOCKED);												
					SavePumpInfo(p+1);		
					iOperationDone = 0; // in progress
					
				}
			}
			break;		

			case LOCKED:
			{	
				SetCommand(CMD_GET_PUMP_TOTALS, SERVER_POS_NUMBER, p+1);
				m_cPumpArray[p].SetLockStatus(WAIT_RESPONSE);							
				SavePumpInfo(p+1);		

				if(LOG_BASIC_FLOW_CONTROL)
				{	
					CString str;
					str.Format("Send Command : GET_PUMP_TOTAL");
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);
				}	

				iOperationDone = 0; // in progress
			}
			break;

			case WAIT_RESPONSE:
			{
				CString str;

				m_cPumpArray[p].m_lWaitCounter++;

				if(m_cPumpArray[p].m_lWaitCounter == 1200)				//4.0.3.21
				{					
					lMisc = m_cPumpArray[p].GetStat().GetMisc();
					lMisc |= MISC_WAIT_RESPONSE_TIMEOUT;
					
					m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
					SavePumpInfo(p+1);		

					if(LOG_DETAIL_FLOW_CONTROL)
					{	
						str.Format("DoAutomaticReadTotal: Time Out on WAIT_RESPONSE , return to LOCKED");
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
				}

				//4.0.3.21 Start
				else if(m_cPumpArray[p].m_lWaitCounter == 2400)
				{
					//If wait has timed out, move on to next pump, 
					//in order to avoid the situation
					//where we enter an endless loop because of pump malfunction
					m_cPumpArray[p].SetLockStatus(RESPONSE_RECEIVED);
					m_cPumpArray[p].m_lWaitCounter = 0;

					str.Format("DoAutomaticReadTotal: timed out on WAIT_RESPONSE , moved to RESPONSE_RECEIVED");
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);

					lAlarmRetCode = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,
															SUB_PUMPSRV,
															PUMP_TOTAL_READING_FAILED,
															p + 1,
															ALARM_ON,
															p + 1,
															0);

					if(lAlarmRetCode)
					{
						str.Format("DoAutomaticReadTotal() - failed to raise alarm, AlarmSrv returned %d" , lAlarmRetCode);
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
				}
				//4.0.3.21 End

				iOperationDone = 0; // in progress
			}
			break;

			//GCI::PumpTotals() will change the status to RESPONSE_RECEIVED
			//4.0.3.21 - timeout will also change lock status to response received
			case RESPONSE_RECEIVED:
			{
				if(bLock)
				{
					if( m_cPumpArray[p].GetLockStatus() == RESPONSE_RECEIVED && m_cPumpArray[p].GetStat().GetRes() != PUMPSRV )	//Lost synchronization between CL and PS  //4.0.23.501 TD 77933
					{
						long lMisc = m_cPumpArray[p].GetStat().GetMisc();
						lMisc &= MISC_CLEAR_PROCESS_FLAGS;
						
						m_cPumpArray[p].SetLockStatus(UNLOCK, lMisc);							
						SavePumpInfo(p+1);
					}
				}
				else
				{
					BOOL bForeCourtCloseByMaintenence  = (m_cServerInfo.GetServerReservation() & MAINTENANCE)? TRUE : FALSE;  //3.0.1.84

					long lMisc = m_cPumpArray[p].GetStat().GetMisc();
					lMisc &= MISC_CLEAR_PROCESS_FLAGS;
					
					if (bForeCourtCloseByMaintenence)
					{
							m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
							SavePumpInfo(p+1);

					}else
					{
							m_cPumpArray[p].SetLockStatus(UNLOCK,lMisc);							
							SavePumpInfo(p+1);
					}

					m_cPumpArray[p].m_lWaitCounter = 0;					//4.0.3.21 
				}

				iOperationDone = 1; // done
			}
			break;
		}
	}
	return iOperationDone;
}


// return TRUE if pump locked
BOOL CServerMain::DoAutomaticPumpLock(long lPumpNumber, long lServerLockReason)
{
	long p = lPumpNumber - 1;
	BOOL	bPumpLocked = FALSE;

	PumpLockType eLockType = LOCK_TYPE_MAINT;
	//We don't want to deal with a pump which has been already locked by mode...
	if((m_cPumpsLockStateArray[p].GetPumpLockStatus() != PM_LOCKED )&& ( m_cPumpsLockStateArray[p].GetPumpLockStatus() != PM_WAIT_LOCK) )
	{
		if(lServerLockReason == EMERGENCY_LOCK)
			eLockType = LOCK_TYPE_EMERGENCY;

		if(m_cPumpArray[p].GetStat().GetStatus() == UNKNOWN_STATUS)	   
			bPumpLocked = TRUE;
		else
		{
			switch(m_cPumpArray[p].GetLockStatus())
			{
				case UNLOCK:
				{	
					long lMisc = m_cPumpArray[p].GetStat().GetMisc();
					if(lServerLockReason & SHIFT_CHANGE)
						lMisc &= MISC_CLEAR_SHIFT_CHANGE_FLAGS;
					if(lServerLockReason & PRICE_CHANGE)
						lMisc &= MISC_CLEAR_PRICE_CHANGE_FLAGS;
					if(lServerLockReason & MAINTENANCE)
						lMisc &= MISC_CLEAR_MAINTENANCE_FLAGS;
									
					m_cPumpArray[p].SetLockStatus(STARTED,lMisc);  							
					SavePumpInfo(p+1);			
				}
				break;

				case STARTED:			
				{
					short nPrePayWaiting, nFree, nUnpaid;
					m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting,&nFree,&nUnpaid);
					m_cPumpArray[p].m_lWaitCounter = 0;

					//4.0.3.27
					//Added second part of if statement in order to support
					//emergency locks (locks due to stop all button)
					if((nPrePayWaiting==0) || (lServerLockReason == EMERGENCY_LOCK))
					{
						long lMisc = m_cPumpArray[p].GetStat().GetMisc();

						//4.0.3.27  added param to CanReserveForPumpLock()
						if(m_cPumpArray[p].CanReserveForPumpLock(eLockType))  // check if can send reserve pump 
																			// check also that no trs in WAIT_TIME_OUT						
						{
							CMD_STRUCT_RESERVE_PUMP cmdInfo;
							cmdInfo.lRes	= PUMPSRV;
							cmdInfo.lResExt = m_cServerInfo.GetServerReservation();
							SetCommand(CMD_RESERVE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
							
							lMisc &= MISC_NOT_WAIT_FOR_PUMP_TO_BE_READY;
							m_cPumpArray[p].SetLockStatus(WAIT_LOCK,lMisc);	
							
							ReleasePumpMessages(p , PUMP_NO_MSG);					// 2.9.1.3

							SavePumpInfo(p+1);
						}
						else if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
								 (m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
								 (m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
								 (m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) )	
						{
							lMisc &= MISC_NOT_WAIT_FOR_PUMP_TO_BE_READY;
							m_cPumpArray[p].SetLockStatus(WAIT_LOCK,lMisc);							
							SavePumpInfo(p+1);
						}
						else
						{
							CPumpStatus	pumpStat;	// 2.9.1.3

							if(!(lMisc & MISC_WAIT_FOR_PUMP_TO_BE_READY))
							{
								lMisc |= MISC_WAIT_FOR_PUMP_TO_BE_READY;
								m_cPumpArray[p].SetLockStatus(STARTED,lMisc);							
								SavePumpInfo(p+1);					
							}

							// start 2.9.1.3
							pumpStat = m_cPumpArray[p].GetStat();
							pumpStat.SetMessage(PUMP_MSG_STOCK_PRE_PAY);
							// end 2.9.1.3

						}
					}
				}
				break;

				case WAIT_LOCK:
				{
					// check if all trs cleared up, and pump reserved for PUMPSRV
					if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
						(m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
						(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
						(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) )

					{
						short nPrePayWaiting, nFree, nUnpaid;
						m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting,&nFree,&nUnpaid);
						nPrePayWaiting = m_cPumpArray[p].GetNumberOfNonClosedPrePay();

						if(lServerLockReason & SHIFT_CHANGE) 						
						{
							if((nPrePayWaiting==0)&&(nUnpaid==0))
							{
								// Do not check ola record......   //4.0.3.39
								if (!(lServerLockReason & FORCE_SHIFT_OLA))
								{
									CPumpTransact		trs;
									PAY_AT_PUMP_INFO	info;
									trs.SetLink(TRS_LINK_OLA_NUMBER, 0);
									memset(&info,' ',sizeof(info)); //4.0.15.11
									long lRtc = TrsLinkOperation(REC_READ_FIRST,&trs,&info);
									long lMisc = m_cPumpArray[p].GetStat().GetMisc();
							
									if((lRtc == ERR_NOT_FOUND)||(lRtc == ERR_DELETED))
									{
															
										lMisc &= MISC_CLEAR_SHIFT_CHANGE_FLAGS;
										m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
										SavePumpInfo(p+1);					
									}
									else
									{
										if(!(lMisc & MISC_OPEN_PAY_AT_PUMP_TRS))
										{
											lMisc |= MISC_OPEN_PAY_AT_PUMP_TRS;	
											m_cPumpArray[p].SetLockStatus(WAIT_LOCK,lMisc);							
											SavePumpInfo(p+1);	
										}
									}
								}
								else
								{
									long lMisc = m_cPumpArray[p].GetStat().GetMisc();

									m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
									SavePumpInfo(p+1);	

									if(LOG_BASIC_FLOW_CONTROL)
									{	
										CString str;
										str.Format("skip check OLA exit record ");
										m_cLogger.LogMsg(p+1,LOG_PUMP,str);
									}

								}

							}
							else
							{	
								long lMisc = m_cPumpArray[p].GetStat().GetMisc();
								long lOrgMisc = lMisc;

								if(nPrePayWaiting)
									lMisc |= MISC_OPEN_PRE_PAY_TRS;
								else 
									lMisc &= MISC_NOT_OPEN_PRE_PAY_TRS;

								if(nUnpaid)
									lMisc |= MISC_OPEN_PAY_AT_KIOSK_TRS;
								else 
									lMisc &= MISC_NOT_OPEN_PAY_AT_KIOSK_TRS;
								
								if(lOrgMisc != lMisc)
								{
									m_cPumpArray[p].SetLockStatus(WAIT_LOCK,lMisc);							
									SavePumpInfo(p+1);			
								}
							}

						}
						else if (lServerLockReason & PRICE_CHANGE) // price change - non shift read tanks or totals.
						{
							if(nPrePayWaiting==0)
							{
								long lMisc = m_cPumpArray[p].GetStat().GetMisc();
								lMisc &= MISC_CLEAR_PRICE_CHANGE_FLAGS;
								m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
								SavePumpInfo(p+1);										
							}
							else
							{			
								long lMisc = m_cPumpArray[p].GetStat().GetMisc();
								long lOrgMisc = lMisc;

								if(nPrePayWaiting)
									lMisc |= MISC_OPEN_PRE_PAY_TRS;
								else 
									lMisc &= MISC_NOT_OPEN_PRE_PAY_TRS;
							
								if(lOrgMisc != lMisc)
								{
									m_cPumpArray[p].SetLockStatus(WAIT_LOCK,lMisc);							
									SavePumpInfo(p+1);					
								}
							}
						}
						else if ((lServerLockReason & MAINTENANCE) || 
								 (lServerLockReason & DATABASE_MAINTENANCE) ||
								 (lServerLockReason & EMERGENCY_LOCK)) // Lock the site due to B/O request.  //56064 - add EMERGENCY_LOCK	//4.0.17.330	//4.0.18.504 
						{
							long lMisc = m_cPumpArray[p].GetStat().GetMisc();
							lMisc &= MISC_CLEAR_MAINTENANCE_FLAGS;
							m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
							SavePumpInfo(p+1);										
						}
					}
					
					else
					{	m_cPumpArray[p].m_lWaitCounter++;
						if(m_cPumpArray[p].m_lWaitCounter == 1000)
						{
							long lMisc = m_cPumpArray[p].GetStat().GetMisc();
							lMisc |= MISC_WAIT_LOCK_TIMEOUT;
							
							m_cPumpArray[p].SetLockStatus(STARTED,lMisc);							
							SavePumpInfo(p+1);
							if(LOG_DETAIL_FLOW_CONTROL)
							{	
								CString str;
								str.Format("DoAutomaticPumpLock: Time Out on WAIT_LOCK , return to STARTED");
								m_cLogger.LogMsg(p+1,LOG_PUMP,str);
							}
						}
					}
				}
				break;

				case WAIT_RESPONSE:
				{
					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("(WAIT_RESPONSE) Inncorrect state for DoAutomaticPumpLock !!! switch to (WAIT_LOCKED)");
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
					m_cPumpArray[p].SetLockStatus(WAIT_LOCK);							
					SavePumpInfo(p+1);		
				}
				break;

				case RESPONSE_RECEIVED:
				{
					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("(RESPONSE_RECEIVED) Inncorrect state for DoAutomaticPumpLock !!! switch to (WAIT_LOCKED)");
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
					m_cPumpArray[p].SetLockStatus(WAIT_LOCK);							
					SavePumpInfo(p+1);		
				}

				case LOCKED:			
				{
					bPumpLocked = TRUE;
				}
				break;
			}
		}
	}
	else
	{
		bPumpLocked = TRUE;
	}

	return bPumpLocked;

}

// return TRUE if pump unlocked
BOOL CServerMain::DoAutomaticPumpUnLock(long lPumpNumber)
{
	long p = lPumpNumber - 1;
	BOOL	bPumpUnLocked = FALSE;

	CPumpStatus cPumpStatus;  //4.0.5.24 
	memset(&cPumpStatus, 0 , sizeof(CPumpStatus));
	//We don't want to deal with a pump which has been locked by mode...	
	if((m_cPumpsLockStateArray[p].GetPumpLockStatus() != PM_LOCKED )&& ( m_cPumpsLockStateArray[p].GetPumpLockStatus() != PM_WAIT_LOCK) )
	{		
		//If the current pump status is equal to PUMP_EXCLUSIVELY_LOCKED it means this
		//pump has been particularly locked and shouldn't be unlocked with the rest of
		//the pumps in the forecourt. Otherwise it should.

		if(!m_cSinglePumpLock.IsExclusivelyLocked(lPumpNumber)) //4.0.5.24
		{
			if(m_cPumpArray[p].GetStat().GetStatus() == UNKNOWN_STATUS || m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) //4.0.22.509 (76106)
			{
				UnlockPump(p); // TD 348577
				bPumpUnLocked = TRUE;	
			}
			else
			{

				switch(m_cPumpArray[p].GetLockStatus())
				{
					case UNLOCK:
					{
						bPumpUnLocked = TRUE;
					}
					break;

					case STARTED:
					case WAIT_LOCK:
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("Inncorrect state for DoAutomaticPumpUnLock !!! ");
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}

						long lMisc = m_cPumpArray[p].GetStat().GetMisc();
						lMisc &= MISC_CLEAR_PROCESS_FLAGS;
						
						m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
						SavePumpInfo(p+1);		
					}
					break;

					case LOCKED:
					{	
						if(m_cPumpArray[p].GetStat().GetRes() == PUMPSRV)
						{
							CMD_STRUCT_RELEASE_PUMP cmdInfo;
							cmdInfo.lRes	= PUMPSRV;
							cmdInfo.lResExt = m_cServerInfo.GetServerReservation();	// 4.0.23.2400

							if (!(m_cServerInfo.GetServerReservation() & SHIFT_CHANGE))   // release Pump from maintenance only if in original was lock for it.
								cmdInfo.lResExt = m_cServerInfo.GetServerReservation() & MAINTENANCE;

							if(m_cServerInfo.GetServerReservation() & UNLOCK_BY_TIMER)							//4.0.5550.2001
								cmdInfo.lResExt |= UNLOCK_BY_TIMER;


							SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RELEASE_PUMP));						
							m_cPumpArray[p].SetLockStatus(WAIT_RESPONSE);							
							SavePumpInfo(p+1);
							m_cPumpArray[p].m_lWaitCounter = 0;
						}
						else
						{	
							long lMisc = m_cPumpArray[p].GetStat().GetMisc();
							lMisc &= MISC_CLEAR_PROCESS_FLAGS;
							
							m_cPumpArray[p].SetLockStatus(UNLOCK,lMisc);
							m_cPumpArray[p].m_lWaitCounter = 0;
							SavePumpInfo(p+1);
						}		
						
					}
					break;

					case WAIT_RESPONSE:
					{
						UnlockPump(p); // TD 348577	
					}
					break;

					case RESPONSE_RECEIVED:
					{
						if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
						{
							long lMisc = m_cPumpArray[p].GetStat().GetMisc();
							lMisc &= MISC_CLEAR_PROCESS_FLAGS;
							
							m_cPumpArray[p].SetLockStatus(UNLOCK,lMisc);							
							SavePumpInfo(p+1);
						}
						else
						{
							m_cPumpArray[p].SetLockStatus(LOCKED);							
							SavePumpInfo(p+1);
						}
					}
					break;
				}
			}
		}
		else                                            //4.0.5.24
		{
			//Setting the ResExt again to RES_EXT_PUMP_SINGLE_LOCK in case it has been overriden
			cPumpStatus = m_cPumpArray[lPumpNumber - 1].GetStat();
			cPumpStatus.SetRes(cPumpStatus.GetRes(), RES_EXT_PUMP_SINGLE_LOCK); 
			bPumpUnLocked  = TRUE;
		}
	}
	else
	{
		bPumpUnLocked  = TRUE;
	}

	return bPumpUnLocked;
}


void CServerMain::SendGradePrice(short nGrade)
{
	CMD_STRUCT_GRADE_PRICE cmdInfo;
	char sNumber[8];
	int iRetNum=0;
	BOOL	bLast = FALSE;
	BOOL	bValidEntry = FALSE;

	short i,nGradeCount = 0;
	CString str("Grades");
	CString nextStr;
	SZ_TAG_SYSTEMTIME	szTagTime;
	szTagTime.sNull = 0;
	//4.0.8.501m_cParam.LoadParam("GeneralParam", "PriceChangeTime",(char *)&szTagTime,sizeof(szTagTime),"",FALSE);
	m_cPriceChangeFlags.GetPriceChangeDate(szTagTime);  //4.0.8.501

	BOOL ValidGrade[MAX_GRADES_99];//amram 4.0.10.502

	for(i = 1; i <= m_lMaxValidGradeNumber; i++)//amram	4.0.10.502
	{
		ValidGrade[i-1] = FALSE;
		if(nGrade == 0) 
		{
			str = "Grades\\Grade";
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",i);
			str += sNumber;
			ValidGrade[i-1] = m_cParam.CheckValidEntry((char *)((LPCTSTR)str));		
			if(ValidGrade[i-1] == TRUE)
				nGradeCount ++;
		}
	}

	if(nGrade != 0)
		nGradeCount = 1;


	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("^^^ PRICE ^^^ GradeCount = %d",nGradeCount);
		m_cLogger.LogMsg(str);
	}

	short ** NozzleArray = new short*[m_lMaxPumps + 1];  //4.0.0.79
	for(int j = 0; j < m_lMaxPumps + 1; j++)
	{
		NozzleArray[j] = new short[MAX_POSITIONS_PER_PUMP + 1];

		//4.0.1.38
		for (int k = 0; k < MAX_POSITIONS_PER_PUMP + 1; k++)
		{
			NozzleArray[j][k] = 0;
		}
	}
	
	if(NozzleLevelLogic())
	{
		for(int p=1;p<= m_lLastValidPump;p++)  //4.0.0.79
		{
			DWORD dwTmp = 0;													 	
			m_cParam.GetParam("Pumps",p,0,"ValidEntry",FIELD_DWORD,NULL,0,&dwTmp,FALSE);
			if(dwTmp)
			{
				for(int n = 1; n <= MAX_POSITIONS_PER_PUMP; n++)
				{
					dwTmp = 0;
					m_cParam.GetParam("Position",p,n,"ValidEntry",FIELD_DWORD,NULL,0,&dwTmp,FALSE);

					if(dwTmp)
					{
						m_cParam.GetParam("Position",p,n,"Grade1",FIELD_DWORD,NULL,0,&dwTmp  ,FALSE);
						NozzleArray[p][n]  = (short)dwTmp;
					}
				}
			}
		}
	}


	for(i = ((nGrade == 0)? 1:nGrade) ; i <= ((nGrade == 0)? m_lMaxValidGradeNumber:nGrade); i++)//amram 4.0.10.502
	{
		bValidEntry = ValidGrade[i-1];
		if((bValidEntry)&&(iRetNum == 0))
		{
			nGradeCount --;
			if(nGradeCount == 0) 
				bLast = TRUE;
			
			SYSTEMTIME changeTime;
			Tag2SystemTime(&szTagTime.sTime,&changeTime);
			
			SYSTEMTIME systime;
			GetLocalTime(&systime);
			CTime	cCurTime(systime);
			CTime	cChangeTime(changeTime);					
			BOOL bNew;

			if(NozzleLevelLogic())
			{
				for(int p = 1; p <= m_lLastValidPump; p++)  //4.0.0.79
				{
					for(short n = 1; n <= MAX_POSITIONS_PER_PUMP; n++)
					{	
						// locate grade in array of position
						if ( i == (int)(NozzleArray[p][n]))
						{
							if(cCurTime > cChangeTime )
							{
								if(m_cServerInfo.IsPendingCommitPriceChangeWithIntegrityProcess()) //4.0.27.20
									bNew = FALSE;
								else
									bNew = TRUE;
								SetPriceCommand(p,n,i,&cmdInfo,bNew,FALSE);
							}
							else
							{
								bNew = FALSE;
								SetPriceCommand(p,n,i,&cmdInfo,bNew,FALSE);
							}
					
						}
					}
				}
			}
			

			if(cCurTime > cChangeTime )
			{		

				if(m_cServerInfo.IsPendingCommitPriceChangeWithIntegrityProcess()) //4.0.27.20
					bNew = FALSE;
				else
					bNew = TRUE;
				
				SetPriceCommand(0,0,i,&cmdInfo,bNew,bLast);
			}
			else
			{
				bNew = FALSE;
				SetPriceCommand(0,0,i,&cmdInfo,bNew,bLast);
			}
		}								
	}

	for(int j = 0;j < m_lMaxPumps + 1;j++)
	{
		delete[] NozzleArray[j];
	}

	delete[] NozzleArray;
}

//4.0.27.20 - support price integritiy
void CServerMain::SetPriceCommand(long lPumpNumber, short nNozzle,short nGrade,CMD_STRUCT_GRADE_PRICE *pCmdInfo,BOOL bNew,BOOL bLast)
{

	CString str = "Grades\\Grade";
	char sNumber[8];
	long lPosNumber = SERVER_POS_NUMBER;

	memset(sNumber,0,sizeof(sNumber));
	sprintf_s(sNumber, _countof(sNumber),"%02d",nGrade);
	str += sNumber;

	pCmdInfo->nGrade		= nGrade;
	pCmdInfo->lPumpNumber	= lPumpNumber;	// 0 - all pumps
	pCmdInfo->nNozzle		= nNozzle;		// 0 - all nozzles

	//4.0.8.503
	if(bNew)
	{		
		pCmdInfo->nFlags = PRICE_A_CASH|PRICE_B_CREDIT|PRICE_SELF_SERVICE;									

		//4.0.12.515
		if (IsInOriginalPriceChangeProcess())
		{
			pCmdInfo->nFlags |= EXPECT_PRICE_CHANGE_RESULT;
		}
		
		//4.0.19.820 - TD 78775
		if (m_cServerInfo.GetInPriceChangeWithAckProcessFlag())
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_WITH_ACK_PER_PUMP;
		}

		if (m_cServerInfo.IsInPriceChangeWithIntegrityProcess())	
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_INTEGRITY;
			lPosNumber = GetPriceChangeBatchNumber();

		}

		if (m_cServerInfo.IsInCommitPriceChangeWithIntegrityProcess()) 
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_COMMIT_PUMPS_ONLY;

		}

		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_SelfService",(DWORD *)&pCmdInfo->lPriceA,(DWORD)0,FALSE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_SelfService",(DWORD *)&pCmdInfo->lPriceB,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		SetCommand(CMD_SET_GRADE_PRICE, lPosNumber, lPumpNumber,pCmdInfo,sizeof(CMD_STRUCT_GRADE_PRICE));

		pCmdInfo->nFlags = PRICE_A_CASH|PRICE_B_CREDIT|PRICE_FULL_SERVICE;					
		lPosNumber = SERVER_POS_NUMBER;//4.0.26.508 147183

		//4.0.12.515
		if (IsInOriginalPriceChangeProcess())
		{
			pCmdInfo->nFlags |= EXPECT_PRICE_CHANGE_RESULT;
		}

		//4.0.19.820 - TD 78775
		if (m_cServerInfo.GetInPriceChangeWithAckProcessFlag())
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_WITH_ACK_PER_PUMP;
		}

		if (m_cServerInfo.IsInPriceChangeWithIntegrityProcess())	
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_INTEGRITY;
			lPosNumber = GetPriceChangeBatchNumber();
		}

		if (m_cServerInfo.IsInCommitPriceChangeWithIntegrityProcess()) 
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_COMMIT_PUMPS_ONLY;

		}

		if(bLast)
		{
			pCmdInfo->nFlags |= PRICE_END_OF_LIST;
		}

		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_FullService",(DWORD *)&pCmdInfo->lPriceA,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_FullService",(DWORD *)&pCmdInfo->lPriceB,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		SetCommand(CMD_SET_GRADE_PRICE, lPosNumber, lPumpNumber,pCmdInfo,sizeof(CMD_STRUCT_GRADE_PRICE));													
	}
	else
	{
		pCmdInfo->nFlags = PRICE_A_CASH|PRICE_B_CREDIT|PRICE_SELF_SERVICE;					
		lPosNumber = SERVER_POS_NUMBER;//4.0.26.508 147183

		//4.0.12.515
		if (IsInOriginalPriceChangeProcess())
		{
			pCmdInfo->nFlags |= EXPECT_PRICE_CHANGE_RESULT;
		}

		//4.0.19.820 - TD 78775
		if (m_cServerInfo.GetInPriceChangeWithAckProcessFlag())
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_WITH_ACK_PER_PUMP;
		}

		if (m_cServerInfo.IsInPriceChangeWithIntegrityProcess())	
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_INTEGRITY;
			lPosNumber = GetPriceChangeBatchNumber();

		}

		if (m_cServerInfo.IsInCommitPriceChangeWithIntegrityProcess()) 
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_COMMIT_PUMPS_ONLY;

		}
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Old_PriceCash_SelfService",(DWORD *)&pCmdInfo->lPriceA,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Old_PriceCredit_SelfService",(DWORD *)&pCmdInfo->lPriceB,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		SetCommand(CMD_SET_GRADE_PRICE, lPosNumber, lPumpNumber,pCmdInfo,sizeof(CMD_STRUCT_GRADE_PRICE));						

		pCmdInfo->nFlags = PRICE_A_CASH|PRICE_B_CREDIT|PRICE_FULL_SERVICE;					
		lPosNumber = SERVER_POS_NUMBER;//4.0.26.508 147183

		//4.0.12.515
		if (IsInOriginalPriceChangeProcess())
		{
			pCmdInfo->nFlags |= EXPECT_PRICE_CHANGE_RESULT;
		}

		//4.0.19.820 - TD 78775
		if (m_cServerInfo.GetInPriceChangeWithAckProcessFlag())
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_WITH_ACK_PER_PUMP;
		}

		if (m_cServerInfo.IsInPriceChangeWithIntegrityProcess())	
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_INTEGRITY;
			lPosNumber = GetPriceChangeBatchNumber();

		}

		if (m_cServerInfo.IsInCommitPriceChangeWithIntegrityProcess()) 
		{
			pCmdInfo->nFlags |= PRICE_CHANGE_COMMIT_PUMPS_ONLY;

		}
		if(bLast)
		{
			pCmdInfo->nFlags |= PRICE_END_OF_LIST;
		}
		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Old_PriceCash_FullService",(DWORD *)&pCmdInfo->lPriceA,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Old_PriceCredit_FullService",(DWORD *)&pCmdInfo->lPriceB,(DWORD)0,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		SetCommand(CMD_SET_GRADE_PRICE, lPosNumber, lPumpNumber,pCmdInfo,sizeof(CMD_STRUCT_GRADE_PRICE));													
	}
	//4.0.8.503
}

BOOL CServerMain::NozzleLevelLogic()
{
	if(m_dwNozzleLevelLogic)
		return TRUE;
	else
		return FALSE;
}

long CServerMain::GetLockResExt()
{
	return m_cServerInfo.GetServerReservation();
}

void CServerMain::SetLockResExt(long lStat)
{
	m_cServerInfo.SetServerReservation(lStat);
}


void CServerMain::SetServerLockStatus(LockStatus lStat)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	if (lStat != IGNORE_LOCK_STATUS)
	{
		long lTmpLockResExt = m_cServerInfo.GetServerReservation();
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str = "Server Lock State: ";
			switch(lStat)
			{
				case STARTED: str += "STARTED"; break;
				case WAIT_LOCK: str += "WAIT_LOCK"; break;
				case LOCKED: str += "LOCKED"; break;
				case WAIT_RESPONSE: str += "WAIT_RESPONSE"; break;
				case RESPONSE_RECEIVED: str += "RESPONSE_RECEIVED"; break;
				case UNLOCK: str += "UNLOCK"; break;
			}
			
			// 4.0.8.500 
			// change  paramter m_cInfo.lockResExt to lTmpLockResExt
			if(lTmpLockResExt & PRICE_CHANGE)
			{
				str += " (PRICE_CHANGE) ";
			}
			if(lTmpLockResExt & TANK_READING)
			{
				str += " (TANK_READING) ";
			}
			if(lTmpLockResExt & PUMP_TOTALS_READING)
			{
				str += " (PUMP_TOTALS_READING) ";
			}	
			if(lTmpLockResExt & SHIFT_CHANGE)
			{
				str += " (SHIFT_CHANGE) ";
			}
			if(lTmpLockResExt & MAINTENANCE)
			{
				str += " (MAINTENANCE) ";
			}

			m_cLogger.LogMsg( str );
		}

		m_cServerInfo.SetServerStatus(lStat);

	}

	SQLPumpSrvFile.SaveServerInfo();


}

void CServerMain::SetShiftChangeState(ChangeState lStat)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	m_cServerInfo.SetShiftChangeStatus(lStat);	

	SQLPumpSrvFile.SaveServerInfo();

}

void CServerMain::SetPriceChangeState(ChangeState lStat)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	m_cServerInfo.SetPriceChangeState(lStat);

	SQLPumpSrvFile.SaveServerInfo();

}

void CServerMain::SetCurrentShift(SHIFT_REC *pInfo)
{
	m_cCurrentShift = *pInfo;
} 

void CServerMain::GetCurrentShift(SHIFT_REC *pInfo)
{
	*pInfo = m_cCurrentShift;
}


LockStatus CServerMain::GetLockStatus()
{
	return 	m_cServerInfo.GetServerStatus();
}

long CServerMain::SavePumpInfo(long lPumpNumber)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	long lRetCode = 0;

	SQLPumpSrvFile.SaveInfo(lPumpNumber, __FUNCTION__, __LINE__);

	return lRetCode;
}

void CServerMain::CheckShiftChange__(BOOL bForceNonLock)
{
	__try
	{
		CheckShiftChange(bForceNonLock);
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckShiftChange")) //4.0.15.450
	{

		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckShiftChange()", LOG_LEVEL_0);	

		exit(1);
	}   
}

void CServerMain::DoAutomaticMaintenanceLock__()
{
	__try
	{
		DoAutomaticMaintenanceLock();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticMaintenanceLock")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticMaintenanceLock()", LOG_LEVEL_0);

		exit(1);
	}
}

//4.0.3.27  Changed method to support emergency lock
void CServerMain::DoAutomaticMaintenanceLock()
{
	BOOL bPerformLock = FALSE;

	if(m_cServerInfo.GetRequiredMaintenanceProcessFlags() == MP_LOCK)
	{
		bPerformLock = TRUE;		

		m_cServerInfo.SetServerReservation(MAINTENANCE);
	}
	 
	else if(m_cServerInfo.GetRequiredMaintenanceProcessFlags() == MP_EMERGENCY_LOCK)
	{
		bPerformLock = TRUE;

		m_cServerInfo.SetServerReservation(EMERGENCY_LOCK);
		
	}

	//4.0.5550.1504
	else if(m_cServerInfo.GetRequiredMaintenanceProcessFlags() == MP_DB_MAINTENANCE_LOCK)
	{
		bPerformLock = TRUE;
		m_cServerInfo.SetServerReservation(DATABASE_MAINTENANCE);
	}

	if(bPerformLock)
	{
		switch(m_cServerInfo.GetServerStatus())
		{
			case UNLOCK:
			//-----------------------------------------------------------------------------------
			{
				SetServerLockStatus(STARTED);

				//4.0.13.50
				m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,ALARM_FORECOURT_IN_MAINTENANCE,0,1,0,0);
			}
			break;

			case STARTED:
			case WAIT_LOCK:
			//-----------------------------------------------------------------------------------
			{
				BOOL bAllPumpsLocked = TRUE;

				for (int p = 0;p < m_lLastValidPump;p++)
				{
					if(!DoAutomaticPumpLock(p+1,m_cServerInfo.GetServerReservation()))
					{
						bAllPumpsLocked = FALSE;

						if(m_cServerInfo.GetServerStatus() != WAIT_LOCK) 
							SetServerLockStatus(WAIT_LOCK);	
					}
				}

				if(bAllPumpsLocked)
					SetServerLockStatus(LOCKED);
			}
			break;

			case WAIT_RESPONSE:
			//-----------------------------------------------------------------------------------
			{
				SetServerLockStatus(WAIT_LOCK);	
			}
			break;

			case LOCKED:
			//-----------------------------------------------------------------------------------
			{
				m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_NONE);
				SetServerLockStatus(IGNORE_LOCK_STATUS);

			}
			break;
		}
	}
}

void CServerMain::DoAutomaticMaintenanceUnlock__()
{
	__try
	{
		DoAutomaticMaintenanceUnlock();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticMaintenanceUnlock")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticMaintenanceUnlock()", LOG_LEVEL_0);

		exit(1);
	}
}

void CServerMain::DoAutomaticMaintenanceUnlock()
{
	int p = 0;
	BOOL bAllPumpsUnLocked = TRUE;
	CString sLogMsg;

	if(m_cServerInfo.GetRequiredMaintenanceProcessFlags() == MP_UNLOCK)
	{
		switch(m_cServerInfo.GetServerStatus())
		{
			case UNLOCK:       //3.0.0.4 
			//-----------------------------------------------------------------------------------
			{	
				m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_NONE);
				SetServerLockStatus(IGNORE_LOCK_STATUS);
			}
			break;

			case LOCKED:
			//-----------------------------------------------------------------------------------
			{
				SetServerLockStatus(RESPONSE_RECEIVED);	
			}
			break;

			//4.0.14.501
			case WAIT_LOCK:
			//-----------------------------------------------------------------------------------
			{

				CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

				for(p = 0; p < m_lLastValidPump;p++)
				{
					if (m_cPumpArray[p].GetLockStatus() == WAIT_LOCK)
					{
						m_cPumpArray[p].SetLockStatus(UNLOCK);							
						SavePumpInfo(p+1);
					}
				}

				SetServerLockStatus(RESPONSE_RECEIVED);	
			}
			break;

			case RESPONSE_RECEIVED: 
			//-----------------------------------------------------------------------------------
			{
				bAllPumpsUnLocked = TRUE;

				for(p=0;p< m_lLastValidPump;p++)
				{
					if(DoAutomaticPumpUnLock(p+1) == FALSE)
					{
						bAllPumpsUnLocked = FALSE;
					}
				}

				if(bAllPumpsUnLocked)
				{	
					m_cServerInfo.ClearShiftFlags(); 
					SetServerLockStatus(UNLOCK);	
					
					//4.0.23.20 - shut off the maintenance alarm.
					m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,ALARM_FORECOURT_IN_MAINTENANCE,0,0,0,0);
				}
			}
			break;
		}
	}

	//4.0.1.38 Start
	else if(m_cServerInfo.GetRequiredMaintenanceProcessFlags() == MP_FORCED_UNLOCK)
	{
		//If we're in the middle of a Tank Delivery Emulation process - need to clear it:
        
		int nErrorRetrieved = 0;

		if(m_cServerInfo.GetDeliveryEmulationStatus() != DES_IDLE)
			SetDeliveryFlags(DES_IDLE, PD_FORCE_RELEASE , nErrorRetrieved, TRUE);

		switch(m_cServerInfo.GetServerStatus())
		{
		case STARTED:
		case WAIT_LOCK:
			bAllPumpsUnLocked = TRUE;

			for(p=0;p< m_lLastValidPump;p++)
			{
				if(!DoAutomaticPumpUnLock(p+1))
					bAllPumpsUnLocked = FALSE;
			}

			if(bAllPumpsUnLocked)
			{	
				m_cServerInfo.ClearShiftFlags();

				SetServerLockStatus(UNLOCK);

				sLogMsg.Format("DOAutomaticMaintenanceUnlock, forced unlock of all pumps completed");
				_LOGMSG.LogMsg(sLogMsg , LOG_LEVEL_1);
			}

			break;

		//Connect to regular unlock flow
		case LOCKED:
			
			m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_UNLOCK);
			SetServerLockStatus(RESPONSE_RECEIVED);
			
			sLogMsg.Format("DOAutomaticMaintenanceUnlock, attempted forced unlock of locked forecourt, using normal unlock process");
			_LOGMSG.LogMsg(sLogMsg , LOG_LEVEL_1);
			break;

		//Connect to regular unlock flow
		case RESPONSE_RECEIVED:
			m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_UNLOCK);
	
			sLogMsg.Format("DOAutomaticMaintenanceUnlock, forced unlock connecting to usual flow");
			_LOGMSG.LogMsg(sLogMsg , LOG_LEVEL_1);
			break;

		//Forecourt already unlocked, no need to do anything
		case UNLOCK:
			m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_NONE);
			sLogMsg.Format("DOAutomaticMaintenanceUnlock, attempted forced unlock, but forecourt already unlocked");
			_LOGMSG.LogMsg(sLogMsg , LOG_LEVEL_1);

			//4.0.14.501
			//Check if there is a single pump that is locked and release it.
			//Only if the timer is > 0 
			if (GetUnbalancedPrPTimer())
			{
				//Check the lock for each pump
				for (int i=0;i<m_cPumpArray.GetSize();i++) //4.0.22.503 - read GetSize instead of MAX_PUMPS_64
				{
					//If the pump is locked
					if (m_cPumpArray[i].GetStat().GetRes() == PUMPSRV &&
						m_cPumpArray[i].GetStat().GetResExt() == RES_EXT_PUMP_SINGLE_LOCK)
					{
						//Unlock the pump
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("Force unlock - there is pump locked, release the pump");
							_LOGMSG.LogMsg(i+1,LOG_PUMP,str);	
						}

						CMD_STRUCT_RELEASE_PUMP cmdReleaseSinglePump;
						memset(&cmdReleaseSinglePump, 0 , sizeof(CMD_STRUCT_RELEASE_PUMP));

						cmdReleaseSinglePump.lRes = PUMPSRV;
						cmdReleaseSinglePump.lResExt = IDLE;
						SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER,i+1,&cmdReleaseSinglePump,sizeof(CMD_STRUCT_RELEASE_PUMP));

						//Changing the state to PUMP_WAIT_TO_BE_EXCLUSIVELY_LOCKED in the state machine
						m_cSinglePumpLock.SetPumpStateWaitUnlocked(i+1);

						CPumpTransact trs;
						int nArraySize = m_cPumpArray[i+1].GetTrsArraySize();

						CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

						for (int nTrsNum = 0; nTrsNum < nArraySize; nTrsNum++)
						{
							m_cPumpArray[i].GetTrsByIndex(nTrsNum , &trs);

							//Check if we reach UnbalancedPrPTimer, then update the trs.
							if(trs.GetStatus() == ACCEPTED)
							{
								//check if it is a PrePay trs and the timer is not 0.
								if ((trs.GetRes() == PRE_PAY_AT_POS) && (GetUnbalancedPrPTimer() > 0))
								{
									SYSTEMTIME st;
									CTime cTime = trs.GetTime();

									cTime.GetAsSystemTime(st);
									long lMin = GetUnbalancedPrPTimer() / 60;

									st.wMinute -= (WORD)(lMin + 5);

									trs.SetTime(st);

									m_cPumpArray[i].SetTrsByIndex(nTrsNum , &trs, FALSE);

								}
							}
						}
					}
				}
			}

			break;
			
		default:
			sLogMsg.Format("DoAutomaticMaintenanceUnlock, unexpected lock status (%d) found while attempting forced unlock" , m_cServerInfo.GetServerReservation());
			_LOGMSG.LogMsg(sLogMsg , LOG_LEVEL_1);

			m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_NONE);
			
			
			break;
		}
	}
	//4.0.1.38 End
}

/******************************************************************************
 Description:	Handling the Start Lock State in the delivery emulation single tank state machine.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.000 TD 66935
******************************************************************************/
void CServerMain::HandleStartLockState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	if (lProcessStoppedStatus == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT)
	{
		//Setting the appropriate flags in the delivery emulation single tank state machine:
		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_IDLE, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_IDLE failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: process returned back to idle state due to aborting operation", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}

	}
	else
	{
		if ((m_dwEmulationDeliveryTimeOut) && (bLockConnectedPumps))
		{
			//Locking the Tank (all the pumps connected to the tank):
		    m_cServerInfo.SetSingleTankLockStatus(lTankNumber, SINGLE_TANK_LOCK_STARTED);
				
		    //Setting the appropriate flags in the delivery emulation single tank state machine:
		    if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_WAIT_FOR_LOCK, lProcessCommand, nErrorRetrieved))
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_WAIT_FOR_LOCK failed", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
			else
				m_cTankArray[lTankNumber-1].InitWaitForLockTime();

		}
	    else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: start without lock pumps", lTankNumber);
		    m_cLogger.LogMsg(strLog);
				 
		    if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_REQUEST_TANK_READING, lProcessCommand, nErrorRetrieved))
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_REQUEST_TANK_READING failed", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
		}
	}
}

/******************************************************************************
 Description:	Handling the Wait For Lock State in the delivery emulation single tank state machine. 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::HandleWaitForLockState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	if ((lProcessStoppedStatus == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (m_cTankArray[lTankNumber-1].IsTimeOutForLocking()))
	{
		//Setting the appropriate flags in the delivery emulation single tank state machine:
		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_UNLOCK, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_UNLOCK failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: process was jumped to UnLock state due to aborting operation", lTankNumber);
			m_cLogger.LogMsg(strLog);
			m_cTankArray[lTankNumber-1].ResetWaitForLockTime();	//Zeroing the lock TimeOut variable
		}
	}

	else
	{
		if (m_cServerInfo.GetSingleTankLockStatus(lTankNumber) == SINGLE_TANK_LOCKED)
		{
			//The tank is locked - switching to a timeout state, and starting to measure time...
		    //(all tank's pumps should be locked for some time, before a reading can started):
				
		    if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_WAIT_TIMEOUT, lProcessCommand, nErrorRetrieved))
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_WAIT_TIMEOUT failed", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
		    else
			{
				m_cTankArray[lTankNumber-1].ResetWaitForLockTime();//Zeroing the lock TimeOut variable
				m_cTankArray[lTankNumber-1].InitEndLockTime();	   //Init the time measuring variable

				//4.0.19.1260 - TD 242013
				if (lProcessCommand == PD_SINGLE_TANK_START)
				{
					m_cTankArray[lTankNumber-1].TurnOnIncDeliveryEmulationSales();

					if (LOG_DETAIL_FLOW_CONTROL)
					{
						strLog.Format("Delivery Emulation Single Tank: TurnOnIncDeliveryEmulationSales - lTankNumber %ld", lTankNumber);
						m_cLogger.LogMsg(strLog);
					}
				}
			}
		}

	}
}

/******************************************************************************
 Description:	Handling the Wait Time Out State in the delivery emulation single tank state machine.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::HandleWaitTimeOutState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	if (lProcessStoppedStatus == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT)
	{
		//Setting the appropriate flags in the delivery emulation single tank state machine:
		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_UNLOCK, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_UNLOCK failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: process was jumped to UnLock state due to aborting operation", lTankNumber);
			m_cLogger.LogMsg(strLog);
			m_cTankArray[lTankNumber-1].ResetEndLockTime();	//Zeroing the time measuring variable
		}

	}
	else
	{
		//Checking if the delivery emulation timeout for this tank has passed. If it did, start the tank reading process:
	    if(m_cTankArray[lTankNumber-1].IsTimeOutBeforeReading())
		{
			if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_REQUEST_TANK_READING, lProcessCommand, nErrorRetrieved))
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_REQUEST_TANK_READING failed", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
			else
				m_cTankArray[lTankNumber-1].ResetEndLockTime();	//Zeroing the time measuring variable
		}

	}
}

/******************************************************************************
 Description:	Handling the Request Tank Reading State in the delivery emulation single tank state machine.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::HandleRequestTankReadingState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	if (lProcessStoppedStatus == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT)
	{
		//Setting the appropriate flags in the delivery emulation single tank state machine:
		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_UNLOCK, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_UNLOCK failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: process was jumped to UnLock state due to aborting operation", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}

	}
	else
	{
		if ((m_cServerInfo.GetWetStockFlags()) || (m_cServerInfo.GetRequiredShiftProcessFlags())|| (m_cServerInfo.GetMemoProcessFlags()))
		{
			//Wait different process to be end:
		    if(LOG_BASIC_FLOW_CONTROL)
			{
				strLog.Format("Delivery attempt GetWetstock fail WetStackflags=%ld ,Shiftprocess=%ld, memeo flags=%ld", m_cServerInfo.GetWetStockFlags(), m_cServerInfo.GetRequiredShiftProcessFlags(), m_cServerInfo.GetMemoProcessFlags());
			    m_cLogger.LogMsg(strLog);
			}
		}
		else //Send the tank reading request:
		{
			if(lProcessCommand == PD_SINGLE_TANK_START)
				GetWetStockData(WSM_BY_START_DELIVERY);
			else if(lProcessCommand == PD_SINGLE_TANK_END)
				GetWetStockData(WSM_BY_END_DELIVERY);
			else //Error
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: DES_SINGLE_TANK_REQUEST_TANK_READING in invalid process type", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
			
			if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_WAIT_TANK_READING, lProcessCommand, nErrorRetrieved))
			{
				strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_WAIT_TANK_READING failed", lTankNumber);
			    m_cLogger.LogMsg(strLog);
			}
		    else
				m_cTankArray[lTankNumber-1].InitWaitForReadTime();
		}

	}
}

/******************************************************************************
 Description:	Handling the Wait Tank Reading State in the delivery emulation single tank state machine.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::HandleWaitTankReadingState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	if ((lProcessStoppedStatus == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (m_cTankArray[lTankNumber-1].IsTimeOutForReading()))
	{
		//Clearing the wet stock process (=> wet stock reading flags) + release locked pumps:
		strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: Clearing Tank Reading Flags, in order to cancel tank reading process, due to aborting operation", lTankNumber);
		m_cLogger.LogMsg(strLog);
		m_cServerInfo.ClearTankReadingFlags();
		//Setting the appropriate flags in the delivery emulation single tank state machine:
		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_UNLOCK, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_UNLOCK failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: process was jumped to UnLock state due to aborting operation", lTankNumber);
			m_cLogger.LogMsg(strLog);
			m_cTankArray[lTankNumber-1].ResetWaitForReadTime();	//Zeroing the reading TimeOut variable
		}

	}
	//Else: do nothing - this state is handled in CGCI::TankReading2__

}

/******************************************************************************
 Description:	Handling the Un Lock State in the delivery emulation single tank state machine.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		06/11/2008   11:02		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::HandleUnLockState(const BYTE lProcessCommand, const long lProcessStoppedStatus, const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps)
{
	CString strLog;
	int		nErrorRetrieved = 0;

	m_cTankArray[lTankNumber-1].ResetWaitForReadTime();	//Zeroing the reading TimeOut variable

	SERVER_INFO  cLogInfo;
	m_cServerInfo.GetInfo(cLogInfo);
	strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank: DES_SINGLE_TANK_UNLOCK state. Delivery Emulation Single Tank Status: %d, Delivery Emulation Single Tank Process: %d, Tank Lock Status: %d, byRequiredMaintenanceProcess: %d ", cLogInfo.byDeliveryEmulationSingleTankStatus[lTankNumber - 1], cLogInfo.byDeliveryEmulationSingleTankProcess[lTankNumber - 1], cLogInfo.lSingleTankLockStatus[lTankNumber - 1], cLogInfo.byRequiredMaintenanceProcess);
	m_cLogger.LogMsg(strLog);

	//If the tank is unlocked now we can switch back to idle state - the process is finished:
	if (m_cServerInfo.GetSingleTankLockStatus(lTankNumber) == SINGLE_TANK_UNLOCKED)
	{
		strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank: DES_SINGLE_TANK_UNLOCK state, TANK IS UNLOCKED. Delivery Emulation Single Tank Status: %d, Delivery Emulation Single Tank Process: %d, Tank Lock Status: %d, byRequiredMaintenanceProcess: %d ", cLogInfo.byDeliveryEmulationSingleTankStatus[lTankNumber - 1], cLogInfo.byDeliveryEmulationSingleTankProcess[lTankNumber - 1], cLogInfo.lSingleTankLockStatus[lTankNumber - 1], cLogInfo.byRequiredMaintenanceProcess);
	    m_cLogger.LogMsg(strLog);

		/*****************/
		//Reset The PumpSrv Delivery emulation Accumulated Delivery 
		//Emulation sales to avoid wrong calculation of transaction
		//which started before getting the tank readings //4.0.19.160 TD 63661
		/*****************/			
 		if(	(lProcessCommand == PD_SINGLE_TANK_END) &&
			(lProcessStoppedStatus != SINGLE_TANK_PROCESS_STOPPED_BY_ABORT))			//4.0.28.500	TD 224543  
 		{
 			//save zero to memory 
 			m_cTankArray[lTankNumber-1].ReSetAccumulatedDeliveryEmulationSales();
 			
 			//save to ini 
 			m_cTankArray[lTankNumber-1].SaveAccumulatedDeliveryEmulationSales();


			m_cTankArray[lTankNumber-1].TurnOffIncDeliveryEmulationSales();
			if (LOG_DETAIL_FLOW_CONTROL)
			{
				strLog.Format("Delivery Emulation Single Tank: ReSetAccumulatedDeliveryEmulationSales and TurnOffIncDeliveryEmulationSales - lTankNumber %ld", lTankNumber);
				m_cLogger.LogMsg(strLog);
			}		
 		}

		if(!SetDeliverySingleTankFlags(lTankNumber, lTankReference, bLockConnectedPumps, DES_SINGLE_TANK_IDLE, lProcessCommand, nErrorRetrieved))
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: call to SetDeliverySingleTankFlags() function with DES_SINGLE_TANK_IDLE failed", lTankNumber);
			m_cLogger.LogMsg(strLog);
		}
		else
			m_cTankArray[lTankNumber-1].SetWasUnlockCommandSet(FALSE);
	}
	else
	{
		//If tank is still not unlocked yet, and also - a unlocked request wasn't sent: send it:
		if(!m_cTankArray[lTankNumber-1].GetWasUnlockCommandSet())
		{
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: Requesting to Unlock Tank", lTankNumber);
			m_cLogger.LogMsg(strLog);

			m_cServerInfo.SetSingleTankLockStatus(lTankNumber, SINGLE_TANK_UNLOCK_STARTED);
				    
			SERVER_INFO rec;
			m_cServerInfo.GetInfo(rec);
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank: After Request to Unlock Tank. DES_SINGLE_TANK_UNLOCK state, TANK IS UNLOCKED. Delivery Emulation Single Tank Status: %d, Delivery Emulation Single Tank Process: %d, Tank Lock Status: %d, byRequiredMaintenanceProcess: %d ", cLogInfo.byDeliveryEmulationSingleTankStatus[lTankNumber - 1], cLogInfo.byDeliveryEmulationSingleTankProcess[lTankNumber - 1], cLogInfo.lSingleTankLockStatus[lTankNumber - 1], cLogInfo.byRequiredMaintenanceProcess);
			m_cLogger.LogMsg(strLog);
					
			m_cTankArray[lTankNumber-1].SetWasUnlockCommandSet(TRUE);
		}
	}
}

/******************************************************************************
 Description:	Automatic procedure done for the Emulation Delivery Single Tank Process 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		23/10/2008   11:44		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::DoAutomaticEmulationDeliverySingleTank(const long lTankNumber)
{	
	CString strLog;

	long	lTankReference        = m_cTankArray[lTankNumber-1].GetDeliveryReference(); 
	BOOL	bLockConnectedPumps   = m_cTankArray[lTankNumber-1].GetLockConnectedPumps();

	BYTE	lProcessCommand       = m_cServerInfo.GetDeliveryEmulationSingleTankProcessType(lTankNumber);
	long	lProcessStatus        = m_cServerInfo.GetDeliveryEmulationSingleTankStatus(lTankNumber);
	long	lProcessStoppedStatus = m_cServerInfo.GetDeliveryEmulationSingleTankProcessStopped(lTankNumber);

	switch(lProcessStatus)
	{
		case DES_SINGLE_TANK_IDLE:

			//Do nothing - default situation
			break;

			
		case DES_SINGLE_TANK_START_LOCK:
		{
			HandleStartLockState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}

		case DES_SINGLE_TANK_WAIT_FOR_LOCK:
		{
			HandleWaitForLockState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}

		case DES_SINGLE_TANK_WAIT_TIMEOUT:
		{
			HandleWaitTimeOutState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}

		case  DES_SINGLE_TANK_REQUEST_TANK_READING:
		{
			HandleRequestTankReadingState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}

		case DES_SINGLE_TANK_WAIT_TANK_READING:
		{
			HandleWaitTankReadingState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}

		case DES_SINGLE_TANK_UNLOCK:
		{
			HandleUnLockState(lProcessCommand, lProcessStoppedStatus, lTankNumber, lTankReference, bLockConnectedPumps); 
			break;
		}			
				
		default: //Invalid State:
			strLog.Format("Delivery Emulation Single Tank: DoAutomaticEmulationDeliverySingleTank for tank number %d: Invalid value for m_cInfo.byDeliveryEmulationSingleTankStatus. Transferring to default statuses", lTankNumber);
			m_cLogger.LogMsg(strLog);
			
			//Error in data - transferring back to default statuses:
			m_cServerInfo.ClearSingleTankFlags();

			break;
	}
}

/******************************************************************************
 Description:	Automatic procedure done for the Emulation Delivery Single Tank Process 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		23/10/2008   11:44		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::DoAutomaticEmulationDeliverySingleTank__()
{
	try
	{
		for(long lTankNumber = 0; lTankNumber < m_lLastValidTank; lTankNumber++)
			DoAutomaticEmulationDeliverySingleTank(lTankNumber + 1);
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticEmulationDeliverySingleTank()", LOG_LEVEL_0);
		exit(1);
	}
}

/******************************************************************************
 Description:	Automatic procedure done for the Emulation Delivery Process 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Udi F			09/02/2004   14:37		Start
******************************************************************************/
void CServerMain::DoAutomaticEmulationDelivery__()
{
	__try
	{
		DoAutomaticEmulationDelivery();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticEmulationDelivery")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticEmulationDelivery()", LOG_LEVEL_0);
		exit(1);
	}
}

/******************************************************************************
 Description:	Automatic procedure done for the Emulation Delivery Process 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Udi F			09/02/2004   15:55		Start
******************************************************************************/
void CServerMain::DoAutomaticEmulationDelivery()
{		
	static BOOL bWasUnlockCommandSet = FALSE;

	long         lLoopCounter       = 0;
	static DWORD dwInitialTickCount = 0;
	DWORD        dwCurTickCount     = 0;
	int          nErrorRetrieved    = 0;

	CString strLog;

	switch(m_cServerInfo.GetDeliveryEmulationStatus())
	{
		case DES_IDLE :
			//Do nothing - default situation
			break;

		case DES_START_LOCK: 
			 if (m_dwEmulationDeliveryTimeOut)  //4.0.15.501
			 {

				//Locking the forecourt

				m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_LOCK);
				
				//Setting the appropriate flags in the delivery emulation state machine
	
				if(!SetDeliveryFlags(DES_WAIT_FOR_LOCK,m_cServerInfo.GetDeliveryEmulationStatus(), nErrorRetrieved))
					m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");

			 }
			 else //4.0.14.240
			 { 
				m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: start without lock forecourt.");

				if(!SetDeliveryFlags(DES_REQUEST_TANK_READING, m_cServerInfo.GetDeliveryEmulationProcessType(), nErrorRetrieved))  
					m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");

			 }
			break;
		
		case DES_WAIT_FOR_LOCK:
			if(LOCKED == m_cServerInfo.GetServerStatus()) //4.0.13.505
			{
				//The forecourt is locked - switching to a timeout state, and starting to measure time...
				
				if(!SetDeliveryFlags(DES_WAIT_TIMEOUT, m_cServerInfo.GetDeliveryEmulationStatus(), nErrorRetrieved))					
					m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");
				else
					dwInitialTickCount = GetTickCount();
			}
			break;

		case DES_WAIT_TIMEOUT:
		{
			//4.0.14.250
			//Checking if the delivery emulation timeout has passed. If it did, we start the actual read tanks process
			dwCurTickCount = GetTickCount();
			if( (dwCurTickCount - dwInitialTickCount) > (m_dwEmulationDeliveryTimeOut * MILLISECONDS_IN_A_SECOND) )
			{
				//4.0.14.240
				if(!SetDeliveryFlags(DES_REQUEST_TANK_READING, m_cServerInfo.GetDeliveryEmulationProcessType(), nErrorRetrieved))  
					m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");
				//Zeroing the time measuring variable again
				else
					dwInitialTickCount = 0;
			}
		}
			break;

		//4.0.14.240
		case  DES_REQUEST_TANK_READING:
			{
				if (m_cServerInfo.GetWetStockFlags()  ||
				m_cServerInfo.GetRequiredShiftProcessFlags()||
				m_cServerInfo.GetMemoProcessFlags())
				{
					// Wait different process to be end
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("deleivery attempt GetWetstock fail WetStackflags=%ld ,Shiftprocess=%ld, memeo flags=%ld", 
												 m_cServerInfo.GetWetStockFlags() ,
													m_cServerInfo.GetRequiredShiftProcessFlags(),
													m_cServerInfo.GetMemoProcessFlags());

							m_cLogger.LogMsg(str);
						}
					
				}
				else
				{
					if(PD_START == m_cServerInfo.GetDeliveryEmulationProcessType())
						GetWetStockData( WSM_BY_START_DELIVERY );
					else if(PD_END == m_cServerInfo.GetDeliveryEmulationProcessType())					
						GetWetStockData( WSM_BY_END_DELIVERY );
					else //Error
						m_cLogger.LogMsg("Delivery: DES_WAIT_TIMEOUT in invalid EmulationProcess ");					

					if(!SetDeliveryFlags(DES_WAIT_TANK_READING, m_cServerInfo.GetDeliveryEmulationProcessType(), nErrorRetrieved))
						m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");
					//Zeroing the time measuring variable again
					else
						dwInitialTickCount = 0;

				}

				break;


			}

		case DES_WAIT_TANK_READING:
			//Do nothing - this state is handled in CGCI::TankReading2__
			break;

		case DES_UNLOCK:
			//@@@ 4.0.5.31

			/*****************/
			//Reset The PumpSrv Delivery emulation Accumulated Delivery 
			//Emulation sales to avoid wrong calculation of transaction
			//which started before getting the tank readings //4.0.20.52 TD 63661
			/*****************/			
			//ReSetAccumulatedDeliveryEmulationSales();

			SERVER_INFO  cLogInfo;  //4.0.8.500
			m_cServerInfo.GetInfo(cLogInfo);
			
			strLog.Format("Delivery: DoAutomaticEmulationDelivery: DES_UNLOCK state. Delivery Emulation Status: %d, Delivery Emulation Process: %d, lockStatus: %d, byRequiredMaintenanceProcess: %d ", cLogInfo.byDeliveryEmulationStatus, cLogInfo.byDeliveryEmulationProcess, cLogInfo.lockStatus, cLogInfo.byRequiredMaintenanceProcess);
			m_cLogger.LogMsg(strLog);			
			//@@@
			//If the forecourt is unlocked now we can switch back to idle state - the process is finished 
			if(UNLOCK == m_cServerInfo.GetServerStatus()) //4.0.13.505
			{
				//@@@ 4.0.5.30							
			    strLog.Format("Delivery: DoAutomaticEmulationDelivery: DES_UNLOCK state, SERVER IS UNLOCKED. Delivery Emulation Status: %d, Delivery Emulation Process: %d , lockStatus: %d, byRequiredMaintenanceProcess: %d", cLogInfo.byDeliveryEmulationStatus, cLogInfo.byDeliveryEmulationProcess, cLogInfo.lockStatus, cLogInfo.byRequiredMaintenanceProcess);
			    m_cLogger.LogMsg(strLog);			
				
				if(!SetDeliveryFlags(DES_IDLE, m_cServerInfo.GetDeliveryEmulationProcessType(), nErrorRetrieved))
					m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: call to SetDeliveryFlags() function failed");
				else
					bWasUnlockCommandSet = FALSE;
			}
			else
			{
				//If we haven't unlocked the forecourt we'll do it - and only once of course
				if(!bWasUnlockCommandSet)
				{
					
				    strLog.Format("Delivery: DoAutomaticEmulationDelivery: Requesting to Unlock Forecourt");
					m_cLogger.LogMsg(strLog);
					
					m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_UNLOCK);
				    
					SERVER_INFO rec;
					m_cServerInfo.GetInfo(rec);
					strLog.Format("Delivery: DoAutomaticEmulationDelivery: After Request to Unlock Forecourt. Delivery Emulation Status: %d, Delivery Emulation Process: %d , lockStatus: %d, byRequiredMaintenanceProcess: %d", rec.byDeliveryEmulationStatus, rec.byDeliveryEmulationProcess, rec.lockStatus, rec.byRequiredMaintenanceProcess);
					m_cLogger.LogMsg(strLog);			
					
					bWasUnlockCommandSet = TRUE;
				}
			}
			break;
				
		default: 
			//Invalid States
			m_cLogger.LogMsg("Delivery: DoAutomaticEmulationDelivery: Invalid value for m_cInfo.byDeliveryEmulationStatus. Transferring to default statuses");
			//4.0.5.41
			//Error in data - transferring back to default statuses:
			m_cServerInfo.ClearDeliveryEmulationFlags();

			break;
	}
}
//Udi 4.0.5.24 End

void CServerMain::CheckShiftChange(BOOL bForceNonLock)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	BOOL bInLoop = TRUE;

	while(bInLoop)
	{
		bInLoop = FALSE;

		switch(m_cServerInfo.GetShiftChangeStatus())
		{
			case CHANGE_START:
			{						
				m_cServerInfo.SetRequiredShiftProcessFlags(TRUE);
				SetShiftChangeState(CHANGE_IN_PROGRESS);
				if(LOG_BASIC_FLOW_CONTROL)
				{
					m_cLogger.LogMsg("Shift Change Started ! ");
				}
				break;
			}

			case CHANGE_IN_PROGRESS:							
			{
				if (!m_cServerInfo.GetRequiredShiftProcessFlags())
				{
					SetShiftChangeState(CHANGE_DONE);					
				}
				else if(LOG_BASIC_FLOW_CONTROL)
				{
					//m_cLogger.LogMsg("Shift Change In Progress ! ");
				}
				break;
			}

			case CHANGE_DONE:
			case CHANGE_WAIT_NEXT:
			{
				SHIFT_REC sRec;
				memset(&sRec,0,sizeof(SHIFT_REC));
				int iFound = FindNextShiftTime(&sRec);	
				
				
				SYSTEMTIME st;			
				GetLocalTime(&st);
				CTime	cCurTime(st);
				CTime	cNextTime(sRec.cStartTime);
				
				if (iFound)
				{

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str;									   
						str.Format("^^^ SHIFT ^^^ Next Shift Start Time    : %02ld-%02ld  %02ld:%02ld:%02ld",cNextTime.GetMonth(),cNextTime.GetDay(), cNextTime.GetHour(),cNextTime.GetMinute(),cNextTime.GetSecond());
						_LOGMSG.LogMsg(str);
					}

					if ( cCurTime >= cNextTime )
					{
						SetCurrentShift(&sRec);						
						NewActiveShiftNumber();	
						
						//4.0.3.52
						if ((m_cServerInfo.GetServerReservation() & MAINTENANCE) && ((m_cServerInfo.GetServerStatus() == LOCKED)))
						{
							CString sTableName;
							sTableName = "Shifts\\";
							if(GetShiftMode() == SHIFT_MODE_SINGLE)
							{
								sTableName += "Day8\\Shift1";
							}
							else
							{
								
								sTableName += "Day";
								char sNumber[8];
								memset(sNumber,0,sizeof(sNumber));
								sprintf_s(sNumber, _countof(sNumber),"%d",sRec.cStartTime.wDayOfWeek + 1);    //4.0.31.0
								sTableName += sNumber;
								sTableName += "\\Shift";
								memset(sNumber,0,sizeof(sNumber));
								sprintf_s(sNumber, _countof(sNumber),"%d",sRec.lNumber);
								sTableName += sNumber;
							}

							_LOGMSG.LogMsg(" Set shift while the system is  reserverd to Maintenance");							
							SetServerLockStatus(UNLOCK);							
							//m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "LockForeCourt",(DWORD)1); //4.0.31.0
						}
							
						SQLPumpSrvFile.SaveShiftInfo();

						
						if(bForceNonLock)
						{
							m_cServerInfo.SetShiftLockFlags(FALSE);
						}
						else
						{
							DWORD dwLock;
							m_cParam.LoadParam("GeneralParam", "ShiftLock",&dwLock,(DWORD)1, FALSE);

							if(dwLock || sRec.bLockShiftIgnorCurrentShift) //4.0.5.39
								m_cServerInfo.SetShiftLockFlags(TRUE);
							else
								m_cServerInfo.SetShiftLockFlags(FALSE);

						}

						SetShiftChangeState(CHANGE_START);
						bInLoop = TRUE;
					}
					else
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							m_cLogger.LogMsg("Shift Change done, waiting for next shift time to arrive ! ");
						}						
					}
				}
				else if(LOG_BASIC_FLOW_CONTROL)
				{
					m_cLogger.LogMsg("Shift Change done, no news ! ");					

				}
				break;
			}

			default:
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					m_cLogger.LogMsg("Shift Change unstable state !!! ");
				}
				break;
			}			
		}
	}
}

void CServerMain::CheckPriceChange__()
{
	__try
	{
		CheckPriceChange();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckPriceChange")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckPriceChange()", LOG_LEVEL_0);	

		exit(1);
	}   

}

void CServerMain::CheckPriceChange()
{
//	m_cLogger.LogLocationIn("CheckPriceChange()");
	
	BOOL bInLoop = TRUE;

	while(bInLoop)
	{
		bInLoop = FALSE;
		//4.0.8.500 switch(m_cInfo.lPriceChangeState)
		switch(m_cServerInfo.GetPriceChangeState())
		{
			case CHANGE_START:
			{
				CString sMsg("Price Change Started ! ");
				
				m_cServerInfo.SetRequiredPriceChangeFlags(TRUE);
				SetPriceChangeState(CHANGE_IN_PROGRESS);
				//CR_475695_Start
				if (TRUE == m_cPriceChangeFlags.IsRequiredTotals())						
				{
					m_cPriceChangeFlags.SetPriceChangelPumpTotalsRequestState(PChange_TOTALS_REQUEST_STARTED);
					sMsg.Append("Pump totals required.");
				}

				if(LOG_BASIC_FLOW_CONTROL)
				{
					m_cLogger.LogMsg( sMsg );
				}
				break;
			}

			case CHANGE_IN_PROGRESS:
			{
				//4.0.8.500if(m_cInfo.bRequiredPriceChange == 0)
				if (m_cServerInfo.GetRequiredPriceChangeFlags() == 0 )
				{
					// 14/11/00
					// Update the field "PriceChangeDone", and changing the Price Change State
					// to CHANGE_DONE was moved to the function PriceChangeProcess, just after
					// all the pump were unlocked.
					// I left the calls here, because they make no harm.
					//4.0.8.501m_cParam.SaveParam("GeneralParam", "PriceChangeDone",(DWORD)1);
					m_cPriceChangeFlags.SetPriceChangeStatus(1); //4.0.8.501
					SetPriceChangeState(CHANGE_DONE);
				}
				else if(LOG_BASIC_FLOW_CONTROL)
				{
					// m_cLogger.LogMsg("Price Change In Progress ! ");
				}
				break;
			}

			case CHANGE_DONE:
				{

					m_cPriceChangeFlags.SetPriceChangelPumpTotalsRequestState(PChange_NO_TOTALS_REQUEST);

					//4.0.27.20 147183 - stop process if we are waiting for commit
					if(m_cServerInfo.IsPendingCommitPriceChangeWithIntegrityProcess())
					{
						break;
					}

				}
			case CHANGE_WAIT_NEXT:
			{
				DWORD dwTmp;
				//4.0.8.501m_cParam.LoadParam("GeneralParam", "PriceChangeDone",&dwTmp,(DWORD)1, FALSE);
				dwTmp = m_cPriceChangeFlags.GetPriceChangeStatus(); //4.0.8.501
				SZ_TAG_SYSTEMTIME	szTagTime;
				szTagTime.sNull = 0;			
				//4.0.8.5001m_cParam.LoadParam("GeneralParam", "PriceChangeTime",(char *)&szTagTime,sizeof(szTagTime),"",FALSE);
				m_cPriceChangeFlags.GetPriceChangeDate(szTagTime);

				SYSTEMTIME changeTime;
				Tag2SystemTime(&szTagTime.sTime,&changeTime);

				SYSTEMTIME systime;
				GetLocalTime(&systime);
				CTime	cCurTime(systime);
				CTime	cChangeTime(changeTime);

				// not done !
				if((dwTmp == 0)&&( cCurTime > cChangeTime  )) 
				{					
					DWORD dwLock;
					m_cParam.LoadParam("GeneralParam", "PriceChangeLock",&dwLock,(DWORD)1, FALSE);	
//4.0.8.500
//					if(dwLock) 
//						m_cInfo.bPriceChangeLock = 1;
//					else
//						m_cInfo.bPriceChangeLock = 0;
//
					if(dwLock) 
						m_cServerInfo.SetLockForecourtOnPriceChangeFlags(TRUE);
					else
						m_cServerInfo.SetLockForecourtOnPriceChangeFlags(FALSE);

					if (_Module.m_server.IsInOriginalPriceChangeProcess())      //RFUEL-696  
						m_cServerInfo.SetWaitForPriceChangeAckFlags(TRUE,TRUE); //4.0.9.503
					SetPriceChangeState(CHANGE_START);
					bInLoop = TRUE;
				}
				// if done and 
				else if ( cCurTime < cChangeTime  )
				{
					if(dwTmp == 1)
					{
					 //4.0.8.501	m_cParam.SaveParam("GeneralParam", "PriceChangeDone",(DWORD)0);
						m_cPriceChangeFlags.SetPriceChangeStatus(0); //4.0.8.501						
					}

					//4.0.8.500 if(m_cInfo.lPriceChangeState != CHANGE_WAIT_NEXT)							
					if(m_cServerInfo.GetPriceChangeState() != CHANGE_WAIT_NEXT)							
						SetPriceChangeState(CHANGE_WAIT_NEXT); 				
					
				}

				// 4.0.8.50
				//if(LOG_BASIC_FLOW_CONTROL)
				//{
				//	//4.0.8.500 if(m_cInfo.lPriceChangeState != CHANGE_WAIT_NEXT)
				//	
				//	if(m_cServerInfo.GetPriceChangeState() != CHANGE_WAIT_NEXT)
				//	{
				//		m_cLogger.LogMsg("Price Change Done , no news ! ");
				//	}
				//}

				break;
			}
		}						
	}

//	m_cLogger.LogLocationOut("CheckPriceChange()");
}

// return 1 if found 
// return 0 if not found (in this case default generated
int CServerMain::FindCurrentShift(SHIFT_REC * pShiftRec)
{	
	int iRetNum  = 1; // found.
	SYSTEMTIME st;
	BOOL bValidEntry;
	GetLocalTime(&st);
	CTime	cCurTime(st);
	CTime	cCurrentShiftTime;
	SYSTEMTIME cCurrentShiftStartTime;

	CString str("Shifts\\");
	char sNumber[2];

	if(m_dwShiftMode == SHIFT_MODE_SINGLE)
	{
		str += "Day8\\Shift";
	}
	else
	{
		str += "Day";		
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%1d", st.wDayOfWeek+1);
		str += sNumber;
		str += "\\Shift";
	}

	CString sEntry;
	int iCurrentShiftNumber = 0;	
	for (int i = 1; i<100; i++)
	{
		if((m_dwShiftMode == SHIFT_MODE_SINGLE) && (i>1))
			break;

		sEntry = str;
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%d",i);
		sEntry += sNumber;	

		bValidEntry = m_cParam.CheckValidEntry((char *)((LPCTSTR)sEntry));
		if(bValidEntry)
		{
			SZ_TAG_SYSTEMTIME szStartTime;
			szStartTime.sNull = 0;
			memset (&szStartTime,0,sizeof(SZ_TAG_SYSTEMTIME));
			if(!m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "StartTime",(char *)&szStartTime,sizeof(SZ_TAG_SYSTEMTIME),"",FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE))  //4.0.8.503
			{
				SYSTEMTIME cStartTime;
				Tag2SystemTime(&szStartTime.sTime,&cStartTime);

				//4.0.12.210
				if(m_dwShiftMode != SHIFT_MODE_SINGLE)
				{
					cStartTime.wDay = st.wDay;
					cStartTime.wMonth = st.wMonth;
					cStartTime.wYear = st.wYear;
					SystemTime2Tag(&cStartTime,&szStartTime.sTime);
					m_cParam.SaveParam((char *)((LPCTSTR)sEntry), "StartTime",(char *)&szStartTime,FALSE,0,0,0,TRUE);

				}


				CTime cShiftStartTime(cStartTime);

				if (cCurTime >= cShiftStartTime )
				{
					//4.0.12.210
					if (m_dwShiftMode != SHIFT_MODE_SINGLE)
					{
						//Check first if we not already process that shift
						SHIFT_REC	sCurRec;
						GetCurrentShift(&sCurRec);
						CTime cCurShiftStartTime(sCurRec.cStartTime);

						if(cCurShiftStartTime < cShiftStartTime) // different shift 4.0.25.503 144870
						{
							cCurrentShiftStartTime = cStartTime;
							iCurrentShiftNumber = i;					
						}
						else
						{
							cCurrentShiftStartTime = sCurRec.cStartTime; //4.0.25.503 144870

						}
					}
					else
					{
						cCurrentShiftStartTime = cStartTime;
						iCurrentShiftNumber = i;					
					}
				}
				else
					break;
			}			
			else 
				break;				
		}
		else
			break;
	}

	// get old information
	GetCurrentShift(pShiftRec);

	if(iCurrentShiftNumber != 0)
	{
		// update information 
		sEntry = str;
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%d",iCurrentShiftNumber);
		sEntry += sNumber;

		pShiftRec->lNumber = iCurrentShiftNumber;		
		DWORD dwTmp = 0;
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ReadPumpTotals",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bDoPumpTotalsReading = (BOOL) dwTmp;
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ReadTanks",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bDoTankReading = (BOOL) dwTmp;		
		pShiftRec->cStartTime  = cCurrentShiftStartTime;

		//4.0.3.60 Start
		m_cParam.LoadParam((LPCSTR)sEntry , "ReconcileTankSrv" , &dwTmp , (DWORD)0 , FALSE);
		pShiftRec->byReconcileTankSrv = (BYTE)dwTmp;
		//4.0.3.60 End

		// 2.9.2.1 start 
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "LockForeCourt",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bLockPumpAtEndShift = (BOOL)dwTmp;			
		// 2.9.2.1 end

		//4.0.3.39
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ForceShiftOLA",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->byForceShiftOLA = (BYTE)dwTmp;	
		//4.0.10.505
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ShiftLockDuringProcess",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bLockShiftDuringProcess = (BYTE)dwTmp;	
		
		//4.0.5550.1504
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "DataBaseMaintenance",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bDataBaseMaintenance = (BYTE)dwTmp;			

		//4.0.26.508 TD 146575
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ExportSiteConfig", &dwTmp, (DWORD)0, FALSE);
		pShiftRec->bExportSiteConfiguration = (BYTE)dwTmp;
		//CR_475695_Start
		m_cParam.LoadParam((char *)((LPCTSTR)sEntry), "ShiftEOD",&dwTmp,(DWORD)0,FALSE);
		pShiftRec->bShiftEOD = (BYTE)dwTmp;
		//CR_475695_End
		iRetNum = 1; // found
	}
	else
	{
		pShiftRec->lNumber = 1;		
		pShiftRec->bDoTankReading = FALSE;
		pShiftRec->bDoPumpTotalsReading = FALSE;
		// 2.9.2.1 start 
		pShiftRec->bLockPumpAtEndShift  = FALSE; 
		// 2.9.2.1 end 

		pShiftRec->byForceShiftOLA  =0;
		pShiftRec->bLockShiftIgnorCurrentShift =0; // 4.0.5.39

		pShiftRec->cStartTime  = st;		
		iRetNum = 0; // not found
	}
	return iRetNum;
}

// return 1 if found 
// return 0 if not found - no change 
int CServerMain::FindNextShiftTime(SHIFT_REC * pShiftRec)
{

	int iRetNum;
	SHIFT_REC	sRec;

	if(FindCurrentShift(&sRec))
	{
		CTime		cFoundShiftStartTime(sRec.cStartTime);

		SHIFT_REC	sCurRec;
		GetCurrentShift(&sCurRec);
		CTime cCurShiftStartTime(sCurRec.cStartTime);




//		CString str;
//		str = "Current shift start time - ";
//		str += cCurShiftStartTime.Format("%H:%M:%S");
//		str += " And found shift start time - ";
//		str += cFoundShiftStartTime.Format("%H:%M:%S");
//		if(LOG_BASIC_FLOW_CONTROL)
//		{
//			m_cLogger.LogMsg(str);
//		}
		
		
		if(cCurShiftStartTime == cFoundShiftStartTime) // same shift
		{
			// try to find next
			iRetNum = 0;
		}
		else if (cCurShiftStartTime > cFoundShiftStartTime)  //4.0.7.504
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{				
				CString str;
				str.Format("Set Shift date corrupted, The current shift date is %02ld-%02ld  %02ld:%02ld:%02ld bigger then target date  %02ld-%02ld  %02ld:%02ld:%02ld, update the current shift date" , 
					cCurShiftStartTime.GetMonth(),cCurShiftStartTime.GetDay(), cCurShiftStartTime.GetHour(),cCurShiftStartTime.GetMinute(),cCurShiftStartTime.GetSecond() ,
					cFoundShiftStartTime.GetMonth(),cFoundShiftStartTime.GetDay(), cFoundShiftStartTime.GetHour(),cFoundShiftStartTime.GetMinute(),cFoundShiftStartTime.GetSecond() );
				_LOGMSG.LogMsg(str);
			}

			CString sTableName;
			sTableName = "Shifts\\";
			if(GetShiftMode() == SHIFT_MODE_SINGLE)
			{
				SZ_TAG_SYSTEMTIME szTagTime;
				SYSTEMTIME systime;					
				szTagTime.sNull = 0;

				cCurShiftStartTime.GetAsSystemTime(systime);
				SystemTime2Tag(&systime,&szTagTime.sTime);
				sTableName += "Day8\\Shift1";
				m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "StartTime",(char *)&szTagTime,TRUE,0,0,0,TRUE);			
				iRetNum = 0;
			}
		    else
			{
				//4.0.12.211
				//Set the new shift anyway
				*pShiftRec = sRec;
				iRetNum = 1;		

			}

		}

		else // current shift time changed 
		{ 
			if(LOG_BASIC_FLOW_CONTROL)
			{
				m_cLogger.LogMsg("^^^ SHIFT ^^^ Shift time changed !");
				CString str;
				str.Format("^^^ SHIFT ^^^ Current Shift Start Time : %02ld-%02ld  %02ld:%02ld:%02ld",cCurShiftStartTime.GetMonth(),cCurShiftStartTime.GetDay(), cCurShiftStartTime.GetHour(),cCurShiftStartTime.GetMinute(),cCurShiftStartTime.GetSecond());
				_LOGMSG.LogMsg(str);
			}

			*pShiftRec = sRec;
			iRetNum = 1;		
		}
	}
	else 
		iRetNum = 0; // not found

	return iRetNum;
}

long CServerMain::GetTankReadIndex()
{
	return (long)m_dwTankReadIndex;
}

long CServerMain::GetDeliveryIndex()
{
	return (long)m_dwDeliveryIndex;
}

long CServerMain::GetAlarmIndex()
{
	return (long)m_dwAlarmIndex;
}

long CServerMain::GetCarWashIndex()
{
	return (long)m_dwCarWashIndex;
}

long CServerMain::GetTotalIndex()
{
	return (long)m_dwTotalIndex;
}

//4.0.13.500
void CServerMain::IncreaseSeverityAlarmsCount()
{
	(long)m_dwSeverityAlarmsCount++;
}

//4.0.13.500
void CServerMain::DecreaseSeverityAlarmsCount()
{
	(long)m_dwSeverityAlarmsCount--;
	if (m_dwSeverityAlarmsCount < 0)
		m_dwSeverityAlarmsCount = 0;
}

//4.0.13.500
void CServerMain::ResetSeverityAlarmsCount()
{
	m_dwSeverityAlarmsCount = 0;
}

BOOL CServerMain::PumpNotInWorkingState(long lPumpNumber)
{
	BOOL bRetVal;

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	if( (m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() == OUT_OF_SERVICE) ||
		(m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() == UNKNOWN_STATUS) ||
		(m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() == COMMS_TERMINATED) )
		bRetVal = TRUE;
	else
		bRetVal = FALSE;

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------

	return bRetVal;
}

long CServerMain::GetShiftMode()
{
	return (long)m_dwShiftMode;
}


void CServerMain::CheckDeliveryAndTank()
{
	if(LOG_BASIC_FLOW_CONTROL)
	{	
		CString str;
		str.Format("Send Commands : GET_TANK_READING, GET_DELIVERY_REPORT (periodic tank and delivery checking)");
		m_cLogger.LogMsg(str);
	}

	CMD_STRUCT_TANK_READING cmdInfo;
	cmdInfo.lStatus = TANK_STATUS_BUSY; // doing tank read at busy station.
	SetCommand(CMD_GET_TANK_READING, SERVER_POS_NUMBER, 0,&cmdInfo,sizeof(CMD_STRUCT_TANK_READING)); // 0 - All tanks.
	SetCommand(CMD_GET_DELIVERY_REPORT, SERVER_POS_NUMBER, 0); // 0 - All tanks.
}



void CServerMain::CheckUnpaidTimeOut__()
{
	__try
	{
		CheckUnpaidTimeOut();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckUnpaidTimeOut")) //4.0.15.450
	{
		
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckUnpaidTimeOut()", LOG_LEVEL_0);	

		exit(1);
	}   
}


//4.0.9.509
//we add also here check to CheckAutoReconcile 
//instead of the methods in gci 
void CServerMain::CheckUnpaidTimeOut()
{
	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	CTime cCurTime = CTime::GetCurrentTime();
	CTimeSpan ts;

	for( int p = 0; p < m_lLastValidPump; p++)  //4.0.0.79
	{
		CPumpStatus stat = m_cPumpArray[p].GetStat();
		long lPumpMisc = stat.GetMisc();
		BOOL bSetPumpTimeOutFlag    = FALSE;			

		if(m_cPumpArray[p].UnpaidTransactions() || m_cPumpArray[p].AcceptedTransactions()) //4.0.13.500
		{			
			CPumpTransact trs;
			int iArraySize = m_cPumpArray[p].GetTrsArraySize();
		
			for (int i=0; i<iArraySize; i++)
			{
				m_cPumpArray[p].GetTrsByIndex (i,&trs);
				long lTrsMisc			= trs.m_lMisc;
				BOOL bSetTrsTimeOutFlag	= FALSE;			
				BOOL bChange = TRUE;

				if(trs.GetStatus() == UNPAID)
				{ 
					if(!trs.GetOnOffer())
					{
						if(cCurTime > trs.GetTime())
						{
							ts = cCurTime - trs.GetTime();				
							if(ts.GetTotalSeconds() >= (LONG)m_dwPAKAutoReconcileTimer)
							{
								if(CheckActivityPAKAutoReconcile(p+1,trs))
								{
									CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);				
									if(LOG_BASIC_FLOW_CONTROL)
									{	
										CString str;
										str.Format("CheckAutoReconcile:: Change trans from  unpiad to paid");
										_LOGMSG.LogMsg(p+1,LOG_PUMP,str);	
									}
								}
							}	
						}
					}
					if(lTrsMisc & MISC_SUPPRESSED_UNPAID_TRS_TIMEOUT)
					{
						bChange = FALSE;
					}

					//2.9.1.1
					if ((m_dwSuppressedDriveoffTimeout) &&
						(lTrsMisc & MISC_SUPPRESSED_UNPAID_TRS_TIMEOUT))
					{
						if(!trs.GetOnOffer())
						{
							if(cCurTime > trs.GetTime())
							{
								CTimeSpan tsSuppressesd;
								long lSuppressesd = 0;

								tsSuppressesd = cCurTime  - m_cPumpArray[p].GetTimeSuppressedDriveoffTimeout(i);				
									
								lSuppressesd = (long)tsSuppressesd.GetTotalSeconds();

								if(tsSuppressesd.GetTotalSeconds() >= (LONG)m_dwSuppressedDriveoffTimeout)
								{
									//bChange = TRUE;
									
									//lTrsMisc -=  (MISC_SUPPRESSED_UNPAID_TRS_TIMEOUT + MISC_UNPAID_TRS_TIMEOUT);
									lTrsMisc &= MISC_NOT_SUPPRESSED_UNPAID_TRS_TIMEOUT;
									trs.m_lMisc = lTrsMisc;				// Trs Level 	
									m_cPumpArray[p].SetTrsByIndex(i,&trs,FALSE);

									if(LOG_BASIC_FLOW_CONTROL)
									{	
										CString str;
										str.Format("CheckUnpaidTimeOut:: Remove Suppressed DriveOff TimeOut Pump (%d) Trs %d  Seconds=(%ld)",p+1, trs.m_lNumber , ((LONG)m_cPumpArray[p].GetUnpaidTrsTimeOut() + (LONG)m_dwSuppressedDriveoffTimeout));
										m_cLogger.LogMsg(p+1,LOG_PUMP,str);				
									}

									m_cPumpArray[p].SetTimeSuppressedDriveoffTimeout(i,cCurTime);
								}
							}	
						}
					}

					if(bChange) 
					{
						if(!trs.GetOnOffer())
						{
							if(cCurTime > trs.GetTime())
							{
								ts = cCurTime - trs.GetTime();				
								if(ts.GetTotalSeconds() >= (LONG)m_cPumpArray[p].GetUnpaidTrsTimeOut())
								{
									bSetPumpTimeOutFlag  = TRUE; //4.0.26.506 157073
									if ((trs.m_lMisc & MISC_TRS_AUTH_WITH_FAILED_ANPR) || (trs.m_lMisc & MISC_TRS_BLOCKED_ANPR)) //4.0.26.505 157073
									{
										bSetTrsTimeOutFlag = FALSE; //4.0.26.506 157073

									}
									else
									{
										bSetTrsTimeOutFlag = TRUE; //4.0.26.506 157073
									}
								}
							}	
						}

						if(bSetTrsTimeOutFlag)
						{
							if(!(lTrsMisc & MISC_UNPAID_TRS_TIMEOUT))
							{
								lTrsMisc |= MISC_UNPAID_TRS_TIMEOUT;
								trs.m_lMisc = lTrsMisc;				// Trs Level 	
								m_cPumpArray[p].SetTrsByIndex(i,&trs,FALSE);

								if(LOG_BASIC_FLOW_CONTROL)
								{	
									CString str;
									str.Format("CheckUnpaidTimeOut:: Trs %d, Misc %d, Seconds = %d", trs.m_lNumber,lTrsMisc,ts.GetTotalSeconds() );
									m_cLogger.LogMsg(p+1,LOG_PUMP,str);				
								}
							}
							
							// 2.9.1.1	
							m_cPumpArray[p].SetTimeSuppressedDriveoffTimeout( i ,cCurTime); //4.0.2.38
						}
						else
						{
							if (lTrsMisc & MISC_SUPPRESSED_UNPAID_TRS_TIMEOUT)
							{
								if(lTrsMisc & MISC_UNPAID_TRS_TIMEOUT)
								{
									lTrsMisc &= MISC_NOT_UNPAID_TRS_TIMEOUT;
									trs.m_lMisc = lTrsMisc;				// Trs Level 	
									m_cPumpArray[p].SetTrsByIndex(i,&trs,FALSE);
								}
							}
						}
					}
				}

				//4.0.13.500
				CheckPrPTimerForTrs(trs,p+1);

			} // End of trs Loop 

			if(bSetPumpTimeOutFlag)
			{
				if(!(lPumpMisc & MISC_UNPAID_TRS_TIMEOUT))
				{
					_LOGMSG.LogMsg("GCI::CheckUnpaidTimeOut add trs flag MISC_UNPAID_TRS_TIMEOUT");//Amram remove
					lPumpMisc |= MISC_UNPAID_TRS_TIMEOUT;
					stat.SetMisc(lPumpMisc);			// Pump Level 
					m_cPumpArray[p].SetStat(stat);	
				}
			}
			else
			{
				if(lPumpMisc & MISC_UNPAID_TRS_TIMEOUT)
				{
					lPumpMisc &= MISC_NOT_UNPAID_TRS_TIMEOUT;
					stat.SetMisc(lPumpMisc);			// Pump Level
					m_cPumpArray[p].SetStat(stat);					
				}
			}
		}
		else 
		{
			if(lPumpMisc & MISC_UNPAID_TRS_TIMEOUT)
			{
				lPumpMisc &= MISC_NOT_UNPAID_TRS_TIMEOUT;
				stat.SetMisc(lPumpMisc);			// Pump Level
				m_cPumpArray[p].SetStat(stat);						
			}			
		}
	}

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
}


//4.0.17.20 - TD 26384
void CServerMain::CheckAndReserveTimeOut__()
{
	__try
	{
		CheckAndReserveTimeOut();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckAndReserveTimeOut")) //4.0.15.450
	{

		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckAndReserveTimeOut()", LOG_LEVEL_0);	

		exit(1);
	}
}

//4.0.17.20 - TD 26384
void CServerMain::CheckAndReserveTimeOut()
{
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	CTime cCurTime = CTime::GetCurrentTime();
	CTimeSpan ts;
	CString str;
	long lRtc;

	for( int p = 0; p < m_lLastValidPump; p++) 
	{
		CPumpTransact trs;
		int iArraySize = m_cPumpArray[p].GetTrsArraySize();
		CPumpStatus stat = m_cPumpArray[p].GetStat();
		long lMisc = stat.GetMisc();
		BOOL bFoundPAKTimeout = FALSE;

		//Check PAK trs
		if(lMisc & MISC_PUMP_CHECK_AND_RESERVE)
		{
			if(cCurTime > stat.GetTime())
			{
				ts = cCurTime - stat.GetTime();
				if(ts.GetTotalSeconds() >= (LONG)m_dwCheckAndReserveTimeOut)
				{	
					if(LOG_BASIC_FLOW_CONTROL)
						_LOGMSG.LogMsg(p+1,LOG_PUMP, "CheckAndReserve got to timeout (PAK)");

					bFoundPAKTimeout = TRUE;
				} 
			}
		}
		
		//if (!bFoundPAKTimeout)
		//{
			for (int i=0; i<iArraySize; i++)
			{
				m_cPumpArray[p].GetTrsByIndex (i,&trs);
				long lTrsMisc			= trs.m_lMisc;
				
				if((lTrsMisc & MISC_PUMP_CHECK_AND_RESERVE) && (trs.GetStatus() == WAIT_AUTH)) //Check PrePay trs
				{ 
					if(cCurTime > trs.GetTime())
					{
						ts = cCurTime - stat.GetTime()/*trs.GetTime()*/;
						if(ts.GetTotalSeconds() >= (LONG)m_dwCheckAndReserveTimeOut)
						{	
							if(LOG_BASIC_FLOW_CONTROL)
								_LOGMSG.LogMsg(p+1,LOG_PUMP, "CheckAndReserve got to timeout (PrePay)");

							long lRc = WideRemoveTrs(&trs,&lRtc);

							if(lRc && LOG_BASIC_FLOW_CONTROL)
							{
								str.Format("Failed to execute WideRemoveTrs: retCode=%ld, trs number=%ld", lRc, trs.m_lNumber);
								_LOGMSG.LogMsg(p+1, LOG_PUMP, str);
							}
							
							break;
						}
					}
				}

			} // End of trs Loop 
		//}

		if (bFoundPAKTimeout)
		{
			lMisc &= MISC_NOT_PUMP_CHECK_AND_RESERVE;	// remove the misc

			//stat.SetStatus(READY);
			stat.SetMisc(lMisc);
			//stat.SetRes(NULL_RES, NULL_RES_EXT);
			m_cPumpArray[p].SetStat(stat);
		}
	}
}


void CServerMain::CheckDispensingTimeOut__()
{
	__try
	{
		CheckDispensingTimeOut();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckDispensingTimeOut")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckDispensingTimeOut()", LOG_LEVEL_0);	

		exit(1);
	}
}


void CServerMain::CheckDispensingTimeOut()
{

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	CTime cCurTime = CTime::GetCurrentTime();
	CTimeSpan ts;

	for( int p = 0; p < m_lLastValidPump; p++)  //4.0.0.79
	{
		CPumpStatus stat = m_cPumpArray[p].GetStat();
		long lMisc = stat.GetMisc();
		
		// Check if Dispensing PAK
		if(stat.GetStatus() == DISPENSING)
		{
			BOOL bSetTimeOutFlag    = FALSE;
			CPumpTransact trs;
			m_cPumpArray[p].GetCurrentTrs(&trs);

//			if(LOG_BASIC_FLOW_CONTROL)
//			{	
//				CString str;
//				str.Format("Checking Dispensing Timeout:: Pump (%d) ,Misc %d, (Trs %d %02d:%02d), (%02d:%02d) ",p+1,lMisc, trs.m_lNumber,trs.GetTime().GetMinute(),trs.GetTime().GetSecond(),cCurTime.GetMinute(),cCurTime.GetSecond());
//				m_cLogger.LogMsg(str);								
//			}

			//if((trs.m_lRoundedValue)&&(trs.GetLinkFlags() == TRS_NO_LINK))
			if((trs.m_lRoundedValue)&&(PAK_LINK_TYPE(trs.GetLinkFlags()) ||
			 ((trs.m_lRoundedValue)&&(trs.GetLinkFlags() == TRS_LINK_ATTEND))))
			{
				if(cCurTime > trs.GetTime())
				{
					ts = cCurTime - trs.GetTime();								
					if(ts.GetTotalSeconds() >= (LONG)m_cPumpArray[p].GetDispensingTimeOut())
					{
						bSetTimeOutFlag = TRUE;
					}
				}
			}

			if(bSetTimeOutFlag)
			{
				if((lMisc & MISC_DISPENSING_TIMEOUT) != MISC_DISPENSING_TIMEOUT)
				{
					lMisc |= MISC_DISPENSING_TIMEOUT;
					stat.SetMisc(lMisc);
					m_cPumpArray[p].SetStat(stat);					

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("CheckDispensingTimeOut:: Misc %d, Seconds = %d",lMisc, ts.GetTotalSeconds() );
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);								
					}
				}
			}
			else
			{
				if(lMisc & MISC_DISPENSING_TIMEOUT)
				{
					lMisc &= MISC_NOT_DISPENSING_TIMEOUT;
					stat.SetMisc(lMisc);
					m_cPumpArray[p].SetStat(stat);					
				}
			}
		}
		else // Not Dispensing PAK
		{
			if(lMisc & MISC_DISPENSING_TIMEOUT)
			{
				lMisc &= MISC_NOT_DISPENSING_TIMEOUT;
				stat.SetMisc(lMisc);
				m_cPumpArray[p].SetStat(stat);					
			}
		}
	}

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
}

void CServerMain::CheckAuthorizedTimeOut__()
{
	__try
	{
		CheckAuthorizedTimeOut();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::CheckAuthorizedTimeOut__")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::CheckAuthorizedTimeOut()", LOG_LEVEL_0);	

		exit(1);
	}   
}


// M.L 1.7.98 
void CServerMain::CheckAuthorizedTimeOut()
{
	OLA_STAT ola;
//	m_cLogger.LogLocationIn("CheckAuthorizedTimeOut()");

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	CTime cCurTime = CTime::GetCurrentTime();
	CTimeSpan ts;

	for( int p = 0; p < m_lLastValidPump; p++)   //4.0.0.79
	{
		CPumpStatus stat = m_cPumpArray[p].GetStat();
		long lMisc = stat.GetMisc();

		//4.0.19.504 - TD 47559
		//Update the timer in case of external PAP and there was OUT_OF_SERVICE
		// CR 444830
		if (((GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse()) && (stat.GetStatus() == OUT_OF_SERVICE) && (stat.GetRes() == PAY_AT_PUMP) && (stat.GetResExt() == RES_EXT_PAP_EXTERNAL || stat.GetResExt() == RES_EXT_MOBILE)) ||
			((GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse()) && (GetServerState() != SERVER_IDLE) && (stat.GetRes() == PAY_AT_PUMP) && (stat.GetResExt() == RES_EXT_PAP_EXTERNAL || stat.GetResExt() == RES_EXT_MOBILE)))
		{
			BOOL bFound = FALSE;
			CPumpTransact trs;
			bFound = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_OLA_NUMBER,&trs);
			if(bFound)
			{
				trs.UpdateTime();
				CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
			}
		}
		
		// Check if Authorized PAK
		//4.0.3.23
		// check timeout only for PAK transaction or special external PAP transactions.
//		if((stat.GetStatus() == AUTHORIZED)&&(stat.GetRes() == PAY_AT_KIOSK) && (stat.GetResExt() == NULL_RES_EXT))
		if(((stat.GetStatus() == AUTHORIZED)&&(stat.GetRes() == PAY_AT_KIOSK) && 
			(stat.GetResExt() == NULL_RES_EXT || stat.GetResExt() == RES_EXT_AUTO_AUTH)) || //4.0.13.20 
			((GetIFSFTerminalSrvInUse()) && (stat.GetStatus() == AUTHORIZED) && (stat.GetRes() == PAY_AT_PUMP) && (stat.GetResExt() == RES_EXT_PAP_EXTERNAL))) //4.0.19.504 - TD 47559
		{
			BOOL bSetTimeOutFlag    = FALSE;
			BOOL bFound = FALSE;

			CPumpTransact trs;
			if(!m_cPumpArray[p].GetCurrentTrs(&trs))
				bFound = TRUE;
			if(!bFound)
				bFound = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_NO_LINK,&trs);
			if(!bFound)    //4.0.1.34
				bFound = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_ATTEND,&trs);
			if(!bFound && GetIFSFTerminalSrvInUse() && stat.GetResExt() == RES_EXT_PAP_EXTERNAL) //4.0.19.504 - TD 47559
				bFound = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_OLA_NUMBER,&trs);

			if(bFound)
			{
				//if((trs.m_lRoundedValue == 0)&&((trs.GetLinkFlags() == TRS_NO_LINK) || (trs.GetLinkFlags() == TRS_LINK_ATTEND))) //4.0.1.34
				if((trs.m_lRoundedValue == 0) &&
					((trs.GetLinkFlags() == TRS_NO_LINK) || (trs.GetLinkFlags() == TRS_LINK_ATTEND) ||  //4.0.1.34
					((GetIFSFTerminalSrvInUse()) && (stat.GetRes() == PAY_AT_PUMP) && (stat.GetResExt() == RES_EXT_PAP_EXTERNAL) && (trs.GetLinkFlags() == TRS_LINK_OLA_NUMBER))))
				{ 
					if(cCurTime > trs.GetTime())
					{
						ts = cCurTime - trs.GetTime();								
						if(m_cPumpArray[p].GetPAKAuthorizedTimeOut())
						{
							if(ts.GetTotalSeconds() >= (LONG)(m_cPumpArray[p].GetPAKAuthorizedTimeOut()))
							{
								bSetTimeOutFlag = TRUE;
								trs.UpdateTime();
								CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
							}
						}
					}
				}
			}

			if(bSetTimeOutFlag)
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{	
					CString str;
					str.Format("CheckAuthorizedTimeOut:: Seconds = %d", ts.GetTotalSeconds() );
					m_cLogger.LogMsg(p+1,LOG_PUMP,str);								
				}

				SetCommand(CMD_STOP_PUMP, SERVER_POS_NUMBER, p+1);
			}
		}
		else if((stat.GetStatus() == AUTHORIZED)&&(stat.GetRes() == PAY_AT_PUMP) && (stat.GetResExt() == RES_EXT_FLEET)) //4.0.15.501
		{
			m_cPumpArray[p].GetOlaStat(&ola);

			if( OLA_STATE(ola.m_byState) == OLA_WAIT_REEFER)
			{
				BOOL bSetTimeOutFlag    = FALSE;
				BOOL bFound = FALSE;

				CPumpTransact trs;
				if(!m_cPumpArray[p].GetCurrentTrs(&trs))
					bFound = TRUE;
				if(!bFound)
					bFound = m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_OLA_NUMBER,&trs);

				if(bFound)
				{
					if(cCurTime > trs.GetTime())
					{
						ts = cCurTime - trs.GetTime();								
						
						if(ts.GetTotalSeconds() >= (LONG)(m_dwSecondTrsAuthTimeout))
						{
							bSetTimeOutFlag = TRUE;
							trs.UpdateTime();
							CentralUpdateTrs(p+1,trs.m_lNumber,&trs,FALSE);
						}
					}
				}

				if(bSetTimeOutFlag)
				{
					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("CheckAuthorizedTimeOut fleet Pump (%d) , Seconds = %d",p+1, ts.GetTotalSeconds() );
						m_cLogger.LogMsg(str);								
					}

					SetCommand(CMD_STOP_PUMP, SERVER_POS_NUMBER, p+1);		
				}
			}
		}
	}

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
}

BOOL CServerMain::DBConnectionAvailable() const 
{
	CPumpSrvDatabase & PumpSrvDataBase = CPumpSrvDatabase::GetInstance();
	BOOL ans = PumpSrvDataBase.IsDatabaseOpen();
	ans &= (BOOL)PumpSrvDataBase.IsDatabaseConnected();
	return ans;
}

BOOL CServerMain::IsShiftChangeInProgress()
{
	//4.0.8.500return(m_cInfo.bRequiredShiftProcess);
	return(m_cServerInfo.GetRequiredShiftProcessFlags());
}

long CServerMain::GetLimit(short nLevel,long lPumpNumber)
{
	long lValueLimit = 0;
	short nPumpLevel = nLevel;

	if(lPumpNumber)
	{
		if(nLevel == PRICE_LEVEL_DEFAULT)
			nPumpLevel = (short)(m_cPumpArray[lPumpNumber-1].GetPriceLevelDefault());
	}
	else
	{
		if(nLevel == PRICE_LEVEL_DEFAULT)
			nPumpLevel = (short)(m_cPumpArray[1].GetPriceLevelDefault());
	}
	

	switch(nPumpLevel)
	{
		case PRICE_LEVEL_DEFAULT:
		case PRICE_LEVEL_CREDIT:
			//lValueLimit = (long)m_dwCreditLimit; // 4.0.6.505
			lValueLimit = (long)m_dwCreditLimit; //
			break;
		case PRICE_LEVEL_CASH:
			lValueLimit = (long)m_dwCashLimit;	
			break;
	}

	if(PUMP_NOT_VALID(lPumpNumber))
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,"GetLimit, Pump number is invalid");	
	else
		OverwriteModeLimit(lPumpNumber ,nPumpLevel ,lValueLimit);		

	return (lValueLimit*1000);
}

long CServerMain::GetRegion()
{
	return (long)m_dwRegion ;
}

long CServerMain::GetOLAInUse()
{
	return (long)m_dwOLASrvInUse;
}

long CServerMain::OLALogDeclineReq()
{
	return (long)m_dwOLALogDeclineReq;
}

long CServerMain::OLAByController()
{
	return (long)m_dwOLAByController;
}

long CServerMain::AllowAuthOnNonRequest()
{
	return (long)m_dwAllowAuthOnNonRequest;
}

long CServerMain::GetWetStockMode()
{
	return (long)m_dwWetStockMode;
}

long CServerMain::GetWetStockInterval()
{
	return (long)m_dwWetStockInterval;
}

void CServerMain::SetReqiredModeProcess__()
{
	__try
	{
		//4.0.8.500m_cInfo.bRequiredModeProcess = 1;
		m_cServerInfo.SetRequiredModeProcessFlags(TRUE);

	}
	__except(_HANDLE_EXCEPTION("CServerMain::SetReqiredModeProcess")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::SetReqiredModeProcess()", LOG_LEVEL_0);	

		exit(1);
	}   

}

void CServerMain::SetReqiredModeProcess()
{
	//4.0.8.500 m_cInfo.bRequiredModeProcess = 1;
	m_cServerInfo.SetRequiredModeProcessFlags(TRUE);
}


void CServerMain::DoAutomaticWatchdog()
{
//	m_cLogger.LogLocationIn("DoAutomaticWatchdog()");

__try
{
	if((!m_bRcvAnyMsg) && (GetServerState() == SERVER_IDLE))
	{		
		// PumpSrv switch to offline (no controller) 
		SetServerState(SERVER_STARTUP);

		//4.0.6.507 - sending "no controller" alarm
		if(_ALARM_SRV.m_lAlarmSrvActive)//4.0.6.507
			m_cAlarm.ServerStateAlarm(SERVER_IDLE,SERVER_STARTUP);
	}

	//SetCommand(CMD_WATCHDOG,SERVER_POS_NUMBER,WATCHDOG_INTERVAL);		

	SetCommand(CMD_WATCHDOG,SERVER_POS_NUMBER,m_dwWatchdogInterval);		
	m_bRcvAnyMsg = FALSE;

	GetLocalTime(&m_tConnectionTimeOut);
}
__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticWatchdog")) //4.0.15.450
{
	// we arrive here on error only !

	if(LOG_ERROR)
		_LOGMSG.LogMsg("CServerMain::DoAutomaticWatchdog()", LOG_LEVEL_0);	

	exit(1);
}   

//	m_cLogger.LogLocationOut("DoAutomaticWatchdog()");
}

void CServerMain::DoAutomaticCheckCarWash__()
{
	//	m_cLogger.LogLocationIn("DoAutomaticCheckCarWash()");

__try
{
	DoAutomaticCheckCarWash();
}
__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticCheckCarWash")) //4.0.15.450
{
	// we arrive here on error only !

	if(LOG_ERROR)
		_LOGMSG.LogMsg("CServerMain::DoAutomaticCheckCarWash()", LOG_LEVEL_0);	

	exit(1);
}   

//	m_cLogger.LogLocationOut("DoAutomaticCheckCarWash()");
}


void CServerMain::DoAutomaticCheckCarWash()
{
	if ( m_cCarWash.CarWashEnabled() )
	{
		LONG lNextRequest;
		CAR_WASH_INFO carWashInfo;
		memset(&carWashInfo, 0, sizeof(carWashInfo));

		CTimeSpan ts;
		SYSTEMTIME systime;
		SYSTEMTIME cRequestSysTime;
		GetLocalTime(&systime);
		CTime cCurTime(systime);

		//Get the index and type, of the current request
		LONG lCurrentRequest;
		LONG lRequestType;
		m_cCarWash.GetCurrentRequest(&lCurrentRequest,&lRequestType,&cRequestSysTime);
		
		//If there is no current request, check for new one, or for cancel one.
		if ( lRequestType == CW_TYPE_NONE )
		{
			//Get the index of the next request in the list
			lNextRequest = m_cCarWash.GetRequestIndex();
			if (lNextRequest) //If there is a request at the list, change the type
			{
				lRequestType = m_cCarWash.GetRequestType();  //CW_TYPE_GENERATE; //4.0.26.501 144221
			}
			else
			{
				//Get the index of the next cancel request in the list
				lNextRequest = m_cCarWash.GetCancelRequest();
				if (lNextRequest) //If there is a request at the list, change the type
				{
					lRequestType = CW_TYPE_CANCEL;
				}
			}
		}	
		switch (lRequestType)
		{
			case CW_TYPE_GENERATE:
			case CW_TYPE_VALIDITY_CHECK: //4.0.26.501 144221
			{
				lNextRequest = m_cCarWash.GetRequestIndex();
				//Check if they are not the same, in that case sent new request (if there any)
				if ( (lNextRequest != lCurrentRequest) && (lNextRequest) )
				{
					carWashInfo.lIndexNumber = lNextRequest;
					long lRtc = IndexOperation(CAR_WASH_FILE,REC_READ, &carWashInfo);
					if(lRtc)
					{
						if(LOG_LOGIC_ERROR)
						{
							CString str;
							str.Format("DoAutomaticCheckCarWash: Read Operation for Car wash Failed !!! lRtc %d",lRtc); 
							m_cLogger.LogMsg(str, LOG_LEVEL_1);						
						}
					}
					else
					{
						carWashInfo.lRequestStatus = CW_REQ_SENT;
						long lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
						if(lRtc)
						{
							if(LOG_LOGIC_ERROR)
							{
								CString str;
								str.Format("DoAutomaticCheckCarWash: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
								m_cLogger.LogMsg(str, LOG_LEVEL_1);						
							}
						}
						else
						{
							CMD_STRUCT_CAR_WASH CmdCarWash;
							memset(&CmdCarWash, 0, sizeof(CmdCarWash));
							CmdCarWash.lSyncNumber	= carWashInfo.lIndexNumber;
							CmdCarWash.lWashProgram = carWashInfo.lProgramIndex;
							
							memcpy(CmdCarWash.carWashData.sCode, carWashInfo.sCode, sizeof(CmdCarWash.carWashData.sCode)); //4.0.26.501 144221

							if (lRequestType == CW_TYPE_GENERATE)
								SetCommand(CMD_GET_NEW_WASH_CODE, carWashInfo.lPOS,carWashInfo.lDevice,&CmdCarWash, sizeof(CmdCarWash));
							else	//4.0.26.501 144221
								SetCommand(CMD_CAR_WASH_VALIDITY, carWashInfo.lPOS,carWashInfo.lDevice,&CmdCarWash, sizeof(CmdCarWash));

							GetLocalTime(&cRequestSysTime);

							if (lRequestType == CW_TYPE_GENERATE)
								m_cCarWash.SetCurrentRequest(lNextRequest,CW_TYPE_GENERATE,&cRequestSysTime);
							else	//4.0.26.501 144221
								m_cCarWash.SetCurrentRequest(lNextRequest,CW_TYPE_VALIDITY_CHECK,&cRequestSysTime);

						}
					}
				}
				else if (!lNextRequest)
				{
					m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
				}
				else if (lNextRequest == lCurrentRequest)
				{//Response wasn't recieved yet, check timeout.
					CTime cRequestTime(cRequestSysTime);
					CTimeSpan ts = cCurTime - cRequestTime;
					if ( ts.GetTotalSeconds()  > CAR_WASH_REQUEST_TIME_OUT )
					{//We reached time out, remove the request from the list
						
						if(LOG_LOGIC_ERROR)  //4.0.3.309
						{
							CString str;
							str.Format("DoAutomaticCheckCarWash: Remove item lCurrentRequest=%ld", lCurrentRequest); 
							m_cLogger.LogMsg(str);						
						}

						carWashInfo.lIndexNumber = lNextRequest;
						long lRtc = IndexOperation(CAR_WASH_FILE,REC_READ, &carWashInfo);
						if(lRtc)
						{
							if(LOG_LOGIC_ERROR)
							{
								CString str;
								str.Format("DoAutomaticCheckCarWash: Read Operation for Car wash Failed !!! lRtc %d",lRtc); 
								m_cLogger.LogMsg(str, LOG_LEVEL_1);						
							}
						}
						else
						{
							carWashInfo.lRequestType = lRequestType; //4.0.26.501 144221
							carWashInfo.lRequestStatus = CW_REQ_RESPONDED;
							long lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
							if(lRtc)
							{
								if(LOG_LOGIC_ERROR)
								{
									CString str;
									str.Format("DoAutomaticCheckCarWash: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
									m_cLogger.LogMsg(str, LOG_LEVEL_1);						
								}
							}
							else
							{
								//Remove request from the list
								m_cCarWash.RemoveRequest();
								//Clear current request
								m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
							}
						}
					}
				}

				break;
			}
			case CW_TYPE_CANCEL:
			{
				lNextRequest = m_cCarWash.GetCancelRequest();
				//Is there a cancel request waiting?
				if (lNextRequest) 
				{
					//Check it the waiting cancel request is not being process already.
					if ( lNextRequest != lCurrentRequest)
					{
						//Make sure there is no request waiting, if there is, it get higher priority
						if ( !m_cCarWash.GetRequestIndex() )
						{
							carWashInfo.lIndexNumber = lNextRequest;
							long lRtc = IndexOperation(CAR_WASH_FILE,REC_READ, &carWashInfo);
							if(lRtc)
							{
								if(LOG_LOGIC_ERROR)
								{
									CString str;
									str.Format("DoAutomaticCheckCarWash: Read Operation for Car wash Failed !!! lRtc %d",lRtc); 
									m_cLogger.LogMsg(str, LOG_LEVEL_1);						
								}
							}
							else
							{
								carWashInfo.lRequestStatus = CW_REQ_SENT;
								long lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
								if(lRtc)
								{
									if(LOG_LOGIC_ERROR)
									{
										CString str;
										str.Format("DoAutomaticCheckCarWash: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
										m_cLogger.LogMsg(str, LOG_LEVEL_1);						
									}
								}
								else
								{
									CMD_STRUCT_CAR_WASH CmdCarWash;
									memset(&CmdCarWash, 0, sizeof(CmdCarWash));

									CmdCarWash.lSyncNumber = carWashInfo.lIndexNumber;
									CmdCarWash.lWashProgram = carWashInfo.lProgramIndex;
									CmdCarWash.lFlags = 0L;
									memcpy(CmdCarWash.carWashData.sCode, carWashInfo.sCode, sizeof(CmdCarWash.carWashData.sCode));
									SystemTime2Tag(&carWashInfo.cExpirationDate,&CmdCarWash.carWashData.sExpirationDate);

									l2a(carWashInfo.lPrice, CmdCarWash.carWashData.sPrice,sizeof(CmdCarWash.carWashData.sPrice));
									l2a(carWashInfo.lProgramIndex, CmdCarWash.carWashData.sProgram,sizeof(CmdCarWash.carWashData.sProgram));

									if(LOG_BASIC_FLOW_CONTROL)
									{
										CString str;
										str.Format("DoAutomaticCheckCarWash: Cancel wash code %.10s",carWashInfo.sCode);
										_LOGMSG.LogMsg(str);
									}
									SetCommand(CMD_CANCEL_WASH_CODE, carWashInfo.lPOS,carWashInfo.lDevice,&CmdCarWash, sizeof(CmdCarWash));
									GetLocalTime(&cRequestSysTime);
									m_cCarWash.SetCurrentRequest(lNextRequest,CW_TYPE_CANCEL,&cRequestSysTime);
								}
							}
						}
						else
						{
							m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
						}
					}
					else
					{//Response wasn't recieved yet, check timeout.
						CTime cRequestTime(cRequestSysTime);
						CTimeSpan ts = cCurTime - cRequestTime;
						if ( ts.GetTotalSeconds()  > CAR_WASH_REQUEST_TIME_OUT )
						{//We reached time out, remove the request from the list
							carWashInfo.lIndexNumber = lNextRequest;
							long lRtc = IndexOperation(CAR_WASH_FILE,REC_READ, &carWashInfo);
							if(lRtc)
							{
								if(LOG_LOGIC_ERROR)
								{
									CString str;
									str.Format("DoAutomaticCheckCarWash: Read Operation for Car wash Failed !!! lRtc %d",lRtc); 
									m_cLogger.LogMsg(str, LOG_LEVEL_1);						
								}
							}
							else
							{
								carWashInfo.lRequestType = CW_TYPE_CANCEL;
								carWashInfo.lRequestStatus = CW_REQ_RESPONDED;
								long lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
								if(lRtc)
								{
									if(LOG_LOGIC_ERROR)
									{
										CString str;
										str.Format("DoAutomaticCheckCarWash: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
										m_cLogger.LogMsg(str, LOG_LEVEL_1);						
									}
								}
								else
								{
									//Remove request from the canceled list
									m_cCarWash.RemoveCancelRequest();
									//Clear current request
									m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
								}
							}
						}
					}
				}
				else
					m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
				break;
			}
			default:
				m_cCarWash.SetCurrentRequest(0,CW_TYPE_NONE);
		}	
	}
}

/******************************************************************************
 Description:	Checking for and handling sync, setup and cold start requests
 Returns:      	
				   
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			7/10/2009   10:44		Start TD 76432 4.0.23.504

******************************************************************************/
void CServerMain::DoAutomaticCarWashGeneralReq__()
{

__try
{
	DoAutomaticCarWashGeneralReq();
}
__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticCarWashGeneralReq")) //4.0.15.450
{
	// we arrive here on error only !

	if(LOG_ERROR)
		_LOGMSG.LogMsg("CServerMain::DoAutomaticCarWashGeneralReq()", LOG_LEVEL_0);	

	exit(1);
}   

//	m_cLogger.LogLocationOut("DoAutomaticCarWashGeneralReq()");
}

void CServerMain::DoAutomaticCarWashGeneralReq()
{
	if ( m_cCarWash.CarWashEnabled() && ((m_cCarWashGeneralRequest.GetCarWashRequestStatus() == CW_REQ_OPEN) || (m_cCarWashGeneralRequest.GetCarWashRequestStatus() == CW_REQ_SENT)))
	{
		SYSTEMTIME cRequestSysTime;
		SYSTEMTIME systime;
		GetLocalTime(&systime);
		CTime cCurTime(systime);

		//Get the index and type, of the current request
		LONG lCurrentRequest;
		LONG lRequestType;
		m_cCarWashGeneralRequest.GetCurrentRequest(&lCurrentRequest,&lRequestType,&cRequestSysTime);
		

		//Response wasn't recieved yet, check timeout.
		CTime cRequestTime(cRequestSysTime);
		CTimeSpan ts = cCurTime - cRequestTime;
		if ( ts.GetTotalSeconds()  > m_cCarWashGeneralRequest.GetGeneralRequestTimeout() )
		{//We reached time out, remove the request from the list
			SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_CODAX_REQUEST_TIMEOUT);
			
			if(LOG_LOGIC_ERROR)
			{
				CString str;
				str.Format("DoAutomaticCarWashGeneralReq: General request for car wash failed after timeout!!!"); 
				m_cLogger.LogMsg(str, LOG_LEVEL_1);						
			}
			switch (lRequestType)
			{
				case CW_TYPE_SYNC_FUNC:
				case CW_TYPE_SETUP_FUNC:
				{
					m_cCarWashGeneralRequest.SetCarWashRequestStatus(CW_REQ_RESPONDED);
					m_cCarWashGeneralRequest.SetCarWashResult(CW_OPERATION_FAILED);
				}
				break;
				case CW_TYPE_COLD_START_FUNC:
				{
					m_cCarWashGeneralRequest.SetCarWashRequestStatus(CW_REQ_SENT);
				}
				break;
			}
		}
		else if (m_cCarWashGeneralRequest.GetCarWashRequestStatus() == CW_REQ_OPEN)
		{
			CMD_STRUCT_CAR_WASH CmdCarWash;
			memset(&CmdCarWash, 0, sizeof(CmdCarWash));
			CmdCarWash.lSyncNumber	= 0;
			CmdCarWash.lWashProgram = 0;
			CmdCarWash.lFlags = m_cCarWashGeneralRequest.GetCurrentCarWashRequestFlags();

			SetCommand(CMD_CAR_WASH_GENERAL_REQUEST, m_cCarWashGeneralRequest.GetPosNumber(), m_cCarWashGeneralRequest.GetDeviceNumber(),&CmdCarWash, sizeof(CmdCarWash)); //4.0.23.506
			m_cCarWashGeneralRequest.SetCarWashRequestStatus(CW_REQ_SENT);

		}
	}	
}

/***************************/
void CServerMain::DoAutomaticlCarWashClear__()
{
	//	m_cLogger.LogLocationIn("DoAutomaticlCarWashClear()");
__try
{
	DoAutomaticlCarWashClear();
}
__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticlCarWashClear")) //4.0.15.450
{
	// we arrive here on error only !

	if(LOG_ERROR)

		_LOGMSG.LogMsg("CServerMain::DoAutomaticlCarWashClear()", LOG_LEVEL_0);

	exit(1);
}   

//	m_cLogger.LogLocationOut("DoAutomaticlCarWashClear()");	
}

void CServerMain::DoAutomaticlCarWashClear()
{
	if ( m_cCarWash.CarWashEnabled() )
	{
		BOOL bFileRemoved;
		//Remove every record over 24 hour old. And in case no POS ever took
		//a record then cancel the code.
		CAR_WASH_INFO carWashInfo;
		memset(&carWashInfo, 0, sizeof(carWashInfo));

		CTimeSpan ts;
		SYSTEMTIME systime;
		GetLocalTime(&systime);
		CTime cCurTime(systime);
		
		long lRtc = IndexOperation(CAR_WASH_FILE,REC_READ_FIRST, &carWashInfo);
		while (!lRtc)
		{
			bFileRemoved = FALSE;
			CTime cLastUpdateTime(carWashInfo.cLastUpdate);
			ts = cCurTime - cLastUpdateTime;
			
			if ( ts.GetTotalHours() > 24L )
			{
				switch ( carWashInfo.lRequestStatus )
				{
					case CW_REQ_OPEN:
					{
						//Could it be that after 24 hours, the record didn't sent?
						//If so it is a serious bug, any way remove it.
						lRtc = IndexOperation(CAR_WASH_FILE,REC_DELETE, &carWashInfo);
						if(lRtc)
						{
							if(LOG_LOGIC_ERROR)
							{
								CString str;
								str.Format("DoAutomaticlCarWashClear: Delete Operation for Car wash Failed !!! lRtc %d",lRtc); 
								_LOGMSG.LogMsg(str, LOG_LEVEL_1);						
							}
						}
						else
						{
							bFileRemoved = TRUE;
							m_cCarWash.RemoveRequest(carWashInfo.lIndexNumber);
						}
						break;
					}
					case CW_REQ_SENT:
					{
						//Could it be that we are waiting to response for over 24 hours?
						//If so it is a even more serious bug then the one above, 
						//Any way try to cancel it first and only then remove.
						carWashInfo.lRequestType = CW_TYPE_CANCEL;
						carWashInfo.lRequestStatus = CW_REQ_OPEN;
						lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
						if(lRtc)
						{
							if(LOG_LOGIC_ERROR)
							{
								CString str;
								str.Format("DoAutomaticlCarWashClear: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
								_LOGMSG.LogMsg(str, LOG_LEVEL_1);						
							}
						}
						else
						{
							//Remove from the request list
							m_cCarWash.RemoveRequest(carWashInfo.lIndexNumber);
							//Add to the cancel list
							m_cCarWash.AddCancelRequest(carWashInfo.lIndexNumber);
						}
						break;
					}
					case CW_REQ_RESPONDED:
					{
						//Response was recieved, but no POS every try to get the information.
						//Therefore, if we got a code we need to cancel it, before we remove the record.
						//but if we fail to get code, then we should remove the record.
						if ( (carWashInfo.sCode[0]) && (carWashInfo.lRequestType != CW_TYPE_CANCEL) )
						{//There is a code that need to be canceled.
							carWashInfo.lRequestStatus = CW_REQ_OPEN;
							carWashInfo.lRequestType = CW_TYPE_CANCEL;
							GetLocalTime(&carWashInfo.cLastUpdate);
							lRtc = IndexOperation(CAR_WASH_FILE,REC_UPDATE, &carWashInfo);
							if(lRtc)
							{
								if(LOG_LOGIC_ERROR)
								{
									CString str;
									str.Format("DoAutomaticlCarWashClear: Update Operation for Car wash Failed !!! lRtc %d",lRtc); 
									_LOGMSG.LogMsg(str, LOG_LEVEL_1);						
								}
							}
							else
							{
								//Add to the cancel list
								m_cCarWash.AddCancelRequest(carWashInfo.lIndexNumber);
							}
						}
						else
						{//No code, remove the record.
							lRtc = IndexOperation(CAR_WASH_FILE,REC_DELETE, &carWashInfo);
							if(lRtc)
							{
								if(LOG_LOGIC_ERROR)
								{
									CString str;
									str.Format("DoAutomaticlCarWashClear: Delete Operation for Car wash Failed !!! lRtc %d",lRtc); 
									_LOGMSG.LogMsg(str, LOG_LEVEL_1);						
								}
							}
							else
							{
								bFileRemoved = TRUE;
							}

						}
						break;
					}
					case CW_REQ_CLOSE:
					{
						//The classic option, request was made, then the POS ask for response,
						//and 24 hours after that the record being remove.
						lRtc = IndexOperation(CAR_WASH_FILE,REC_DELETE, &carWashInfo);
						if(lRtc)
						{
							if(LOG_LOGIC_ERROR)
							{
								CString str;
								str.Format("DoAutomaticlCarWashClear: Delete Operation for Car wash Failed !!! lRtc %d",lRtc); 
								_LOGMSG.LogMsg(str, LOG_LEVEL_1);						
							}
						}
						else
						{
							bFileRemoved = TRUE;
						}
						break;
					}
					default:;
				}
			}
			if (bFileRemoved)
				lRtc = IndexOperation(CAR_WASH_FILE,REC_READ_FIRST, &carWashInfo);
			else
				lRtc = IndexOperation(CAR_WASH_FILE,REC_READ_NEXT, &carWashInfo);
		}
	}
}

void CServerMain::GetWetStockData__(long lMode ,long lWetStockOnDemandFlags)
{
//	m_cLogger.LogLocationIn("GetWetStockData()");
__try
{
	GetWetStockData(lMode, lWetStockOnDemandFlags);
}
__except(_HANDLE_EXCEPTION("CServerMain::GetWetStockData")) //4.0.15.450
{
	// we arrive here on error only !

	if(LOG_ERROR)
		_LOGMSG.LogMsg("CServerMain::GetWetStockData()", LOG_LEVEL_0);

	exit(1);
}   

//	m_cLogger.LogLocationOut("GetWetStockData()");
}

void CServerMain::GetWetStockData(long lMode ,long lWetStockOnDemandFlags)
{
	long lWetStockFlags = 0;
	BOOL bGetWetStockData = FALSE;
	CString cMsg;


	//Check if wet stock process or shift are currently running. 
	if (m_cServerInfo.GetWetStockFlags()  ||
		m_cServerInfo.GetRequiredShiftProcessFlags()||
		m_cServerInfo.GetMemoProcessFlags())
	{
		_LOGMSG.LogMsg("GetWetStockData Skip due to other process active. "); //4.0.15.501
		return ;
	}

	long lTankNumber;

	if(( lMode != WSM_BY_START_DELIVERY ) && ( lMode != WSM_BY_END_DELIVERY ) && (m_cServerInfo.GetDeliveryEmulationStatus() != DES_IDLE) && (m_cCommonFunction.IsDeliveryEmulationSingleTankInReadingProcess(lTankNumber)))
	{
		_LOGMSG.LogMsg("GetWetStockData, Not performing WetStock while the Delivery Emulation Process is in progress");
	}	
	else
	{
		m_cParam.LoadParam("GeneralParam", "WetStockFlags",(DWORD *)&lWetStockFlags,(DWORD)0, FALSE);
		lWetStockFlags &= WET_STOCK_ALL;
		
		switch (lMode)
		{
			case WSM_BY_INTERVAL:
				bGetWetStockData = TRUE;
				cMsg = " (WSM_BY_INTERVAL)";
				break;

			case WSM_BY_TIME:
			{
				if (lWetStockFlags)
				{
					char sTime[10];
					DWORD dwWetStockDone;
					m_cParam.LoadParam("GeneralParam", "WetStockDone",&dwWetStockDone,(DWORD)1, FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
					m_cParam.LoadParam("GeneralParam", "WetStockTime",(char *)sTime,sizeof(sTime),"",FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
					
					//Get time for getting wet stock data.
					SYSTEMTIME changeTime;
					GetLocalTime(&changeTime);
					changeTime.wHour = a2i((BYTE *)sTime,2);
					changeTime.wMinute = a2i((BYTE *)sTime+2,2);
					// 4.0.7.500
					if (strlen(sTime) >= 6)
					{
						changeTime.wSecond = a2i((BYTE *)sTime+4,2);
					}
					else 
						changeTime.wSecond = 20;
					
					//Get current time.
					SYSTEMTIME systime;
					GetLocalTime(&systime);
					
					CTime	cCurTime(systime);
					CTime	cChangeTime(changeTime);

					if((dwWetStockDone == 0)&&( cCurTime > cChangeTime  )) 
					{
						cMsg = " (WSM_BY_TIME)";
						bGetWetStockData = TRUE;
					}
					else if (cCurTime < cChangeTime)
					{
						if (dwWetStockDone)
							m_cParam.SaveParam("GeneralParam", "WetStockDone",(DWORD)0,TRUE,0,0,0,TRUE); //4.0.8.503
					}
				}
			}
			break;
			//Add by Yaron 
			case WSM_BY_MEMO:
			{
				long lMemoFlags = GetWetStockMemoFlags();
				cMsg = " (WSM_BY_MEMO)";
				bGetWetStockData = TRUE;
				
				if (!lMemoFlags)      //4.0.7.501 
					lWetStockFlags = WET_STOCK_TANKS; 
				else
					lWetStockFlags = lMemoFlags;

				//4.0.16.500
				if (lWetStockOnDemandFlags)
					lWetStockFlags |= lWetStockOnDemandFlags; 

				m_cServerInfo.SetMemoProcessFlags(TRUE);
				break;
			}
			//end add by yaron

			//4.0.5.24 -Added by Udi for Delivery - Start
			case WSM_BY_START_DELIVERY:
				cMsg = " (WSM_BY_START_DELIVERY)";
				bGetWetStockData = TRUE;

				//4.0.20.52 TD 63661
				//If PumpSrv delivery emulation process is active, we do NOT want TankSrv to perform delivery emulation by it self.
				if(GetSupportDeliveryEmulation() == FALSE)	
					lWetStockFlags = WET_STOCK_TANKS + WET_STOCK_DELIVERY_START;
				else
					lWetStockFlags = WET_STOCK_TANKS;
				break;

			case WSM_BY_END_DELIVERY:
				cMsg = " (WSM_BY_END_DELIVERY)";
				bGetWetStockData = TRUE;

				//4.0.20.52 TD 63661
				//If PumpSrv delivery emulation process is active, we do NOT want TankSrv to perform delivery emulation by it self.
				if(GetSupportDeliveryEmulation() == FALSE)	
					lWetStockFlags = WET_STOCK_TANKS + WET_STOCK_DELIVERY_END + WET_STOCK_DELIVERY;
				else
					lWetStockFlags = WET_STOCK_TANKS;
				break;
			
			//4.0.5.24 -Added by Udi for Delivery - End
			case WSM_BY_DEMAND_MEMO: //4.0.7.501
			{								
				cMsg = " (WSM_BY_DEMAND_MEMO)";
				bGetWetStockData = TRUE;
								
				lWetStockFlags = lWetStockOnDemandFlags; 									
				//4.0.8.500 sInfo.byMemoInProcess = TRUE;
				m_cServerInfo.SetMemoProcessFlags(TRUE);
				break;
			}
			// 4.0.22.501 TD 69905
			case WSM_BY_REPORT:
			{
				cMsg = " (WSM_BY_REPORT)";
				bGetWetStockData = TRUE;
				
				lWetStockFlags = WET_STOCK_TANKS + WET_STOCK_REQUESTED_BY_REPORT;
				
				break;
			}	
		}	

		if (bGetWetStockData)
		{
			if (lWetStockFlags)
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{	
					CString str("Automatic GetWetStockData Flags - ");
					if (lWetStockFlags & WET_STOCK_PUMP_TOTALS)
						str += "Pump Toatls, ";
					if (lWetStockFlags & WET_STOCK_TANKS)
						str += "Tank Reading, ";
					if (lWetStockFlags & WET_STOCK_DELIVERY)
						str += "Delivery Report, ";
					if (lWetStockFlags & WET_STOCK_DELIVERY_START)
						str += "Delivery Start, ";
					if (lWetStockFlags & WET_STOCK_DELIVERY_END)
						str += "Delivery End, ";
					if (lWetStockFlags & WET_STOCK_ALARM)
						str += "Alarm, ";
					if (lWetStockFlags & WET_STOCK_PUMP_CFG)
						str += "Pump Configuration, ";
					if (lWetStockFlags & WET_STOCK_TANK_CFG)
						str += "Tank Configuration, ";
					if (lWetStockFlags & WET_STOCK_MOST_RECENT_DELIVERY)
						str += "recent delivery, ";
					if (lWetStockFlags & WET_STOCK_DO_MEMO_PROCESS)
						str += "memo process, ";
					if (lWetStockFlags & WET_STOCK_REQUESTED_BY_POS_PUMP) //4.0.16.500
						str += "Requested by PosPump, ";
					if (lWetStockFlags & WET_STOCK_REQUESTED_BY_REPORT) //4.0.22.501 TD 69905
						str += "Requested by Wetstock Report, ";
										

					str = str.Left(str.GetLength() - 2);
					str += cMsg;
					_LOGMSG.LogMsg(str);
				}
				
				SetCommand(CMD_WET_STOCK_DATA,0,lWetStockFlags);

				// Save the requested flags, and by using WET_STOCK_ALL make sure that
				// no unused flag will be use. (otherwise, shift process of another "on demand"
				// process, will never take place).
				
				// 4.0.7.503
				if ((WET_STOCK_MOST_RECENT_DELIVERY & lWetStockFlags) && 
					(!(WET_STOCK_DELIVERY & lWetStockFlags)))
				{
					lWetStockFlags |= WET_STOCK_DELIVERY;
				}				
				m_cServerInfo.SetWetStockFlags(lWetStockFlags & WET_STOCK_ALL);
		
				CString strLog;
				strLog.Format("GetWetStockData, Set Server Info. Delivery Status: %d, Delivery Process: %d.", 
					m_cServerInfo.GetDeliveryEmulationStatus(),
					m_cServerInfo.GetDeliveryEmulationProcessType());
					
				_LOGMSG.LogMsg(strLog);
				//@@@
			}
		}
	}
}

void CServerMain::ClearWetStockProcess(long lWetStockFlags) //4.0.9.503
{
	//4.0.9.503if (!byWetStockFlags)
	if (!lWetStockFlags) //4.0.9.503
	{
		DWORD dwWetStockDone;
		m_cParam.LoadParam("GeneralParam", "WetStockDone",&dwWetStockDone,(DWORD)1, FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		if ( dwWetStockDone == 0 )
			m_cParam.SaveParam("GeneralParam", "WetStockDone", (DWORD)1,TRUE,0,0,0,TRUE);  //4.0.8.503
	}
}

void CServerMain::WatchdogRcved()
{

	m_bRcvAnyMsg = TRUE;	
	if(GetServerState() == SERVER_STARTUP)
	{
		// Site controller switched back to Online
		SetServerState(SERVER_IDLE);
		ClearShowGPIMsgCLIsGone();					//4.0.20.950 TD 97894
	}

	//We count 12 watchdogs (1 minute), this is the
	//amount of time that we can wait for transaction update.
	if ( (m_lWatchdogCount >= 3) && (m_lWatchdogCount < 12) )
	{
		m_lWatchdogCount++;
	}	
}

BOOL CServerMain::IsControllerUpdateTrs()
{
	if (m_lWatchdogCount >= 12)
		return TRUE;
	else
		return FALSE;
}

BOOL CServerMain::IsAutoReceiptCheck()
{
	if(m_dwAutoReceiptCheck)
		return TRUE;
	else
		return FALSE;
}

BOOL CServerMain::IsAutoForce()
{
	if(m_dwAutoForce)
		return TRUE;
	else
		return FALSE;
}


BYTE * CServerMain::GetStringTillDelimiter(BYTE *pszInString, BYTE cDelimiter, BYTE *pszOutString)
{
	CString sInString(pszInString);
	int iPos = sInString.Find(cDelimiter);

	if(iPos != -1)
	{
		memcpy(pszOutString,pszInString,iPos);
		return (pszInString+iPos+1);
	}
	else
		return NULL;
}

// return TRUE in case of "Delimiter found" 
BOOL CServerMain::GetStringTillDelimiterOrEnd(BYTE *pszInString, BYTE *pszOutString, int iOutStringSize, BYTE **pNextString)
{
	CString sInString(pszInString);
	int iPos = sInString.Find(',');

	if(iPos != -1)
	{
		memcpy(pszOutString,pszInString,MIN(iPos,iOutStringSize));
		*pNextString = pszInString+iPos+1;
		return TRUE;
	}
	else
	{
		if(sInString.GetLength()) 
			memcpy(pszOutString,pszInString,MIN(iOutStringSize,sInString.GetLength()));
		*pNextString = NULL;
		return FALSE;
	}
}


void CServerMain::GetVersion()
{
	
	BOOL bSetDefault = FALSE;
	// Get module handle   
	BYTE *pVersionInfo = NULL;
	TCHAR filename[_MAX_PATH];
	DWORD	dwLen;	
	LPVOID	lpvi;   

	HMODULE hModule = ::GetModuleHandle(NULL);
	if (hModule==NULL)      
		bSetDefault = TRUE;
	
	// get module file name   
	if(!bSetDefault)
	{
		dwLen = GetModuleFileName(hModule, filename, sizeof(filename)/sizeof(filename[0]));   
		if (dwLen <= 0)      
			bSetDefault = TRUE;
	}

	// read file version info
	
	if(!bSetDefault)
	{
		DWORD dwDummyHandle; // will always be set to zero
		dwLen = GetFileVersionInfoSize(filename, &dwDummyHandle);   
		if (dwLen <= 0)
			bSetDefault = TRUE;
	}
	  
	
	if(!bSetDefault)
	{
		pVersionInfo = new BYTE[dwLen]; // allocate version info
		if (!::GetFileVersionInfo(filename, 0, dwLen, pVersionInfo))
			bSetDefault = TRUE;
			
	}


	unsigned int uiLen;
	if(!bSetDefault)
	{
		if (!VerQueryValue(pVersionInfo, _T("\\"), &lpvi, &uiLen))
			bSetDefault = TRUE;
	}
	
	// copy fixed info to myself, which am derived from VS_FIXEDFILEINFO

	if(!bSetDefault)
	{
		VS_FIXEDFILEINFO FixedFileInfo;
		FixedFileInfo = *(VS_FIXEDFILEINFO*)lpvi;

		if (!VerQueryValue(pVersionInfo, "\\VarFileInfo\\Translation", &lpvi, &uiLen) && uiLen >= 4) 
			bSetDefault = TRUE;
	}
			
	// Get translation info   
	if(!bSetDefault)
	{
		struct TRANSLATION 
		{   
			WORD langID;   // language ID   
			WORD charset; // code page
		} Translation;
		Translation = *(TRANSLATION*)lpvi;

		char sQuery[50];
		sprintf_s(sQuery, _countof(sQuery), "\\StringFileInfo\\%04x%04x\\FileVersion", Translation.langID, Translation.charset);
		LPCTSTR pVal;      
		if (VerQueryValue(pVersionInfo, sQuery,(LPVOID*)&pVal, &uiLen)) 
		{         
			m_strPumpSrvVersion = pVal;
		}
		
		//4.0.0.83
		else
			bSetDefault = TRUE;
	}

	if(pVersionInfo!=NULL)		//4.0.20.503  
	{
		delete [] pVersionInfo;
		pVersionInfo = NULL;
	}
	
	if(bSetDefault)
	{
		BYTE HardCodeVer[10];
		BYTE *pTmp;
		CString sVersion = PUMPSRV_VERSION;
		memset(HardCodeVer,0,sizeof(HardCodeVer));
		pTmp = (BYTE *)sVersion.GetBuffer(0);
		memcpy(HardCodeVer, pTmp+15, sizeof(HardCodeVer)-1 ); 
		m_strPumpSrvVersion = HardCodeVer;
	}
}



//4.0.5.0
long CServerMain::SaveCardSaleData(long lPumpNumber, CARD_SALE_ALL3 *pData)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	PAY_AT_PUMP_INFO info;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&info);
	memcpy(&info.CardSaleInfo.cardData , &pData->CardSaleAll.data , sizeof(CARD_SALE_ALL3));
	
	m_cPumpArray[lPumpNumber-1].SetPAPInfo(&info);

	long lRtc = SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);

	return (lRtc);
}

//4.0.14.500

BOOL CServerMain::IsNozzleRestrict(long lPumpNumber, OLA_STAT *pOla, PAY_AT_PUMP_INFO *pInfo)
{
	BOOL bRetCode = FALSE;

	//The first 3 "if", chaecking if nozzle restriction is necessary at all.
	if (NozzleLevelLogic())//If we use nozzle restriction
	{
		if (SESSION_TYPE(pOla->m_byState) == SESSION_AUTHORIZE) //If session authorize
		{
			if (a2i(pInfo->CardSaleInfo.cardData.sGradeRestriction, sizeof(pInfo->CardSaleInfo.cardData.sGradeRestriction))) //If grade was resricted (If not, there is no restriction for nozzle)
			{		
				//If here, then nozzle restriction necessary.
				//we know need
				if (!a2i(pInfo->CardSaleInfo.cardData.sNozzleRestriction, sizeof(pInfo->CardSaleInfo.cardData.sNozzleRestriction))) //if none of the nozzle was approved
				{
					bRetCode = TRUE;
				}
				else
				{
					if ( a2l(pInfo->CardSaleInfo.cardData.sAVISystemCustomer, sizeof(pInfo->CardSaleInfo.cardData.sAVISystemCustomer)) ) //Check if the transaction is an AVI
					{
						//Check if the nozzle that was authorize is the one that in use.

						//Get the nozzle restriction bitmap.
						BYTE byNozzle = (pInfo->CardSaleInfo.cardData.sNozzle == ' ' ? 0 : pInfo->CardSaleInfo.cardData.sNozzle - 0x30);
						//Get the nozzle in use
						BYTE byNozzleRestriction = (BYTE)a2i(pInfo->CardSaleInfo.cardData.sNozzleRestriction, sizeof(pInfo->CardSaleInfo.cardData.sNozzleRestriction));
						if ( (byNozzle >= 1) && (byNozzle <= MAX_POSITIONS_PER_PUMP)) //Check that the nozzle valid
							if ( byNozzleRestriction != (1<<(byNozzle-1)) )
								bRetCode = TRUE; //The nozzle that in use is restricted
					}
				}
			}
		}
	}
	return bRetCode;
}

long CServerMain::GetOLAServiceStatus()
{
//	m_cLogger.LogLocationIn("GetOLAServiceStatus()");

	long lRetCode = SERVICE_IDLE;
	//first check if OLA is stopped.
	if ( m_cOLASrv->OLAStopped() || !m_cOLASrv->Valid() )
	{
		lRetCode = SERVICE_OFF;
	}
	else
	{
		//Check if one of the transaction got PAP reservation.
		//if not check that we are not in a middle of OLA session.
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		for(int p = 0 ; p < m_lLastValidPump ; p++)  //4.0.0.79
		{
			OLA_STAT			ola;

			if ( m_cPumpArray[p].GetStat().GetRes() == PAY_AT_PUMP )
			{
				lRetCode = SERVICE_IN_MIDDLE_OF_OPERATION;
				break;
			}

			m_cPumpArray[p].GetOlaStat(&ola);		
			if( OLA_STATE(ola.m_byState) != OLA_NONE )
			{
				lRetCode = SERVICE_IN_MIDDLE_OF_OPERATION;
				break;
			}
		}
		//CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);
	}

//	m_cLogger.LogLocationOut("GetOLAServiceStatus()");
	return lRetCode;
}

long CServerMain::StopOLAService()
{
	long lRetCode = 0;

	switch ( GetOLAServiceStatus() )
	{
		case SERVICE_IDLE:
			m_cOLASrv->StopOLA();
			break;

		case SERVICE_OFF:
			//Nothing to do, OLA already down.
			break;

		case SERVICE_IN_MIDDLE_OF_OPERATION:
			//Can't stop OLA, since it is in middle of work.
			lRetCode = 1;
			break;
	}
	return lRetCode;
}

void CServerMain::UpdateParam(char *szTableName, long lKey1, long lKey2, char *szFiledName, short nFiledType, char *szVal, long lVal)
{
	if ( !strcmp(szTableName, "GeneralParam") )
	{
		if ( !strcmp(szFiledName, "AllowAuthOnNonRequest") )
		{
				m_dwAllowAuthOnNonRequest = lVal;
		}
		else if ( !strcmp(szFiledName, "LogLevel") )
		{
			m_cLogger.SetLogLevel(lVal);
		}
		else if ( !strcmp(szFiledName, "OLACheckingInterval") )
		{
			if (lVal > 0)
				m_dwOLACheckingInterval = lVal;
		}
		else if ( !strcmp(szFiledName, "OLALogDeclineReq") )
		{
			m_dwOLALogDeclineReq = lVal;
		}
		else if ( !strcmp(szFiledName, "OLAResponseTimeOut") )
		{
			if (lVal > 0) 
				m_dwOLAResponseTimeOut = lVal;
		}
		else if (!strcmp(szFiledName, "OLAEpsilonSupport"))
		{
			m_bOLAEpsilonSupport = lVal ? TRUE : FALSE;
		}
		else if ( !strcmp(szFiledName, "PrePayAuthorizedTimeOut") )
		{
			if (lVal > 0)
				m_dwPrePayAuthorizedTimeOut = lVal;
		}
		else if ( !strcmp(szFiledName, "WetStockMode") )
		{
			//4.0.2.13 Start
			//if ( (lVal == WSM_BY_INTERVAL) || (lVal == WSM_BY_TIME) )
			m_dwWetStockMode = lVal;
			//4.0.2.13 End
		}
		else if ( !strcmp(szFiledName, "WetStockInterval") )
		{
			m_dwWetStockInterval = lVal;
		}
		else if ( !strcmp(szFiledName, "CheckAndReserveTimeout") ) //4.0.17.20 - TD 26384
		{
			m_dwCheckAndReserveTimeOut = lVal;
		}
		else if ( !strcmp(szFiledName, "TransactNumber") )
		{
			//Check that transaction number is valid.
			if ( (lVal >= 1) || (lVal <= MAX_TRANSACT_SEQ_NUMBER) )
			{
				//First make sure that such transaction number is mot
				//currently in use, only then change the transaction number.
				BOOL bFound = FALSE;
				CPumpTransact trs;
				for ( int p = 0 ; p < m_lLastValidPump ; p++)   //4.0.0.79
				{
					if(m_cPumpArray[p].GetStat().GetStatus() != UNKNOWN_STATUS)
					{
						if ( !m_cPumpArray[p].GetTrsByNumber(lVal, &trs) )
						{
							bFound = TRUE;
							break;
						}
					}
				}
				if ( !bFound )
					m_dwTransactNumber = lVal;
			}

		}
	}
	else if ( !strcmp(szTableName, "Pumps") )
	{
		if ( !strcmp(szFiledName, "AllowPrePayOnRequestingPump") )
		{
			if (lVal > 0) 
				m_cPumpArray[lKey1-1].SetAllowPrePayOnRequestingPump(lVal);
		}
		else if ( !strcmp(szFiledName, "DispensingTimeOut") )
		{
			if (lVal > 0) 
				m_cPumpArray[lKey1-1].SetDispensingTimeOut(lVal);
		}
		else if ( !strcmp(szFiledName, "PAKAuthorizedTimeOut") )
		{
			if (lVal > 0) 
				m_cPumpArray[lKey1-1].SetPAKAuthorizedTimeOut(lVal);
		}
	}
}

DWORD CServerMain::SubSystemTime(SYSTEMTIME SysTime1, SYSTEMTIME SysTime2)
{
	DWORD dwMillisecondsDiff=0;

	long lYear			= SysTime1.wYear		 - SysTime2.wYear;
    long lMonth			= SysTime1.wMonth		 - SysTime2.wMonth;
    long lDayOfWeek		= SysTime1.wDayOfWeek	 - SysTime2.wDayOfWeek;
    long lDay			= SysTime1.wDay			 - SysTime2.wDay;
    long lHour			= SysTime1.wHour		 - SysTime2.wHour;
    long lMinute		= SysTime1.wMinute		 - SysTime2.wMinute;
    long lSecond		= SysTime1.wSecond		 - SysTime2.wSecond;
    long lMilliseconds	= SysTime1.wMilliseconds - SysTime2.wMilliseconds;

	if ( lMilliseconds >= 0 )
	{
		dwMillisecondsDiff += lMilliseconds;
	}
	else
	{
		dwMillisecondsDiff += (lMilliseconds + 1000);
		lSecond--;
	}

	if ( lSecond >= 0 )
	{
		dwMillisecondsDiff += lSecond * 1000;
	}
	else
	{
		dwMillisecondsDiff += (lSecond + 60) * 1000;
		lMinute--;
	}

	if ( lMinute >= 0 )
	{
		dwMillisecondsDiff += lMinute * 1000 * 60;
	}
	else
	{
		dwMillisecondsDiff += (lMinute + 60) * 1000 * 60;
		lHour--;
	}

	if ( lHour >= 0 )
	{
		dwMillisecondsDiff += lHour * 1000 * 60 * 60;
	}
	else
	{
		dwMillisecondsDiff += (lHour + 24) * 1000 * 60 * 60;
	}
	
	return dwMillisecondsDiff;
}

void CServerMain::LoadCarWashDefinition()
{
	// -------------- Car Wash -------------- //
	//Create and load Car Wash parameters
	m_cCarWash.LoadCarWashDefinition();
	//Load the requests and the cancels lists
	m_cCarWash.InitCarWashLists();
	m_cCarWashGeneralRequest.LoadCarWashDefinition();//4.0.23.504 76432
	// -------------------------------------- //
}

BOOL CServerMain::IsResForAVI(PumpResExt lResExt)
{
	BOOL bResForAVI;
	switch (lResExt)
	{
		case RES_EXT_AVI:
		case RES_EXT_RFID_CT:
		case RES_EXT_RFID_HT:
			bResForAVI = TRUE;
			break;

		default:
			bResForAVI = FALSE;
	}

	return bResForAVI;
}

void CServerMain::DoHotPumping(long lPumpNumber,_bstr_t sReturnBuffer)
{
	// Are we work with Hot Pumping
	if ( m_dwHotPumping )
	{
		// Check if we received approved for Hop Pumping
		CString sReturnBuffer((const char *)sReturnBuffer);			//4.0.25.80 TD 142857	
		if ( sReturnBuffer.Find("HotAuthOK[S]=Y") != -1 )
		{
			CPumpTransact trs;
			long p = lPumpNumber-1;
			// Before sending authorize command, 
			// check if the pump is not authorize yet
		
			if( m_cPumpArray[p].GetCurrentTrs(&trs) )
			{
				if ( m_cPumpArray[p].GetStat().GetStatus() == READY )
				{
					// Make sure we didn't reach to the max allowed unpaid transaction, because 
					// if we will 'hot authorize', it might turn into new unpaid transaction.
					short nPrePayWaiting,nFree,nUnpaid;
					m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting,&nFree,&nUnpaid);
					if(nUnpaid < MAX_ALLOWED_UNPAID_TRS(p))
					{
						//2.9.2.5 start //3.0.1.61 start
						BOOL bFound;
						int iLen = 0;
						char *pParam;
						PAY_AT_PUMP_INFO info;
						
						bFound = m_cOLASrv->GetParam(&sReturnBuffer,sReturnBuffer.Find("AmountLimit[F]"),&pParam,&iLen);
						if(bFound) 
						{
							unsigned char sTmpValue[11];
							if(iLen)
							{
								double x;
								x = atof(pParam);
								//In Israel we do not use the decimal point there for all the 5 characeters are for Integer number.
								//therefore there is no need to multiply by 1000 to get the 3 decimal.
								//if ( GetRegion() != REGION_ISRAEL )
								//	x *= 1000;

								x *= 100; //4.0.1.40

								long lVal = (long)x;
								
								if(LOG_BASIC_FLOW_CONTROL)
								{	
									CString str;
									str.Format("Hot Authorize got limit from LinkSrv %ld",lVal);
									m_cLogger.LogMsg(p+1,LOG_PUMP,str);
								}

								m_cPumpArray[p].GetPAPInfo(&info);
								memset(sTmpValue , '0', sizeof(sTmpValue));
								l2a0(lVal, sTmpValue , 10);
								memcpy(info.CardSaleInfo.cardData.sAuthAmt , &sTmpValue[5] ,sizeof(info.CardSaleInfo.cardData.sAuthAmt));
								memcpy(info.CardSaleInfo.extraData.sAuthAmt_Msb , sTmpValue ,sizeof(info.CardSaleInfo.extraData.sAuthAmt_Msb));
								m_cPumpArray[p].SetPAPInfo(&info);
							}
						}
						//2.9.2.5 end //3.0.1.61 end		
						
						//We pass all requirement, therefore authorize the pump.
						SendSwipeResult(lPumpNumber, CD_HOT_PUMP_AUTHORIZE);
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("Hot Authorize");
							m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
						}
					}
				}
			}
		}
	}
}


//4.0.18.501
void CServerMain::ZeroPAPTotals(CPumpTransact *pTrs,PAY_AT_PUMP_INFO *pInfo)
{
	pTrs->m_nGrade = 0;
	pTrs->m_lGradePrice = 0;
	pTrs->m_lRoundedValue = 0;
	pTrs->m_lRoundedVolume = 0;

	//2.9.2.7
	memset(pInfo->CardSaleInfo.extraData.sTaxAmt,' ' , sizeof(pInfo->CardSaleInfo.extraData.sTaxAmt));
	memset(pInfo->CardSaleInfo.extraData.sAuthAmt_Msb ,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sAuthAmt_Msb)); //3.2.0.73
	memset(pInfo->CardSaleInfo.cardData.sAuthAmt ,' ' ,sizeof(pInfo->CardSaleInfo.cardData.sAuthAmt));
	memset(pInfo->CardSaleInfo.extraData.sFuelAmt,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sFuelAmt));
	memset(pInfo->CardSaleInfo.extraData.sFuelAmt_Msb,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sFuelAmt_Msb));
	memset(&pInfo->CardSaleInfo.extraData.SALES[0],' ' ,sizeof(pInfo->CardSaleInfo.extraData.SALES[0]));
	memset(pInfo->CardSaleInfo.extraData.sTotalAmt,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sTotalAmt));
	memset(pInfo->CardSaleInfo.extraData.sTotalAmt_Msb ,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sTotalAmt_Msb));
	memset(pInfo->CardSaleInfo.extraData.sGRTotalDiscount,' ' ,sizeof(pInfo->CardSaleInfo.extraData.sGRTotalDiscount));
}

BOOL CServerMain::IsPumpHotAuthorized(long lPumpNumber, short byOlaStat)
{
	BOOL bPumpHotAuthorized = FALSE;
	if ( m_dwHotPumping )
	{
		CPumpTransact trs;
		long p = lPumpNumber - 1;
		if( SESSION_TYPE(byOlaStat) == SESSION_AUTHORIZE)
		{
			if( (( m_cPumpArray[p].GetStat().GetStatus() == AUTHORIZED ) ||
				( m_cPumpArray[p].GetStat().GetStatus() == DISPENSING )) )
			{
				bPumpHotAuthorized = TRUE;
			}
			else
			{
				bPumpHotAuthorized = (!m_cPumpArray[p].GetCurrentTrs(&trs));
			}
		}
	}
	return bPumpHotAuthorized;					
}

BOOL CServerMain::StopHotAuthorizedPump(long lPumpNumber)
{
	BOOL bRetCode = TRUE;
	if ( m_dwHotPumping )
	{
		long p = lPumpNumber - 1;
		CPumpTransact trs;

		//Update Pump's Misc with MISC_CURRENT_TRS_PAP_CANCELED.

		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		CPumpStatus pumpStat = m_cPumpArray[p].GetStat();
		long lMisc = pumpStat.GetMisc();
		lMisc |= MISC_CURRENT_TRS_PAP_CANCELED;
		pumpStat.SetMisc(lMisc);
		m_cPumpArray[p].SetStat(pumpStat);

		//Update Transaction's Misc with MISC_TRS_PAP_CANCELED.
		trs.Clear();
		trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());
		if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))
		{
			trs.m_lMisc |= MISC_TRS_PAP_CANCELED;
			m_cPumpArray[p].SetTrsByNumber(trs.m_lNumber,&trs,FALSE);
		}

		if( ( m_cPumpArray[p].GetStat().GetStatus() == AUTHORIZED ) || ( m_cPumpArray[p].GetStat().GetStatus() == DISPENSING ) )
		{
			SetCommand(CMD_STOP_PUMP, SERVER_POS_NUMBER, lPumpNumber);
		}
		else
		{
			bRetCode = FALSE;
		}
		
	}

	return bRetCode;
}

long CServerMain::GetStationLimitVolume()
{
	return (m_dwVolumeLimit * 1000);//4.0.6.501	
}


void CServerMain::UpdateEncryptionKeys(long lPumpNumber, _bstr_t sReturnBuffer)
{
	int iLen;
	char *pParam;

	if (sReturnBuffer.length() == 0)
		return;

	if (lPumpNumber == 0)
	{
		CString sReturnBuffer((const char *)sReturnBuffer);					//4.0.25.80 TD 142857
		if ( m_cOLASrv->GetParam(&sReturnBuffer,sReturnBuffer.Find("EncryptionKey[S]"),&pParam,&iLen) )
		{
			char *pEncryptionKey = new char [iLen+1];
			if (pEncryptionKey)
			{
				memcpy(pEncryptionKey, pParam, iLen);
				pEncryptionKey[iLen] = 0;
				if ( m_strEncryptionKey != pEncryptionKey )
				{
					m_strEncryptionKey = pEncryptionKey;
					m_cParam.SaveParam("GeneralParam", "EncryptionKey", pEncryptionKey);
					if( GetServerState() >= SERVER_STARTUP )
					{
						CMD_STRUCT_UPDATE_PARAM cmdInfo;
						memset(&cmdInfo,0,sizeof(CMD_STRUCT_UPDATE_PARAM));
						strcpy_s(cmdInfo.szTableName, _countof(cmdInfo.szTableName),"GeneralParam");
						cmdInfo.lKey1 = 0;
						cmdInfo.lKey2 = 0;
						strcpy_s(cmdInfo.szFieldName, _countof(cmdInfo.szFieldName),"EncryptionKey");
						cmdInfo.nFieldType = FIELD_SZ;
						strcpy_s(cmdInfo.szFieldVal, _countof(cmdInfo.szFieldVal),pEncryptionKey);
						cmdInfo.lVal = 0;
						SetCommand(CMD_UPDATE_PARAM,SERVER_POS_NUMBER, 0,&cmdInfo,sizeof(CMD_STRUCT_UPDATE_PARAM));
					}
				}

				//4.0.2.15 changed to delete[]
				delete[] pEncryptionKey;
			}
		}
	}

}

CString CServerMain::GetSiteID()
{
	return m_sSiteID;
}

void CServerMain::DoAutomaticReceiptCheck()
{
	PAY_AT_PUMP_INFO    cPayAtPumpInfo;   //4.0.2.38
	CPumpTransact		cTmpTrs;		  //4.0.2.38	
	long				lItemIndex = 0;   //4.0.2.38
	CReceiptInfo ReceiptInfo;
	PS::RECEIPT_EXTRA_INFO_REC	ReceiptExtraInfoRec;
	DWORD dwReceiptRecordTimeout, dwMaxReceiptCopies;
	long lRtc = 0;
	CTimeSpan ts;
	long lZoneFlag = 0;  //4.0.10.351
	CTime cCurrentTime = CTime::GetCurrentTime();
	CPumpSrvDatabase & PumpSrvDatabase = CPumpSrvDatabase::GetInstance();

	{

		_Module.m_server.m_cParam.LoadParam("Receipt", "ReceiptRecordTimeout", &dwReceiptRecordTimeout, 0, TRUE);
		_Module.m_server.m_cParam.LoadParam("Receipt", "MaxReceiptCopies", &dwMaxReceiptCopies, 0, TRUE); //3.0.4.9

																										  //memset(&ReceiptInfo , 0 , sizeof(CReceiptInfo));

		ReceiptInfo.Clear();
		lRtc = PumpSrvDatabase.GetFirstReceiptRecord(ReceiptInfo) ? OK : 1;

		//Eyal 4.0.0.37 start
		if (LOG_DETAIL_FLOW_CONTROL)
		{
			CString sMsg;

			if (lRtc == OK)
				sMsg.Format("CServerMain::DoAutomaticReceiptCheck() entering search loop");

			else
				sMsg.Format("CServerMain::DoAutomaticReceiptCheck() exiting without doing anything");

			m_cLogger.LogMsg(sMsg);
		}
		//Eyal 4.0.0.37 end

		while (lRtc == OK)
		{
			long long l;
			CTime cTrsTime(ReceiptInfo.m_TrsTime);

			ts = cCurrentTime - cTrsTime;
			l = ts.GetTotalMinutes();

			//4.0.0.37 changed condition from AND to OR
			if ((ts.GetTotalMinutes() >= (long)dwReceiptRecordTimeout) ||
				(ReceiptInfo.m_NumberOfCopies >= (long)dwMaxReceiptCopies)) // 3.0.4.9 // delete 
			{
				lZoneFlag = 0;
				//4.0.2.38
				memset(&cPayAtPumpInfo, 0, sizeof(PAY_AT_PUMP_INFO));
				ConvertReceiptToOla(ReceiptInfo, &cTmpTrs, &cPayAtPumpInfo);
				lItemIndex = a2l(cPayAtPumpInfo.CardSaleExtraData2.sItemsLinkIndex, sizeof(cPayAtPumpInfo.CardSaleExtraData2.sItemsLinkIndex));

				if (lItemIndex)
				{
					ITEMS_INFO cItemTmp;
					cItemTmp.ItemRec.lIndexNumber = lItemIndex;
					lRtc = _Module.m_server.IndexOperation(ITEMS_FILE, REC_DELETE, &cItemTmp);

					if (lRtc)
					{
						CString sMsg;
						sMsg.Format("CServerMain::DoAutomaticReceiptCheck failed to clear Index=%ld from ItemFile , error=%ld", lItemIndex, lRtc);
						m_cLogger.LogMsg(sMsg);
					}

				}
				//4.0.2.38

				//4.0.10.351
				lZoneFlag = a2l(cPayAtPumpInfo.CardSaleExtraData2.sFlags, sizeof(cPayAtPumpInfo.CardSaleExtraData2.sFlags));

				if (lZoneFlag & FL_EXTRA_RECEIPT_REC)
				{
					memset(&ReceiptExtraInfoRec, ' ', sizeof(RECEIPT_EXTRA_INFO_REC));
					//cReceiptExtraRec.lIndex = a2l(cPayAtPumpInfo.CardSaleExtraData3.sReceiptZoneIndex, sizeof(cPayAtPumpInfo.CardSaleExtraData3.sReceiptZoneIndex));
					
					ReceiptExtraInfoRec.info.lIndexNumber = a2l(cPayAtPumpInfo.CardSaleInfo.cardData.sTranNbr, sizeof(cPayAtPumpInfo.CardSaleInfo.cardData.sTranNbr));
					lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_DELETE, ReceiptExtraInfoRec);
					//lRtc = _Module.m_server.IndexOperation(RECEIPT_EXTRA_DATA_FILE, REC_DELETE, &cReceiptExtraRec);


					if (lRtc)
					{
						CString sMsg;
						sMsg.Format("CServerMain::DoAutomaticReceiptCheck failed to cleared Index=%ld from Receipte.qdx , error=%ld", ReceiptExtraInfoRec.info.lIndexNumber, lRtc);
						m_cLogger.LogMsg(sMsg);
					}
					else
					{
						CString sMsg;
						sMsg.Format("CServerMain::DoAutomaticReceiptCheck successfully  cleared Index=%ld from Receipte.qdx , error=%ld", ReceiptExtraInfoRec.info.lIndexNumber, lRtc);
						m_cLogger.LogMsg(sMsg);
					}


				}

				lRtc = PumpSrvDatabase.DeleteReceiptRecord(ReceiptInfo) ? OK : 1;
				
				//RFUEL-3621
				if (!PumpNotValid(ReceiptInfo.m_PumpNumber))
				{
					if (!(_Module.m_server.m_cMemPumpArray[ReceiptInfo.m_PumpNumber - 1].RemoveTrsMemPumpInfo(ReceiptInfo.m_TrsIndex)))
					{
						CString sMsg;
						sMsg.Format("DoAutomaticReceiptCheck, Record was Not found in MemPumpInfo trs: %ld", ReceiptInfo.m_TrsIndex); //4.0.23.1160 
						m_cLogger.LogMsg(sMsg);
					}
					else
					{
						CString sMsg;
						sMsg.Format("DoAutomaticReceiptCheck, Record was deleted MemPumpInfo trs: %ld", ReceiptInfo.m_TrsIndex); //4.0.23.1160 
						m_cLogger.LogMsg(sMsg);
					}
				}

				if (LOG_FCC_FLOW_CONTROL && !lRtc)
				{
					CString sMsg;
					sMsg.Format("DoAutomaticReceiptCheck, Record deleted Index: %ld", ReceiptInfo.m_TrsIndex); //4.0.23.1160 
					m_cLogger.LogMsg(sMsg);
				}

				if (!lRtc)
				{
					lRtc = PumpSrvDatabase.GetNextReceiptRecord(ReceiptInfo.m_TrsIndex, ReceiptInfo) ? OK : 1;
				}
			}
			else
			{
				lRtc = PumpSrvDatabase.GetNextReceiptRecord(ReceiptInfo.m_TrsIndex, ReceiptInfo) ? OK : 1;
			}
		}

		if (LOG_DETAIL_FLOW_CONTROL)  //4.0.5.39
		{
			CString sMsg;
			sMsg.Format("CServerMain::DoAutomaticReceiptCheck() ended search loop");
			m_cLogger.LogMsg(sMsg);
		}
	}
}

//4.0.18.501
long CServerMain::ConvertOlaToReceipt(CPumpTransact *pTrs, PAY_AT_PUMP_INFO *pInfo, RECEIPT_INFO *pReceipt ,BYTE lOlaState)
{

	PAY_AT_PUMP_INFO	*pPAPInfo;
	BYTE				sTmpTrack2[ENCRYPTED_DATA_SIZE]; //4.0.20.501 TD 60236

	if(pInfo)
		pPAPInfo = (PAY_AT_PUMP_INFO *)pInfo;
	
	memset(pReceipt , 0 , sizeof(RECEIPT_INFO));
	Track2Format(pPAPInfo->CardSaleInfo.cardData.sTrack2Data);	

	const long lOLABufSize = sizeof(pPAPInfo->CardSaleExtraData2);	//995
	const long lReceiptBufSize = sizeof(pReceipt->cReceipt6.BufferRec6);	//922
	const long lSizeDiffOlaReceipt = lOLABufSize - lReceiptBufSize;	//73

	//4.0.20.501 TD 60236 {
	memcpy(pReceipt->cReceipt1.BufferRec1, (char *)&pPAPInfo->CardSaleInfo , sizeof(pPAPInfo->CardSaleInfo));	//900
	memcpy(pReceipt->cReceipt2.BufferRec2,(char *)&pPAPInfo->CardSaleExtraData2 , sizeof(pReceipt->cReceipt2.BufferRec2));	//922
	memcpy(pReceipt->cReceipt3.BufferRec3,(char *)&pPAPInfo->CardSaleExtraData3 , sizeof(pReceipt->cReceipt3.BufferRec3));	//922
	memcpy(pReceipt->cReceipt4.BufferRec4,(char *)&pPAPInfo->CardSaleExtraData4 , sizeof(pReceipt->cReceipt4.BufferRec4));	//4.0.18.501 //922
	memcpy(pReceipt->cReceipt5.BufferRec5,(char *)&pPAPInfo->CardSaleExtraData5 , min(sizeof(pReceipt->cReceipt5.BufferRec5), sizeof(pPAPInfo->CardSaleExtraData5)));	//785 out of 922 //4.0.22.13	TD 72716	filer =922 -785 =137
	memcpy(pReceipt->cReceipt7.BufferRec7,(char *)&pPAPInfo->CardSaleExtraData6 , sizeof(pReceipt->cReceipt7.BufferRec7));

	
	//All remainders are saved in cReceipt6.sbuffer	//4.0.22.13	TD 72716
	memcpy(pReceipt->cReceipt6.BufferRec6,(char *)&pPAPInfo->CardSaleExtraData2 + lReceiptBufSize , lSizeDiffOlaReceipt);	//last 73 bytes of CardSaleExtraData2
	memcpy(pReceipt->cReceipt6.BufferRec6 + lSizeDiffOlaReceipt, (char *)&pPAPInfo->CardSaleExtraData3 + lReceiptBufSize , lSizeDiffOlaReceipt);	//last 73 bytes of CardSaleExtraData3
	memcpy(pReceipt->cReceipt6.BufferRec6 + 2*lSizeDiffOlaReceipt, (char *)&pPAPInfo->CardSaleExtraData4 + lReceiptBufSize , lSizeDiffOlaReceipt);	//last 73 bytes of CardSaleExtraData4
	memcpy(pReceipt->cReceipt6.BufferRec6 + 3*lSizeDiffOlaReceipt, pTrs , sizeof(CPumpTransact)); //200	//4.0.22.13	TD 72716

	//4.0.20.501 TD 60236 }

	memset(pReceipt->cReceipt1.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt1.Index.sTrack2));
	
	//In AVI transaction we do not have Track2, therefore we need new unique key for AVI
	if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_AVI)
	{			
		memcpy(pReceipt->cReceipt1.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));
		m_cLogger.LogMsg("Car registration Transaction 1 !");	
	}
	else if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_ATTENDANT)
	{
		// 
		if (ChrAll((char *)pPAPInfo->CardSaleExtraData2.sItemsLinkIndex , sizeof(pPAPInfo->CardSaleExtraData2.sItemsLinkIndex)))
		{
			memcpy(pReceipt->cReceipt1.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data),sizeof(pReceipt->cReceipt1.Index.sTrack2))); //4.0.21.10 68240
		}
		else
		{
			memset(pReceipt->cReceipt1.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt1.Index.sTrack2));
			memcpy(pReceipt->cReceipt1.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sTrack2Data , min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data),sizeof(pReceipt->cReceipt1.Index.sTrack2))); //4.0.21.10 68240
		}
		
		memset(sTmpTrack2 , ' ' , sizeof(sTmpTrack2));	//4.0.21.10 68240
		memcpy(sTmpTrack2, pReceipt->cReceipt1.Index.sTrack2 , sizeof(sTmpTrack2));
	}
	else
	{
		memcpy(pReceipt->cReceipt1.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sTrack2Data , min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt1.Index.sTrack2))); //4.0.21.10 68240
	}
	
	// copy second record receipt2 buffer 985
	//*******************************************8
	//In AVI transaction we do not have Track2, therefore we need new unique key for AVI
	if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_AVI)
	{		
		memset(pReceipt->cReceipt2.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));
		memcpy(pReceipt->cReceipt2.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		memset(pReceipt->cReceipt3.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));
		memcpy(pReceipt->cReceipt3.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		memset(pReceipt->cReceipt4.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));
		memcpy(pReceipt->cReceipt4.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		memset(pReceipt->cReceipt5.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));
		memcpy(pReceipt->cReceipt5.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		memset(pReceipt->cReceipt6.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));	//4.0.22.501	TD 72716
		memcpy(pReceipt->cReceipt6.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		memset(pReceipt->cReceipt7.Index.sTrack2 , ' ' , sizeof(pReceipt->cReceipt2.Index.sTrack2));	//4.0.22.501	TD 72716
		memcpy(pReceipt->cReceipt7.Index.sTrack2 , pPAPInfo->CardSaleInfo.cardData.sFullVehicleId , sizeof(pPAPInfo->CardSaleInfo.cardData.sFullVehicleId));

		m_cLogger.LogMsg("Car registration Transaction 1 !");	
	}
	else if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_ATTENDANT)
	{
		memcpy(pReceipt->cReceipt2.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt2.Index.sTrack2));
		memcpy(pReceipt->cReceipt3.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt3.Index.sTrack2));
		memcpy(pReceipt->cReceipt4.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt4.Index.sTrack2));
		memcpy(pReceipt->cReceipt5.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt5.Index.sTrack2));
		memcpy(pReceipt->cReceipt6.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt6.Index.sTrack2));		//4.0.22.501	TD 72716
		memcpy(pReceipt->cReceipt7.Index.sTrack2, sTmpTrack2, sizeof(pReceipt->cReceipt7.Index.sTrack2));
	}
	else
	{
		memcpy(pReceipt->cReceipt2.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt2.Index.sTrack2))); //4.0.21.10 68240
		memcpy(pReceipt->cReceipt3.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt3.Index.sTrack2))); //4.0.21.10 68240
		memcpy(pReceipt->cReceipt4.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt4.Index.sTrack2))); //4.0.21.10 68240
		memcpy(pReceipt->cReceipt5.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt5.Index.sTrack2))); //4.0.21.10 68240
		memcpy(pReceipt->cReceipt6.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt6.Index.sTrack2))); //4.0.22.501	TD 72716
		memcpy(pReceipt->cReceipt7.Index.sTrack2, pPAPInfo->CardSaleInfo.cardData.sTrack2Data, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), sizeof(pReceipt->cReceipt7.Index.sTrack2))); //4.0.22.501	TD 72716
	}

	return 0; 
}


//4.0.5.0
//4.0.18.501
//4.0.20.501 TD 60236
long CServerMain::ConvertReceiptToOla(RECEIPT_INFO *pReceipt, CPumpTransact *pTrs, void *pInfo)
{
	PAY_AT_PUMP_INFO	*pPAPInfo;

	pPAPInfo = (PAY_AT_PUMP_INFO *)pInfo;
	const long lOLABufSize = sizeof(pPAPInfo->CardSaleExtraData2);		//995
	const long lReceiptBufSize = sizeof(pReceipt->cReceipt6.BufferRec6);	//922
	const long lSizeDiffOlaReceipt = lOLABufSize - lReceiptBufSize;		//73

	memset(pPAPInfo , ' ', sizeof(PAY_AT_PUMP_INFO));

	memcpy((char *)&pPAPInfo->CardSaleInfo ,pReceipt->cReceipt1.BufferRec1, sizeof(pPAPInfo->CardSaleInfo));
	memcpy((char *)&pPAPInfo->CardSaleExtraData2, pReceipt->cReceipt2.BufferRec2, sizeof(pReceipt->cReceipt2.BufferRec2));//922
	memcpy((char *)&pPAPInfo->CardSaleExtraData3, pReceipt->cReceipt3.BufferRec3, sizeof(pReceipt->cReceipt3.BufferRec3));//922
	memcpy((char *)&pPAPInfo->CardSaleExtraData4, pReceipt->cReceipt4.BufferRec4, sizeof(pReceipt->cReceipt4.BufferRec4));//922
	memcpy((char *)&pPAPInfo->CardSaleExtraData5, pReceipt->cReceipt5.BufferRec5, min(sizeof(pReceipt->cReceipt5.BufferRec5), sizeof(pPAPInfo->CardSaleExtraData5))); //785 out of 922 //4.0.22.501	TD 72716
	memcpy((char *)&pPAPInfo->CardSaleExtraData6, pReceipt->cReceipt7.BufferRec7, sizeof(pReceipt->cReceipt7.BufferRec7));//922
	//////////////////////////
	//delete info index number and fill it with space to use bstrsz
	memset(&pPAPInfo->CardSaleInfo.lIndexNumber , ' ' , sizeof(pPAPInfo->CardSaleInfo.lIndexNumber));

	//All remainders are saved in cReceipt6.sbuffer
	memcpy((char *)&pPAPInfo->CardSaleExtraData2 + lReceiptBufSize, pReceipt->cReceipt6.BufferRec6, lSizeDiffOlaReceipt);//73
	memcpy((char *)&pPAPInfo->CardSaleExtraData3 + lReceiptBufSize, pReceipt->cReceipt6.BufferRec6 + lSizeDiffOlaReceipt, lSizeDiffOlaReceipt);//73
	memcpy((char *)&pPAPInfo->CardSaleExtraData4 + lReceiptBufSize, pReceipt->cReceipt6.BufferRec6 + 2*lSizeDiffOlaReceipt, lSizeDiffOlaReceipt);//73
	memcpy( pTrs ,  pReceipt->cReceipt6.BufferRec6 +  3*lSizeDiffOlaReceipt, sizeof(CPumpTransact)); //200 //4.0.22.13	TD 72716

	////////////////////////////////////////////////////////
	if (pPAPInfo->CardSaleInfo.cardData.sTranType != CD_TYPE_AVI)
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data ,  pReceipt->cReceipt1.Index.sTrack2 , sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));
	else
		memset(pPAPInfo->CardSaleInfo.cardData.sTrack2Data , ' ' , sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));

	if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_ATTENDANT)
	{					
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data , pReceipt->cReceipt2.Index.sTrack2 , sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));
	} 
	else if (pPAPInfo->CardSaleInfo.cardData.sTranType != CD_TYPE_AVI)
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data , pReceipt->cReceipt2.Index.sTrack2 , sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));
	else
		memset(pPAPInfo->CardSaleInfo.cardData.sTrack2Data , ' ' , sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));

	////////////////////////////////////////////////////////

	return 0; 
}

long CServerMain::ConvertReceiptToOla(CReceiptInfo & ReceiptInfo, CPumpTransact *pTrs, PAY_AT_PUMP_INFO *pPAPInfo)
{
	*pPAPInfo = ReceiptInfo.m_PAPInfo;
	*pTrs = ReceiptInfo.m_PumpTransact; //RFUEL-375 - Reprint last receipt doesn't print transaction data - MichaelPo

	////////////////////////////////////////////////////////
	if (pPAPInfo->CardSaleInfo.cardData.sTranType != CD_TYPE_AVI)
	{
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data, (LPCSTR)ReceiptInfo.m_HashedKey, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), ReceiptInfo.m_HashedKey.GetLength()));
	}
	else  if (pPAPInfo->CardSaleInfo.cardData.sTranType == CD_TYPE_ATTENDANT)
	{
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data, (LPCSTR)ReceiptInfo.m_HashedKey, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), ReceiptInfo.m_HashedKey.GetLength()));
	}
	else if (pPAPInfo->CardSaleInfo.cardData.sTranType != CD_TYPE_AVI)
		memcpy(pPAPInfo->CardSaleInfo.cardData.sTrack2Data, (LPCSTR)ReceiptInfo.m_HashedKey, min(sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data), ReceiptInfo.m_HashedKey.GetLength()));
	else
		memset(pPAPInfo->CardSaleInfo.cardData.sTrack2Data, ' ', sizeof(pPAPInfo->CardSaleInfo.cardData.sTrack2Data));

	return 0;
}


long CServerMain::GetTypeLimitByUser(short nTypeLimit)
{
	long  lRetTypeLimit = 0;	

	switch(nTypeLimit)
	{
		case DEBIT_LIMIT_BY_USER:
				lRetTypeLimit = m_dwDebitLimitByUser;
			break;
		case CREDIT_LIMIT_BY_USER:
				lRetTypeLimit = m_dwCreditLimitByUser;
			break;
	}

	return lRetTypeLimit;
}
BOOL CServerMain::IsInteracCard(long lPumpNumber)
{
	PAY_AT_PUMP_INFO cPayAtPumpInfo;
	memset(&cPayAtPumpInfo,' ',sizeof(cPayAtPumpInfo));
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cPayAtPumpInfo);
	if (memcmp(cPayAtPumpInfo.CardSaleExtraData3.sAID, INTERAC_CARD_AID, INTERAC_CARD_AID_SIZE))
		return FALSE;
	return TRUE;
}

// start 2.9.1.3
BOOL CServerMain::ReleasePumpMessages(long lPump, long lVal)
{
	CPumpStatus	pumpStat;
	long		lMessages = 0 ;
	BOOL		bRet = FALSE;

	
	pumpStat = m_cPumpArray[lPump].GetStat();
	// check if exist message lock in Pump.. //2.9.1.3
	lMessages = pumpStat.GetMessage();

	switch(lMessages)
	{
		case PUMP_MSG_STOCK_PRE_PAY:
		{
			pumpStat.SetMessage(lVal);
			bRet = TRUE;
		}
		break;
	}	 
	return bRet;
}
// end 2.9.1.3

//3.0.0.8 (start)
BOOL CServerMain::CheckVITConflict()
{
	if(m_dwCheckVITConflict)
		return TRUE;
	else
		return FALSE;
}

long CServerMain::GetMaxVolumeForVITConflict()
{
	return (long)m_dwMaxVolumeForVITConflict;
}
//3.0.0.8 (end)

//4.0.5.15
/******************************************************************************
 Description:	Go out sync to OLA and retrieve the card information	
 Returns:      	Zero on sucess, outherwise failure. 
 
 WHO			            WHEN                    WHAT
-------------------------------------------------------------------------------
 ???? (old method)			
 AmitH						25/05/2010   19:00 - Add bDoNotUseXmlBuffer to Get Struct or Xml from GetCardInfo.
******************************************************************************/
long CServerMain::GetCardInfo(BSTR sAccountNumber, BSTR bstrTrack1, BSTR bstrTrack2, BSTR bstrShortCardName, BSTR *pRetData,long lFlags,long *lSesionType , long lPumpNumber ,BOOL bDoNotUseXmlBuffer /*= FALSE */) //4.0.25.0
{
	long lRtc = 0;
	long lOlaRecordSize = sizeof(CARD_SALE_ALL3);					// 4.0.32.??? TD 405435
	CComBSTR sCardBuf;
	CARD_SALE_ALL3 CardData;  //4.0.0.75 //4.0.5.0.

	memset(&CardData,' ', sizeof(CardData));

	BYTE sTrack1[TRACK_1_DATA_SIZE*2] = {0};
	Bstr2Buffer(bstrTrack1, sTrack1, min(SysStringLen(bstrTrack1) + 2, sizeof(sTrack1)));

	BYTE sTrack2[TRACK_2_DATA_SIZE*2] = {0};
	Bstr2Buffer(bstrTrack2, sTrack2, min(SysStringLen(bstrTrack2) + 2, sizeof(sTrack2)));

	if (CheckOLA() != OLASRV_COM_ERROR)
	{
		if(lFlags & GET_CARD_INFO_SESSION)
			lRtc = m_cOLASrv->GetCardInfoSession(sAccountNumber, bstrTrack1, bstrTrack2, bstrShortCardName, &sCardBuf, lFlags,lSesionType, lPumpNumber);  //4.0.11.504
		else
			lRtc = m_cOLASrv->GetCardInfo(sAccountNumber, bstrTrack1, bstrTrack2, bstrShortCardName, &sCardBuf, lFlags,lSesionType, lPumpNumber);
	}


	if (m_cOLASrv->Valid() && lRtc == 0)
	{
		if(lFlags & GET_ALL_CARDS_DATA)
		{
			CString sCardOlaInfo = sCardBuf.m_str;
			PAY_AT_PUMP_INFO cPayAtPumpInfo;
			memset(&cPayAtPumpInfo,' ',sizeof(cPayAtPumpInfo));
			m_cOLASrv->ParseData(OLASRV_NEED_MORE_PARAMS,&sCardOlaInfo,&cPayAtPumpInfo,NULL,0,lPumpNumber); //4.0.16.503
			CardData.CardSaleAll.data =  cPayAtPumpInfo.CardSaleInfo.cardData;
			CardData.CardSaleAll.extData = cPayAtPumpInfo.CardSaleInfo.extraData;
			CardData.extData2 = cPayAtPumpInfo.CardSaleExtraData2;
			CardData.extData3 = cPayAtPumpInfo.CardSaleExtraData3;
		}
		else
			m_cOLASrv->ParseCardData(sCardBuf, &CardData,lPumpNumber);
		

		if (lFlags & SWIPE_THREE_OLA_REC)
		{
			lOlaRecordSize = sizeof(CARD_SALE_ALL3);

			if (!GetOLAFlags(CardData.extData2.sFlags ,FL_PAP_AS_THIRD_REC))
			{
				long lTmp = a2l(CardData.extData2.sFlags ,sizeof(CardData.extData2.sFlags))  + FL_PAP_AS_THIRD_REC;
				l2a(lTmp ,CardData.extData2.sFlags ,sizeof(CardData.extData2.sFlags)); 
			}			
		}

		//4.0.14.500
		char sXmlBuff[MAX_XML_BUF_LEN] = {0};
		if (m_bUseXmlBuffer && (bDoNotUseXmlBuffer == FALSE)) //4.0.25.0
		{
			//Xml:
			m_cXmlConvertorEx.ConvertFromStructToXml(sXmlBuff,&CardData);
		}
		else
		{
			//Stracture:
			lOlaRecordSize = sizeof(CARD_SALE_ALL3);
			memcpy(sXmlBuff,&CardData,lOlaRecordSize);
		}
		
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("GetCardInfo Attendant name=%.15s, ID=%.10s,buffer size=%ld.", CardData.extData2.sAttendantName, CardData.extData2.sAttendantID , lOlaRecordSize);
			m_cLogger.LogMsg(str);
		}

		CComBSTR CParam(sizeof(sXmlBuff),sXmlBuff);
		CParam.CopyTo(pRetData);
	}

	return lRtc; 
}

void CServerMain::GetReceiptCounter(long *plCounter, long lType, long lFlags)
{
	int iRtc = 0;
	DWORD dwCounter;
	DWORD dwMaxCounter;
	DWORD dwMinCounter;  //4.0.3.385   //4.0.3.49
	DWORD dwResetCounterInNewYear;	//4.0.3.385
	DWORD dwInvoiceTaxYear =0;   //4.0.3.385
	CString str("Receipt\\Receipt");
	CString sTmpStr;
	char sType[8];
	memset(sType,0,sizeof(sType));
	sprintf_s(sType, _countof(sType),"%02ld",lType);
	str += sType;


	m_cParam.LoadParam((char *)((LPCTSTR)str), "ResetCounterInNewYear", &dwResetCounterInNewYear,(DWORD)0,TRUE);   //4.0.3.385	

	//if the receipt type is zero - this is a special case in which we take the counter from a member 4.0.19.502
	if (lType == 0)
	{
		dwCounter = m_lReceipt00Counter;
	}
	else
	{
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Counter", &dwCounter,(DWORD)0,TRUE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE);	
	}
	
	m_cParam.LoadParam((char *)((LPCTSTR)str), "MaxCounter", &dwMaxCounter,(DWORD)999999,TRUE);
	m_cParam.LoadParam((char *)((LPCTSTR)str), "MinCounter", &dwMinCounter,(DWORD)1,TRUE);   //4.0.3.385
	m_cParam.LoadParam((char *)((LPCTSTR)str), "InvoiceTaxYear", &dwInvoiceTaxYear,(DWORD)0,TRUE);   //4.0.3.385
	
	
	if (dwCounter++ >= dwMaxCounter)
	{
		//dwCounter = 1;
		dwCounter = dwMinCounter;
	}

	if (dwResetCounterInNewYear)
	{
		SYSTEMTIME cCurrentTime;
		GetLocalTime(&cCurrentTime);
			
		if (cCurrentTime.wYear > dwInvoiceTaxYear)
		{
			dwInvoiceTaxYear = cCurrentTime.wYear ;
			m_cParam.SaveParam((char *)((LPCTSTR)str),"InvoiceTaxYear",dwInvoiceTaxYear,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)str), "InvoiceTaxYear", &dwInvoiceTaxYear,(DWORD)0,TRUE);   //4.0.3.385	
			dwCounter = dwMinCounter;
		}	
	}
		
	iRtc = m_cParam.SaveParam((char *)((LPCTSTR)str), "Counter", dwCounter, TRUE, _HOST.m_lGroupNum, 0, dwCounter, TRUE);		//4.0.23.501	TD 78380

	//Update the member 4.0.19.502
	if (lType == 0)
	{
		m_lReceipt00Counter = dwCounter;
	}

	if (iRtc == 0)
		*plCounter = dwCounter;
}

void CServerMain::LoadTableModeSchemToArray__(BOOL bRun)
{
	__try
	{
		LoadTableModeSchemToArray(bRun);  //4.0.1.0
	}
	__except(_HANDLE_EXCEPTION("CServerMain::GetWetStockData")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::LoadTableModeSchemToArray()", LOG_LEVEL_0);

		exit(1);
	}
}

//4.0.1.0
void CServerMain::LoadTableModeSchemToArray(BOOL bRun)
{
	for(int p=1; p <=  m_lMaxPumps ; p++)    //4.0.0.79
	{	
		for(int n=1;n <=  MAX_MODE_SCHEME;n++)		
		{						
			//long lIndex =  (p * MAX_MODE_SCHEME) + n;
			long lIndex = GenerateModeSchemeIndex(p  , n );
			m_cModeSchemeArray[lIndex].SetIndex(p  , n  );
			m_cModeSchemeArray[lIndex].LoadDefinition(1);
		}
		// 4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);
	}
}

long CServerMain::GenerateModeSchemeIndex(long lPump, long lScheme)
{
	long lIndex =   (((lPump - 1) * MAX_MODE_SCHEME) + (lScheme - 1));

	if (lIndex < 0)
		lIndex = 0;

	return lIndex;
}

BOOL CServerMain::ServiceFeeNotValid(LONG lServiceNumber)
{
	if( (lServiceNumber > 0) && (lServiceNumber <= MAX_SERVICE_FEE))
		return FALSE;
	else
		return TRUE;

}

BOOL CServerMain::UseServiceFee()
{
	return m_bUseServiceFee;
}


// locate service fee for Pump & Time
long CServerMain::FindServiceFee(long lPump , SYSTEMTIME & sysTime , long lTrsType)
{
	long lServiceFeeIndex = 0;

	long lIndexChange = 0;
	long lIndex = GenerateModeSchemeIndex(lPump , 1); 								

	lIndexChange = lIndex;		
	long lNewMode = m_cModeSchemeArray[lIndex].GetMode();

	for(long s=2; s <= MAX_MODE_SCHEME; s++)				
	{	
		lIndex = GenerateModeSchemeIndex(lPump , s); 

		if(m_cModeSchemeArray[lIndex].Active(sysTime))
		{		
			lNewMode = m_cModeSchemeArray[lIndex].GetMode();					
			lIndexChange = lIndex;
		}
	}
	
	lServiceFeeIndex = m_cModeSchemeArray[lIndexChange].GetServiceFeeSet();

	return (lServiceFeeIndex);
}

void CServerMain::PrintReport(long lTerminalType, long lTerminalNumber, char *pData, long lFlags, long lLen)
{
	CMD_STRUCT_PRINT_REPORT cmdInfo;
	
	cmdInfo.lOriginTrans = lTerminalType;
	cmdInfo.lDeviceNumber = lTerminalNumber;	
	cmdInfo.lFlags	= 0L;
	memcpy(&cmdInfo.data, pData, REPORT_TEXT_LENGTH );
	cmdInfo.lTextLength = lLen;

	SetCommand( CMD_PRINT_REPORT, 
				SERVER_POS_NUMBER, 
				0L,
				&cmdInfo,
				sizeof(CMD_STRUCT_PRINT_REPORT));
}


BOOL CServerMain::ServiceModeNotValid(long lServiceMode)
{
	if( (lServiceMode >= 0) && (lServiceMode <= MAX_SERVICE_LEVEL))
		return FALSE;
	else
		return TRUE;
}

long CServerMain::GetAviTrsTimeOut()
{
	return (long)m_dwAviTrsTimeOut;
}

//add by Yaron
long CServerMain::GetMemoInterval()
{
	return (long)m_dwMemoInterval;
}


void CServerMain::SetWetStockClearTime(long lWetStockClearTime)
{
	m_dwWetStockClearTime = lWetStockClearTime;
}

long CServerMain::GetWetStockClearTime()
{
	return (long)m_dwWetStockClearTime;
}

// TD 351225
DWORD CServerMain::GetWetStockStateTimeout()  
{
	return m_dwWetStockStateTimeout;
}

//4.0.21.500 TD 66935:
void CServerMain::SetPumpLockTimeOut(DWORD dwPumpLockTimeOut)
{
	m_dwPumpLockTimeOut = dwPumpLockTimeOut;
}

DWORD CServerMain::GetPumpLockTimeOut()
{
	return m_dwPumpLockTimeOut;
}

void CServerMain::SetMemoInterval(long lMemoInterval)
{
	m_dwMemoInterval = lMemoInterval;
}


// Function name	: CServerMain::CreateTanksTable
// Description	    : Creates the Tanks table in the registry
// Return type		: void 
void CServerMain::LoadTanksTable(BOOL bRun)
{
	// 3.1.0.0  start
	int i;
	DWORD dwTmp;

	//3.1.1.72	
	m_cParam.LoadParam("Tanks", "TanksUnitsSetup",&dwTmp,(DWORD)1,TRUE);
	//3.1.1.72
	
	//4.0.3.36
	m_cParam.LoadParam("Tanks", "LevelFactor",&dwTmp, (DWORD)1,	TRUE);
	
	m_cParam.LoadParam("Tanks", "TemperatureFactor",&dwTmp, (DWORD)1,	TRUE);//4.0.3.51
	
	//3.2.0.41
	m_cParam.LoadParam("Tanks", "VolumeMultiply",&dwTmp, (DWORD)1,	TRUE);
	//3.2.0.41

	//4.0.14.501
	m_cParam.LoadParam("Tanks", "ActiveTankConnectedPumpsTable",&dwTmp, (DWORD)1,	TRUE);


	for(i = 1; i <= MAX_TANKS; i++)
	{
		CString str("Tanks\\Tank");
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PureProduct",&dwTmp,(DWORD)1,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "MinDelivery",&dwTmp,(DWORD)150,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpLinkMap",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "LogicTanks",&dwTmp,(DWORD)0,TRUE);

		//add by Yaron for Tank configuration
		m_cParam.LoadParam((char *)((LPCTSTR)str), "FullHeightVolume",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankDiameter",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankTilt",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "StickHeightOffset",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankDeliveryDelay",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankLowLevelLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankHighLevelLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankOverfillLevel",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankHighWaterLevel",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankSuddenLossLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankLeakAlarmLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankHighWaterWarningLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankMaxVolumeLimit",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankDeliveryRequired",&dwTmp,(DWORD)0,TRUE);

		//The CRC field
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ParamCRC",&dwTmp,(DWORD)0,TRUE);

		//Eyal 4.0.0.79 64 pump support
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpLinkMap2",&dwTmp,(DWORD)0,TRUE);

		//4.0.13.501
		m_cParam.LoadParam((char *)((LPCTSTR)str), "LeakThresholdVolume",&dwTmp,(DWORD)0,TRUE);
		//4.0.22.1400
		m_cParam.LoadParam((char *)((LPCTSTR)str), "MaxPumpFlowRate",&dwTmp,(DWORD)0,TRUE);

		//4.0.13.508
		m_cParam.LoadParam((char *)((LPCTSTR)str), "MaximumVolumeWarning",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TankHeight",&dwTmp,(DWORD)0,TRUE);

		//4.0.17.501 - CR 44000
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AccumulatedValue",&dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AccumulatedVolume",&dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);

		//4.0.20.52 (62818)		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "StartDeliveryVolume", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "EndDeliveryVolume", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "StartDeliveryTemperature", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "EndDeliveryTemperature", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AccumulatedDeliverySales", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);

		//4.0.21.500 - TD 66935
		m_cParam.LoadParam((char *)((LPCTSTR)str), "StartDeliveryWaterVolume", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "EndDeliveryWaterVolume", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);

		//4.0.20.501 - TD 65174
		m_cParam.LoadParam((char *)((LPCTSTR)str), "DeliveryReference", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);

		//4.0.21.500 - TD 66935
        m_cParam.LoadParam((char *)((LPCTSTR)str), "FoundDelivery", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);

		//4.0.21.500 - TD 66935
        m_cParam.LoadParam((char *)((LPCTSTR)str), "LockConnectedPumps", &dwTmp, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);

		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);

	}
			
}

//end add by yaron

BOOL CServerMain::AllowParallelAVIUsage()
{
	return m_bAllowParallelAVIUsage;
}

void CServerMain::DeleteMiscInfo(long lPump)
{
	if (lPump > 0)
	{
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		CPumpStatus pumpStat = m_cPumpArray[lPump - 1].GetStat(); 
		long lMisc = pumpStat.GetMisc();
		BOOL bFound = FALSE;
		
		//4.0.2.23
		long lMessage = pumpStat.GetMessage();

		if (lMessage == PUMP_MSG_CARD_ENCRYPTION)
		{
			pumpStat.SetMessage(0);
			bFound = TRUE;
		}
		//4.0.2.23
		 
		//4.0.3.27
		if ((pumpStat.GetError() == SYS_ERROR_NON_SPECIFIC) && (pumpStat.GetDevice() == TERMINAL_PRINTER))
		{
			pumpStat.SetDeviceError(0, NO_DEVICE);
			bFound = TRUE;
		}

		if (lMisc & MISC_NEED_MORE_PARAM)
		{
			lMisc &=MISC_NOT_NEED_MORE_PARAM;
			pumpStat.SetMisc(lMisc);
			bFound = TRUE;
		}

		if (bFound)
		{		
			m_cPumpArray[lPump -1].SetStat(pumpStat);			

		}
	}
}

unsigned int CALLBACK CServerMain::OLAThread(void *pv)
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if (pv == NULL )
		return -1;    // illegal parameter
		//return;

    COLAThreadInfo* pInfo = (COLAThreadInfo*)pv;
	BOOL	bKillThread = FALSE;
	
	while (TRUE)
	{
		// Wait until the main application thread asks 
		// this thread to start.
		if (WaitForSingleObject(pInfo->m_hEventStartThread, INFINITE)
			!= WAIT_OBJECT_0)
			break; //  Terminate this thread by existing the proc.

		// Exit the thread if the main application sets the "kill thread"
		// event.
		if (WaitForSingleObject(pInfo->m_hEventKillThread, 0)
			== WAIT_OBJECT_0)
			break; // Terminate this thread by existing the proc.
		
		bKillThread = FALSE;
	
		while (TRUE)	
		{			

			if (WaitForSingleObject(pInfo->m_hEventKillThread, 0)
				== WAIT_OBJECT_0)
			{
				pInfo->m_pServer->m_cLogger.LogMsg("OLA Thread Killed");
				bKillThread = TRUE;
				break; // Terminate this thread by existing the proc.			
			}

			if (WaitForSingleObject(pInfo->m_hEventStopThread, 0)
				== WAIT_OBJECT_0)
			{
			
				break; // Terminate main loop and wait for start
			}
			
			// wait until we need Ola process
			WaitForSingleObject(pInfo->m_hEventOLACmd,INFINITE);				

			switch(pInfo->m_pServer->m_lOLACmdType)
			{
				case  OLA_REQUEST_TO_SEND:
				{
					try
					{

						pInfo->m_pServer->m_cOLASrv->m_lOlaRtc = pInfo->m_pServer->m_cOLASrv->StartSession(pInfo->m_pServer->m_cOLASrv->m_sOlaReqBuff,pInfo->m_pServer->m_cOLASrv->m_sOlaReqType);					
					}
					catch(...)
					{
						CString str;
						str.Format("catch StartSession exception.....");
						pInfo->m_pServer->m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.19.502
					}
					

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("StartSession, [lRtc=%ld]",pInfo->m_pServer->m_cOLASrv->m_lOlaRtc);
						pInfo->m_pServer->m_cLogger.LogMsg(str);							
					}

				}
				break;
				case OLA_WAIT_RESPONSE:
				{
					try
					{
						_bstr_t cwsBstrtBuffer(pInfo->m_pServer->m_cOLASrv->m_pbsrOlaBuffer, false);	//4.0.25.80 TD 142857
						CComBSTR cwsBstrBuffer((LPCSTR)cwsBstrtBuffer);									//4.0.25.80 TD 142857

						pInfo->m_pServer->m_cOLASrv->m_lOlaRtc = pInfo->m_pServer->m_cOLASrv->QuerySession(pInfo->m_pServer->m_cOLASrv->m_lSessionId, &cwsBstrBuffer.m_str);	//4.0.25.80 TD 142857

						pInfo->m_pServer->m_cOLASrv->m_pbsrOlaBuffer = cwsBstrBuffer.Copy();			//4.0.25.80 TD 142857
					}
					catch(...)
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("catch QuerySession exception.....");
							pInfo->m_pServer->m_cLogger.LogMsg(str,LOG_LEVEL_1);							
						}
					}


					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("QuerySession::lRtc=%ld",pInfo->m_pServer->m_cOLASrv->m_lOlaRtc);
						pInfo->m_pServer->m_cLogger.LogMsg(str);							
					}

				}
				break;
				case OLA_REQUEST_TO_SEND_MORE:
				{
					try
					{
						pInfo->m_pServer->m_cOLASrv->m_lOlaRtc = pInfo->m_pServer->m_cOLASrv->AddParams(pInfo->m_pServer->m_cOLASrv->m_lSessionId ,pInfo->m_pServer->m_cOLASrv->m_sOlaReqBuff);
					}

					catch(...)
					{
						CString str;
						str.Format("catch AddParams exception.....");
						pInfo->m_pServer->m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.19.502
					}

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("AddParams::lRtc=%ld",pInfo->m_pServer->m_cOLASrv->m_lOlaRtc);
						pInfo->m_pServer->m_cLogger.LogMsg(str);							
					}
				}
				break;
				case OLA_SEND_END:
				{
					try
					{
						pInfo->m_pServer->m_cOLASrv->m_lOlaRtc = pInfo->m_pServer->m_cOLASrv->EndSession(pInfo->m_pServer->m_cOLASrv->m_lSessionId);
					}
					catch(...)
					{
						CString str;
						str.Format("catch EndSession exception.....");
						pInfo->m_pServer->m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.19.502
					}

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("EndSession, SessionId=%ld, RetCode=%ld",pInfo->m_pServer->m_cOLASrv->m_lSessionId , pInfo->m_pServer->m_cOLASrv->m_lOlaRtc);
						pInfo->m_pServer->m_cLogger.LogMsg(str);							
					}
				}
				break;
				case OLA_SEND_ENDEX:
				{
					try
					{
						pInfo->m_pServer->m_cOLASrv->m_lOlaRtc = pInfo->m_pServer->m_cOLASrv->EndSessionEx(pInfo->m_pServer->m_cOLASrv->m_lSessionId ,pInfo->m_pServer->m_cOLASrv->m_lSessionResult);
					}
					catch(...)
					{
						CString str;
						str.Format("catch EndSessionEx exception.....");
						pInfo->m_pServer->m_cLogger.LogMsg(str,LOG_LEVEL_1); //4.0.19.502						
					}

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("EndSessionEx, SessionId=%ld, Session result=%ld RetCode=%ld",pInfo->m_pServer->m_cOLASrv->m_lSessionId ,pInfo->m_pServer->m_cOLASrv->m_lQuerySessionResult, pInfo->m_pServer->m_cOLASrv->m_lOlaRtc);
						pInfo->m_pServer->m_cLogger.LogMsg(str);							
					}
				}
				break;
			}
/*
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				CString str;
				str.Format("EndSession::SessionId Cmd=%ld", pInfo->m_pServer->m_lOLACmdType);
				pInfo->m_pServer->m_cLogger.LogMsg(str);							
			}
*/

			SetEvent(pInfo->m_hEventOLACmdDone);			
		}
		
		if(bKillThread) // exit loop due to kill command
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				CString str;
				str.Format("OLAThread, killed Thread");
			}

			break;	
		}
	}

	{
		CString str;
		 str.Format("OLAThread Terminate");
		_LOGMSG.LogMsg(str);	

		//pInfo->m_pServer->m_enmOlaThreadStatus = OLA_SERVER_OFF;
	}

	SetEvent(pInfo->m_hEventThreadKilled);	

	CoUninitialize();

	//4.0.2.15 When OLA connections fail, we kill the thread
	//as part of the retry process.  In order to avoid an 
	//infinite amount of retries, each thread death 
	//will decrement the retry counter by one.
	pInfo->m_pServer->m_cOLASrv->DecrementRetryAttemps();

	return 0;	
}

void CServerMain::CallOLA(long lCmdType, long lPump)
{
	CString str;
	m_lOLAPumpNumber = lPump;
	m_lOLACmdType = lCmdType;
	
	ResetEvent(m_COLAThreadInfo.m_hEventOLACmdDone);
	SetEvent(m_COLAThreadInfo.m_hEventOLACmd);

	str.Format("CallOLA Pump=%ld" , lPump);
	m_cLogger.LogMsg(lPump,LOG_PUMP,str);	
	
	if (WaitForSingleObject(m_COLAThreadInfo.m_hEventOLACmdDone ,  dwOlaWaitingMessTimeOut) != WAIT_OBJECT_0)		
	{		
		SendEventKillOla();
		str.Format("CallOLA, Interface not response!!!!!");
		_LOGMSG.LogMsg(str);	

	}
	else if (m_cOLASrv->m_lOlaRtc == OLASRV_COM_ERROR) // if we get ret code OLASRV_COM_ERROR, we can assume that OLa not Valid.
	{		
		SendEventKillOla();
		if (WaitForSingleObject(m_COLAThreadInfo.m_hEventThreadKilled, dwOlaWaitingMessTimeOut) == WAIT_OBJECT_0)
		{
			ResetEvent(m_COLAThreadInfo.m_hEventOLACmdDone);			
			m_hThreadOLA = NULL;
			CloseHandle(m_hThreadOLA);  // 3.1.1.4

			//4.0.1.32
			//No need to attempt to kill thread, because we have already killed it.
			m_cOLASrv->ReleaseService(FALSE);

			//A call to ReleaseService(FALSE)sets m_enmOlaThreadStatus to 
			//OLA_SERVER_WAIT_FOR_KILL.  However, the thread has already
			//been killed, so we set the OLA server state to OLA_SERVER_OFF
			m_enmOlaThreadStatus = OLA_SERVER_OFF;

			_LOGMSG.LogMsg("Ola thread Close OK.");	

		}
		else
		{
			str.Format("Ola thread  NOT Close OK!");
			_LOGMSG.LogMsg(str);	

		}

	
	}
}

void CServerMain::StartOLAThread()
{
	CString str;
	 str.Format("Create OLA thread");
	_LOGMSG.LogMsg(str);	


	if (!m_hThreadOLA)
	{
		m_COLAThreadInfo.m_pServer = this;
		
	//	m_hThreadOLA = (HANDLE) _beginthreadex(	NULL,
	//							0,
	//							OLAThread,
	//							&m_COLAThreadInfo,
	//							0,
	//							&m_usOLAThreadId );

		m_hThreadOLA = (HANDLE) CreateThread(NULL,
								0,
								(LPTHREAD_START_ROUTINE )OLAThread,
								&m_COLAThreadInfo,
								0,
								&m_dwOLAThreadId );
	}else
	{
		 str.Format("StartOLAThread, OLA thread Exist");
		_LOGMSG.LogMsg(str);	
	}

}

OlaSrvStatus CServerMain::CheckOLA()
{
	CString str;
	OlaSrvStatus enmStatus = m_enmOlaThreadStatus;

	switch (enmStatus)
	{
		case OLA_SERVER_OFF: 
		{
			m_enmOlaThreadStatus = OLA_SERVER_WAIT_FOR_START;
			StartOLAThread();
		}
		break;
		case OLA_SERVER_ON : 
			break;
		case OLA_SERVER_WAIT_FOR_KILL: 
		{
			if (WaitForSingleObject(m_COLAThreadInfo.m_hEventThreadKilled, 200) == WAIT_OBJECT_0)
			{
				ResetEvent(m_COLAThreadInfo.m_hEventOLACmdDone);
				m_cLogger.LogMsg("CheckOLA() Reset event");	
				m_hThreadOLA = NULL;
				m_cOLASrv->ReleaseService(FALSE);				
				m_enmOlaThreadStatus = OLA_SERVER_OFF;
			}			
		}
		break;
		case OLA_SERVER_WAIT_FOR_START: 
		{
			SetEvent(m_COLAThreadInfo.m_hEventStartThread);
			m_enmOlaThreadStatus = OLA_SERVER_ON;
		}
		break;
		default:
			break;

	}
	enmStatus =m_enmOlaThreadStatus;

//	str.Format("CServerMain::CheckOLA =%d" , enmStatus);
//	_LOGMSG.LogMsg(str);	


	return (enmStatus);
}


void CServerMain::DeleteOLAThreadInfo()
{
	CString str;
	 str.Format("Start CServerMain::Delete OLA Thread Info");
	_LOGMSG.LogMsg(str);	
	
	if (m_COLAThreadInfo.m_hEventOLACmd)
		CloseHandle(m_COLAThreadInfo.m_hEventOLACmd);	
	if (m_COLAThreadInfo.m_hEventOLACmdDone)
		CloseHandle(m_COLAThreadInfo.m_hEventOLACmdDone);	
	if (m_COLAThreadInfo.m_hEventStartThread)
		CloseHandle(m_COLAThreadInfo.m_hEventStartThread);
	if (m_COLAThreadInfo.m_hEventStopThread)
		CloseHandle(m_COLAThreadInfo.m_hEventStopThread);
	if (m_COLAThreadInfo.m_hEventKillThread)
		CloseHandle(m_COLAThreadInfo.m_hEventKillThread);
	if (m_COLAThreadInfo.m_hEventThreadKilled)
		CloseHandle(m_COLAThreadInfo.m_hEventThreadKilled);
	
	 str.Format("End   CServerMain::Delete OLA Thread Info");
	_LOGMSG.LogMsg(str);	


}


void CServerMain::ConstructOLAThreadInfo()
{
	// OLA12345
	m_cLogger.LogMsg("ConstructOLAThreadInfo - Start");	
	m_COLAThreadInfo.m_hEventOLACmd = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_COLAThreadInfo.m_hEventOLACmdDone = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_COLAThreadInfo.m_hEventStartThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_COLAThreadInfo.m_hEventStopThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_COLAThreadInfo.m_hEventKillThread	= CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_COLAThreadInfo.m_hEventThreadKilled = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cLogger.LogMsg("ConstructOLAThreadInfo - End");	

}

void CServerMain::WriteToLogMsg(long lPumpNumber, BOOL bErrorRep, long lError, BOOL bWarningRep, long lWarning, BOOL bDeviceRep, long lDevice, long lDeviceCode, BOOL bMiscRep, long lMisc, long *pVal)
{
	long			p = 0;
	CPumpStatus		pumpStat;
	PumpDevice		Device;	

	if(lPumpNumber)
		p = lPumpNumber-1;

	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);
	
	// Pump device/error/warning/misc report
	if(lPumpNumber)
	{
		long lVal=0;
		pumpStat = m_cPumpArray[p].GetStat();

		if(bDeviceRep)
		{
			Device	= l2PumpDevice(lDevice);
			if(Device == UNKNOWN_DEVICE)
			{
				//retCode = GCI_UNKNOWN_PUMP_DEVICE;	
				*pVal = GCI_UNKNOWN_PUMP_DEVICE;	
			}
			else if (Device == RFID_ANTENNA)
			{
				switch (lMisc)
				{
					case PUMP_MSG_TAG_CHALLANGE_FAIL:
					case PUMP_MSG_TAG_GONE:
					case PUMP_MSG_TAG_NOT_FOUND:
					case PUMP_MSG_TAG_CHANGED:
					case PUMP_MSG_CAR_TAG_READ:
					case PUMP_MSG_HAND_TAG_READ:
					case PUMP_MSG_TAG_ERROR:
					case PUMP_MSG_TAG_SALE_CANCELED: //3.0.2.3
					case PUMP_MSG_TAG_SALE_DECLINED: //3.0.2.3
						pumpStat.SetMessage(lMisc);
						break;

					case PUMP_MSG_TAG_READ:
						//Determine if the tag his hand or car
						if ( pumpStat.GetResExt() == RES_EXT_RFID_CT )
							pumpStat.SetMessage(PUMP_MSG_CAR_TAG_READ);
						else if ( pumpStat.GetResExt() == RES_EXT_RFID_HT )
							pumpStat.SetMessage(PUMP_MSG_HAND_TAG_READ);
						else
							pumpStat.SetMessage(lMisc);
					
						break;			
					case PUMP_MSG_GENERAL_SPEED_PASS_DECLINE:  // 4.0.0.6
							pumpStat.SetMessage(lMisc);
						break;

					case PUMP_NO_MSG:
					default:;
				}
			}
			else 
			{
				BOOL bMessageReport = TRUE;
				if(bErrorRep)
				{
					if (_ALARM_SRV.m_lAlarmSrvActive & (!bMiscRep))
					{
						WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);									 
					}
					else
						pumpStat.SetDeviceError(lError,Device);

					bMessageReport = FALSE;
				}
				if(bWarningRep)
				{
					if (_ALARM_SRV.m_lAlarmSrvActive & (!bMiscRep))
					{
						WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
					}
					else
						pumpStat.SetDeviceWarning(lWarning,Device);
					
					bMessageReport = FALSE;
				}
				if ( bMessageReport )
				{
					if ((_ALARM_SRV.m_lAlarmSrvActive) && 
						(lDevice ==TERMINAL_CARD_READER) &&  
						(lMisc == PUMP_MSG_CARD_ENCRYPTION))
					{
						WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
					}
					else
						pumpStat.SetMessage(lMisc);
				}
			}
		}
		else
		{
			if(bErrorRep)
			{
				if (_ALARM_SRV.m_lAlarmSrvActive & (!bMiscRep))
				{
					WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
				}
				else
					pumpStat.SetError(lError);
			}
				
			if(bWarningRep)
			{
				if (_ALARM_SRV.m_lAlarmSrvActive & (!bMiscRep))
				{
					WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
				}
				else
					pumpStat.SetWarning(lWarning);
			}
		}

		if(bMiscRep)
		{
			long lPumpMisc = pumpStat.GetMisc();
			switch(lMisc)
			{
				case PUMP_MISC_EVENT_HELP_KEY:
					lPumpMisc |= MISC_HELP_REQUEST;
					break;
				case PUMP_MISC_EVENT_CANCEL_KEY:
					// In case RFID transaction was cancelled pass it as a message to the POS.
					if ( (pumpStat.GetResExt() == RES_EXT_RFID_CT) || (pumpStat.GetResExt() == RES_EXT_RFID_HT) )
						pumpStat.SetMessage(PUMP_MSG_TAG_CANCELLED);
					break;
				case PUMP_MISC_EVENT_CARD_SWIPE_ERROR:
					break;
			}
			pumpStat.SetMisc(lPumpMisc);
		}
	}
	else // System error/warning/misc report
	{			
		if(bErrorRep) // Reported to POS status line  example - Sys shout down
		{
			if (_ALARM_SRV.m_lAlarmSrvActive && (!bMiscRep))
			{
				WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
			}
			else
				m_lSysError = lError;
		}

		if(bWarningRep)
		{
			if (_ALARM_SRV.m_lAlarmSrvActive && (!bMiscRep))
			{
				WriteToAlarmSrv(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc, pVal);
			}
			else
				m_lSysWarning = lWarning;
		}

		//4.0.2.0.
		if (_ALARM_SRV.m_lAlarmSrvActive  && bMiscRep)
		{
			CAlarmConvert cAlarmConvert;			
			long lRetMisc=  cAlarmConvert.ConvertMiscAlarmCode(lPumpNumber, lDevice, bErrorRep, lError, bMiscRep, lMisc, pVal);

			if (lRetMisc)
			{
				m_lSysMisc = lMisc;								
			}
		}
		else if(bMiscRep) // Reported to POS status line example - in 5 minutes
		{
			m_lSysMisc = lMisc;			
		}
	}
	
	_LOGMSG.LogGCIReport(lPumpNumber,bErrorRep,lError,bWarningRep,lWarning,bDeviceRep,lDevice,lDeviceCode,bMiscRep,lMisc);

	if ((!_ALARM_SRV.m_lAlarmSrvActive) || bMiscRep)
		if(lPumpNumber)
			m_cPumpArray[p].SetStat(pumpStat);


	// M.L 8/5/98 Lock PumpArray in large scope 
	//-----------------------------------------
}

 void CServerMain::CloseOLAThread(BOOL bShutDown)
{
	CString sStr;
	long	lRtc = 0;
	DWORD dwRet=0;

	sStr.Format("CloseOLAThread()  Thread status=%d " , m_enmOlaThreadStatus);
	m_cLogger.LogMsg(sStr);	

	if (m_hThreadOLA)
	{
		// Do not try to call to OLA
		m_lOLACmdType = 0;

		m_cOLASrv->m_lOlaRtc = OLASRV_COM_ERROR;
		m_lOLAPumpNumber = 0;
		m_lOLACmdType = 0;
		//SetEvent(m_COLAThreadInfo.m_hEventStartThread);
		SetEvent(m_COLAThreadInfo.m_hEventKillThread);				
		SetEvent(m_COLAThreadInfo.m_hEventOLACmd);
		
		if (WaitForSingleObject(m_COLAThreadInfo.m_hEventThreadKilled , 1000) == WAIT_OBJECT_0)
		{
			sStr.Format("CloseOLAThread:: Close Ok.");
			m_cLogger.LogMsg(sStr);						
		}
		else
		{
			sStr.Format("CloseOLAThread Force Close!!!!! ");
			m_cLogger.LogMsg(sStr);						

			try
			{
				lRtc=  TerminateThread(m_hThreadOLA,0);
			}
			catch(...)
			{
				sStr.Format("CloseOLAThread Exception !!!!! ");
				m_cLogger.LogMsg(sStr,LOG_LEVEL_1);	
				
				dwRet = GetLastError();
			}

			sStr.Format(" CloseOLAThread() Force Close !!!!  Rtc=%ld exception=%ld", lRtc , dwRet);
			m_cLogger.LogMsg(sStr,LOG_LEVEL_1);									
		}

		// When we are in middle of shutdown, do not operate alarm. 
		if (!bShutDown)  //4.0.5.24 
		{
			//4.0.2.38
			if (GetAlarmSrvMode() == ALRMSRV_DIRECT_ACTIVE)
			{
				// Clear OLA error
				if (m_cAlarm.m_lAlarmSpecialGroupMap[ALARM_GROUP_OLA])
					lRtc = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE, SUB_PUMPSRV, SOFTWARE_GENERAL_OLA_ERR,0,1,0,0);
			}
			else  //4.0.2.38
				WriteToLogMsg(0, TRUE, SYS_ERROR_OLA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, &lRtc);	

		}

		// start 3.1.0.23
		CloseHandle(m_hThreadOLA);
		// End 3.1.0.23

	}	
	
	m_hThreadOLA = NULL;
	m_enmOlaThreadStatus = OLA_SERVER_OFF;

	sStr.Format("CloseOLAThread, End=%d" , m_enmOlaThreadStatus);
	m_cLogger.LogMsg(sStr);	
}

OlaSrvStatus CServerMain::GetOLAThreadState()
{
	return (m_enmOlaThreadStatus);
}

BOOL CServerMain::GetPosVoidFlags()
{
	return bPostVoidActive;
}



//4.0.12.502
BOOL CServerMain::GetCashAcceptorActive()
{
	return bCashAcceptorActive;
}

void CServerMain::SetPosVoidFlags(BOOL bFlags)
{
	bPostVoidActive = bFlags;
}


//4.0.12.502
void CServerMain::SetCashAcceptorValid(BOOL bFlags)
{
	bCashAcceptorActive = bFlags;
}

int CServerMain::FindTrsByTrsNumber(long lTrsNumber)
{
int iRetNum = 1; // not found	
	int iArraySize;
	CPumpTransact trs;


	if(lTrsNumber != 0)
	{
		for (int p=0; p< m_lLastValidPump; p++)  //4.0.0.79
		{
			iArraySize = m_cPumpArray[p].GetTrsArraySize();
			
			if(iArraySize)
			{
				for (int i=0; i<iArraySize; i++)
				{
					m_cPumpArray[p].GetTrsByIndex (i,&trs);
					if (( trs.m_lNumber == lTrsNumber) &&
						(trs.GetStatus() != PAID))						
					{
						iRetNum = 0; // found
						break;
					}
				}
			}
		}
	}	
	return iRetNum;
}

long CServerMain::SendEventKillOla()
{
	long lRtc= 0;
	CString str;
	str.Format("SendEventKillOla --> Send Event To Kill ola thread");
	_LOGMSG.LogMsg(str);	
	m_lOLAPumpNumber = 0;
	m_lOLACmdType    = 0;
	SetEvent(m_COLAThreadInfo.m_hEventKillThread);			
	SetEvent(m_COLAThreadInfo.m_hEventOLACmd);	
	m_enmOlaThreadStatus = OLA_SERVER_WAIT_FOR_KILL;
	//4.0.2.38
	if (GetAlarmSrvMode() == ALRMSRV_DIRECT_ACTIVE)
	{
		// Clear OLA error
		if (m_cAlarm.m_lAlarmSpecialGroupMap[ALARM_GROUP_OLA])
			lRtc = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE, SUB_PUMPSRV, SOFTWARE_GENERAL_OLA_ERR,0,1,0,0);
	}
	else  //4.0.2.38
		WriteToLogMsg(0, TRUE, SYS_ERROR_OLA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, &lRtc);		 
	return 0;
}

long CServerMain::CheckExistUnBalancePrePay()
{
	PRE_PAY_INFO	cTmpPrePayinfo;	
	CPumpTransact		trs;
	long	lRtc;
	trs.SetLink(TRS_LINK_PREPAY_NUMBER, 0);
	
	lRtc = TrsLinkOperation(REC_READ_FIRST,&trs,&cTmpPrePayinfo);

	if ((lRtc == ERR_NOT_FOUND) || (lRtc == ERR_EXISTS))
	{
		for(int i=1; i <= m_lMaxPumps; i++)  //4.0.0.79
		{
			CString str("Pumps\\Pump");
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",i);
			str += sNumber;				
			m_cParam.SaveParam((char *)((LPCTSTR)str),"UnbalancePrePayCounter",(DWORD)0,FALSE,_HOST.m_lGroupNum,0,i,TRUE);//4.0.3.27 //4.0.8.505
		}
	}	
	return 0;
}

void CServerMain::InitOLAThreadInfo()
{
	m_hThreadOLA = NULL;
	m_COLAThreadInfo.m_hEventOLACmd = NULL;		
	m_COLAThreadInfo.m_hEventOLACmdDone = NULL ;		
	m_COLAThreadInfo.m_hEventStartThread = NULL;		
	m_COLAThreadInfo.m_hEventStopThread = NULL ;
	m_COLAThreadInfo.m_hEventKillThread = NULL;		
	m_COLAThreadInfo.m_hEventThreadKilled = NULL;		
	_LOGMSG.LogMsg("InitOLAThreadInfo");
}


/****All this folowing functions for the Ctrl event handling******/

// Function name	: CServerMain::GetCtrlEventClientId
// Description	    : Retrieve a unide client id.
// Return type		: long 
long CServerMain::GetCtrlEventClientId()
{
	m_lCtrlEventNumerator ++;

	return m_lCtrlEventNumerator;
}

// Function name	: CServerMain::ResetCtrlEventNumerator
// Description	    : Resets the Ctrl Event clientid Numerator to 0.
// Return type		: void 
void CServerMain::ResetCtrlEventNumerator()
{
	m_lCtrlEventNumerator = 0;
}

// Function name	: CServerMain::RemoveCtrlEventPtr
// Description	    : Removes client Event Ptr from container due to clientId.
// Return type		: long 
// Argument         : long lClientId
long CServerMain::RemoveCtrlEventPtr(long lClientId)
{
	BOOL bRes = FALSE;
	long lRetVal = 0;

	bRes = m_CtrlEventsObjMap.RemoveKey(lClientId);

	//checking if last client to reset client id
	if( m_CtrlEventsObjMap.IsEmpty() )
	{
		ResetCtrlEventNumerator();
	}
		
	return lRetVal;
}

// Function name	: CServerMain::AddCtrlEventClient
// Description	    : Add new CtrlEvent client to ptr map due to client id.
// Return type		: long 
// Argument         : long lClientId
// Argument         : ICtrlEvents *pCtrlObj
long CServerMain::AddCtrlEventClient(long lClientId, ICtrlEvents *pCtrlObj)
{
	long lRetVal = 0;

	m_CtrlEventsObjMap.SetAt(lClientId,pCtrlObj);
	
	return lRetVal;
}


// Function name	: CServerMain::InitEventThreadInfo
// Description	    : Inits the Event thread info.
// Return type		: void 
void CServerMain::InitEventThreadInfo()
{
	m_hEventThread = NULL;
	//m_lEventThreadStatus = 0;//stopped  //4.0.2.27
	m_cEventsThreadInfo.m_hEventStartThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cEventsThreadInfo.m_hEventStopThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cEventsThreadInfo.m_hEventKillThread	= CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cEventsThreadInfo.m_hEventThreadKilled = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cEventsThreadInfo.m_pServer = this;	
}


// Function name	: CServerMain::DeleteEventThreadInfo
// Description	    : Deletes the Event thread info.
// Return type		: void 
void CServerMain::DeleteEventThreadInfo()
{
	// Kill the worker thread by setting the "kill thread" event.
	SetEvent(m_cEventsThreadInfo.m_hEventKillThread);
	SetEvent(m_cEventsThreadInfo.m_hEventStartThread); 
	WaitForSingleObject(m_cEventsThreadInfo.m_hEventThreadKilled, INFINITE);
	
	CloseHandle(m_cEventsThreadInfo.m_hEventStartThread);
	CloseHandle(m_cEventsThreadInfo.m_hEventStopThread);
	CloseHandle(m_cEventsThreadInfo.m_hEventKillThread);
	CloseHandle(m_cEventsThreadInfo.m_hEventThreadKilled);

	CloseHandle(m_hEventThread);
	m_hEventThread = NULL;
}


// Function name	: CServerMain::CreateEventThread
// Description	    : Create the Event thread and start it.
// Return type		: void 
void CServerMain::CreateEventThread()
{
	_LOGMSG.LogMsg("Event thread create");

	InitEventThreadInfo();

	if (!m_hEventThread)
	{
		m_hEventThread = (HANDLE) CreateThread(NULL,
								0,
								(LPTHREAD_START_ROUTINE )EventsThread,
								&m_cEventsThreadInfo,
								0,
								&m_dwEventThreadId );
		if(m_hEventThread)
		{

			// change to proirity of events Threads to be lowest for normal, 
			//4.0.2.27 
			BOOL bThreadPriprity = SetThreadPriority(m_hEventThread,THREAD_PRIORITY_LOWEST);
			DWORD dwLastError =GetLastError();

			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString sMsg;
				sMsg.Format("Event thread set to THREAD_PRIORITY_LOWEST=%d, lastError=%ld ",bThreadPriprity , dwLastError );
				m_cLogger.LogMsg(sMsg);
			}

			//4.0.2.27 

			StartEventThread();	
		}
	}
	else
	{
		m_cLogger.LogMsg("StartEventThread, Event thread Exist");
	}
}


// Function name	: CALLBACK CServerMain::EventsThread
// Description	    : The Event thread START_ROUTINE
// Return type		: unsigned int 
// Argument         : void *pv - actually the CEventsThreadInfo struct.
unsigned int CALLBACK CServerMain::EventsThread(void *pv)
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if (pv == NULL )
		return -1;    // illegal parameter

    long lRetVal = 0;
	CEventsThreadInfo*	pInfo = (CEventsThreadInfo*)pv;
	BOOL				bKillThread = FALSE;
	DWORD				dwSleepTime = 0;

	if(LOG_BASIC_FLOW_CONTROL)
	{	
		char sStr[MAX_FIELD_VAL];
		sprintf_s(sStr, _countof(sStr),"EventsThread - start ");
		_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
	}

	while (TRUE)
	{
		// Wait until the main application thread asks 
		// this thread to start.
		if (WaitForSingleObject(pInfo->m_hEventStartThread, INFINITE)
			!= WAIT_OBJECT_0)
			break; //  Terminate this thread by existing the proc.

		// Exit the thread if the main application sets the "kill thread"
		// event.
		if (WaitForSingleObject(pInfo->m_hEventKillThread, 0)
			== WAIT_OBJECT_0)
			break; // Terminate this thread by existing the proc.
		
		bKillThread = FALSE;
				
		while (TRUE)	
		{			

			if (WaitForSingleObject(pInfo->m_hEventKillThread, 0)
				== WAIT_OBJECT_0)
			{
				bKillThread = TRUE;
				break; // Terminate this thread by existing the proc.			
			}

			if (WaitForSingleObject(pInfo->m_hEventStopThread, 0)
				== WAIT_OBJECT_0)
			{
				break; // Terminate main loop and wait for start
			}

			lRetVal = pInfo->m_pServer->m_cEventManager.FireCtrlEvent();
			dwSleepTime = EVENT_THRD_SLEEP_TIME;							//4.0.26.508	TD 211718
			
			lRetVal = pInfo->m_pServer->m_cGPIEventMgr.FireGPIEvent();		//4.0.12.501
			//4.0.26.508	TD 211718
			if (lRetVal == OK)				
				dwSleepTime = 0;
						
			Sleep(dwSleepTime);				
		}
		
		if(bKillThread) // exit loop due to kill command
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				char sStr[MAX_FIELD_VAL];
				sprintf_s(sStr, _countof(sStr),"EventsThread - End ");
				_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
			}

			break;	
		}
	}
					
	SetEvent(pInfo->m_hEventThreadKilled);	
	CoUninitialize();
	return 0;
}


// Function name	: CServerMain::StartEventThread
// Description	    : Starts the Event thread by setting the start event.
// Return type		: void 
void CServerMain::StartEventThread()
{
	//4.0.2.27
	//if(m_lEventThreadStatus == THREAD_STOPPED_STATE)
	//{
	//	SetEvent(m_cEventsThreadInfo.m_hEventStartThread);
	//	m_lEventThreadStatus = THREAD_STARTED_STATE; //started
	//}
	//4.0.2.27

	SetEvent(m_cEventsThreadInfo.m_hEventStartThread);
	//4.0.2.27
}


// Function name	: CServerMain::StopEventThread
// Description	    : Stopes the Event thread by setting the stop event.
// Return type		: void 
void CServerMain::StopEventThread()
{
	//4.0.2.27
	//if(m_lEventThreadStatus == THREAD_STARTED_STATE)
	//{
	//	SetEvent(m_cEventsThreadInfo.m_hEventStopThread);
	//	m_lEventThreadStatus = THREAD_STOPPED_STATE; //stop
	//}

	SetEvent(m_cEventsThreadInfo.m_hEventStopThread);
	//4.0.2.27
}

// Cheak validity PAP amount 
long CServerMain::IsValidPAPAmount(long lPumpNumber , long lPreAuthorizedAmount, char sTranType , long lPreAuthorizedVolume)
{
long  lServiceFee = 0;		
 long  lRetCode = 0;
 long  lTrsType = 0; 


   //  3.2.0.69
   if (lPreAuthorizedVolume)
   {
		return 0; 	
   }

    switch(sTranType)
	{
	case CD_TYPE_AVI:
			GetServiceFeeInfo(lPumpNumber, SERVICE_TYPE_AVI, 0, NULL, GET_FEE_BY_TRANSACTION_TYPE, &lServiceFee, &lRetCode);
		break;
	case CD_TYPE_CREDIT:
	case CD_TYPE_DEBIT:
			GetServiceFeeInfo(lPumpNumber, SERVICE_TYPE_PAP, 0, NULL, GET_FEE_BY_TRANSACTION_TYPE, &lServiceFee, &lRetCode);
		break;

	default:
		break;
	}
		
	// In case problem in service fee 
	if (lRetCode)
	{
		lServiceFee = 0;
	}

	//
	if (!lPreAuthorizedAmount)
	{
		lPreAuthorizedAmount  = GetLimit(PRICE_LEVEL_CREDIT,lPumpNumber);
	}
	else
	{
		/* 4.0.1.40
		if ( GetRegion() == REGION_ISRAEL )
		{
			lPreAuthorizedAmount *= 1000;
		}
		*/ //4.0.1.40
	}

	if ((lPreAuthorizedAmount - lServiceFee) > 0)
		return 0;
	else
	{
		CString str;	
		str.Format("Credit Decline on Validity Amount !!!! Pre Authorized Amount=%ld , Service Fee=%ld" ,  lPreAuthorizedAmount, lServiceFee); 
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);	
		return 1;
	}

}

void CServerMain::GetServiceFeeInfo(long lPump, long lTrsType, long lTrsNumber, BSTR stTime, long lFlags, long *pValue, long *pRetVal)
{
	ServiceFeeRetCode  FeeRetCode =SERVICE_FEE_OK;
	
	SZ_TAG_SYSTEMTIME szTagTime;
	DWORD dwLastErr = 0;
	SYSTEMTIME sysTime ;
	long lIndexServiceFee = 0;
	long lTrsTypeTmp = lTrsType;
	BOOL bChanrgeServiceFee =TRUE;
	
	
	*pValue  = 0;

	if (!UseServiceFee())
		FeeRetCode = SERVICE_FEE_NOT_VALID;
	else if (PUMP_NOT_VALID(lPump))
		FeeRetCode = SERVICE_FEE_INVALID_PUMP_NUMBER;
		
	lIndexServiceFee = GetManualServiceFee();  //4.0.8.503
		

	if ((FeeRetCode == CTRL_OK) && (!lIndexServiceFee))  //4.0.8.503
	{
			
		switch(lFlags)
		{
			case GET_FEE_BY_TRS_NUM:
			{
				CPumpTransact  trs;

				if(!m_cPumpArray[lPump - 1].GetTrsByNumber(lTrsNumber,&trs))
				{
					//4.0.2.1.162
					if (GetMinFullingToChargeServiceFee() > trs.m_lRoundedValue)
					{
						bChanrgeServiceFee = FALSE;
					}
					else
					{
						trs.GetTime().GetAsSystemTime(sysTime);
						lIndexServiceFee = FindServiceFee(lPump ,  sysTime , lTrsTypeTmp);

						//3.0.3.11
						if(trs.m_lRes == PRE_PAY_AT_POS)
						{
							lTrsTypeTmp = SERVICE_TYPE_PREPAY;
						}
						else if(trs.m_lRes == PAY_AT_PUMP)
						{
							if (trs.m_lResExt == RES_EXT_AVI)
								lTrsTypeTmp = SERVICE_TYPE_AVI;
							else
								lTrsTypeTmp = SERVICE_TYPE_PAP;
						}
						else
						{
							//4.0.2.29
							if (trs.m_lResExt == RES_EXT_ATTENDANT)
								lTrsTypeTmp = SERVICE_TYPE_ATTEND;
							else
								lTrsTypeTmp = SERVICE_TYPE_PAK;
							//4.0.2.29
						}					
	/*					if(trs.GetLinkFlags() & TRS_LINK_PREPAY_NUMBER)
						{
							lTrsTypeTmp = SERVICE_TYPE_PREPAY;
						}
						else if(trs.GetLinkFlags() & TRS_LINK_OLA_NUMBER)
						{
							lTrsTypeTmp = SERVICE_TYPE_PAP;
						}
						else
						{
							lTrsTypeTmp = SERVICE_TYPE_PAK;
						}					
	*/
					}
					
				}
				else
				{
					FeeRetCode = SERVICE_FEE_TRS_NOT_FOUND;
				}
			}
					
			break;
			case GET_FEE_BY_TIME:
			{
				// Geting fee by date must send the trsnumber ...
				int iLen=0;  // marik
				memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));
				if (stTime == NULL)
				{
					iLen = 0;
				}else
					iLen = WideCharToMultiByte(CP_ACP,0,stTime,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);

				if(iLen == 0)
				{
					dwLastErr = GetLastError();
					GetLocalTime(&sysTime);
					//retCode = CTRL_LAST_ERROR;
				}else
				{
					szTagTime.sNull = 0;
					if (iLen != sizeof(TAG_SYSTEMTIME) + 1 )
					{
						GetLocalTime(&sysTime);
						CTime	cCurTime1(sysTime);
					}
					else
					{
						Tag2SystemTime(&szTagTime.sTime,&sysTime);		
					}				
				}
				lIndexServiceFee = FindServiceFee(lPump ,  sysTime , lTrsTypeTmp);
			}
			break;
			case GET_FEE_BY_TRANSACTION_TYPE:
			{				
				lIndexServiceFee = m_cPumpArray[lPump-1].GetCurrentServiceFee();
			}
			break;
			default:
				FeeRetCode = SERVICE_FEE_PARAM_NOT_FOUND;
		}
	}

	if ((lIndexServiceFee < 1) || 
		(lIndexServiceFee > MAX_SERVICE_FEE) ||
		(!m_cPumpArray[lPump -1].GetCurrentServiceFee())) //4.0.15.500
		FeeRetCode = SERVICE_FEE_PARAM_NOT_FOUND;

	//4.0.2.21
	if (FeeRetCode == GPI_OK && bChanrgeServiceFee)
	{
		long lRtc = 0;

		CServiceFee	ServiceFee;
		ServiceFee = m_cServiceFeeArray[lIndexServiceFee -1];
		
		long lServiceMode= m_cPumpArray[lPump-1].GetStat().GetServiceMode();
	
		
		//long lServiceFeeSet =  m_cModeSchemeArray[lServiceFeeSet].GetServiceFeeSet();//4.0.12.506
		long lServiceFeeSet =  m_cPumpArray[lPump-1].GetCurrentServiceFee() ; //4.0.12.519//m_cModeSchemeArray[lServiceMode].GetServiceFeeSet();//4.0.12.506
		

		long lManuelServiceFee = GetManualServiceFee();  //4.0.12.506
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("GetServiceFeeInfo ServiceFeeSet = %ld, ManuelServiceFee = %ld ",lServiceFeeSet,lManuelServiceFee  );
			m_cLogger.LogMsg(str);
		}

		if(lManuelServiceFee && !lServiceFeeSet)//4.0.12.506
			*pValue = 0;

		else
		{
		
			switch(lTrsTypeTmp)
			{
				case SERVICE_TYPE_PAK:
					*pValue = (lServiceMode == FULL_SERVICE_MODE)? ServiceFee.GetPakService():ServiceFee.GetSelfPakService();
					break;
				case SERVICE_TYPE_PREPAY:
					*pValue = (lServiceMode == FULL_SERVICE_MODE)? ServiceFee.GetPrePayService(): ServiceFee.GetSelfPrePayService();
					break;
				case SERVICE_TYPE_PAP:
					*pValue = (lServiceMode == FULL_SERVICE_MODE)? ServiceFee.GetPapService():ServiceFee.GetSelfPapService();
					break;
				case SERVICE_TYPE_AVI:
					*pValue = (lServiceMode == FULL_SERVICE_MODE)? ServiceFee.GetAviService():ServiceFee.GetSelfAviService();
					break;
				case SERVICE_TYPE_ATTEND:
					*pValue = (lServiceMode == FULL_SERVICE_MODE)? ServiceFee.GetAttendService():ServiceFee.GetSelfAttendService();
					break;
				default:
					FeeRetCode = SERVICE_FEE_PARAM_NOT_FOUND;
			}									
		}
	}
	/////////////////


	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetServiceFeeInfo return service fee = %ld",*pValue);
		m_cLogger.LogMsg(str);
	}
	*pRetVal = FeeRetCode;
}

// check that the link number is PAK
BOOL CServerMain::PakLinkNumber(long lLinkNumber)
{
	if ((TRS_NO_LINK == lLinkNumber) ||
		(lLinkNumber & TRS_LINK_PAK_AND_LOYALTY))
		return TRUE;
	else
		return FALSE;

}

//50269
BOOL CServerMain::MovePrepayGradesDiscounts(long lFromPumpNumber, long lToPumpNumber, EXTRA_INFO_REC *pOldExtraInfo, EXTRA_INFO_REC *pNewExtraInfo)
{
	TAG_DISCOUNT_MAP sTmpDiscountArray;
	long p = lFromPumpNumber -1;
	long lNumOfPosition = 0,lDiscount=0;  
	short iGradeNum = 0;
	long byNozzle = 0;
	CString str;
	BOOL bRetCode = FALSE;


	if(m_bControllerSupportNozzleRestrction)	//If not by nozzle, then array of discounts is already updated
	{

		memset(&sTmpDiscountArray.sDiscount , ' ', sizeof(sTmpDiscountArray.sDiscount)); 
		memcpy(pNewExtraInfo, pOldExtraInfo, sizeof(EXTRA_INFO_REC));
		
		//Init New pump's discounts
		for (int iGrade = 0; iGrade < MAX_GRADES; iGrade++)    // TD 462238
		{
			pNewExtraInfo->info.lDiscountArray[iGrade] = 0;

		}
		int iCountDiscount = 0;
		for (int i =1 ; i<= MAX_POSITIONS_PER_PUMP; i++)
		{

			iGradeNum = m_cPumpArray[p].NozzleToGrade(i);
			lDiscount = pOldExtraInfo->info.lDiscountArray[i-1];
			//lDiscount = a2l(cFromInfo.CardSaleExtraData2.sDiscountPerGrade[iGradeNum].sDiscount,sizeof(cFromInfo.CardSaleExtraData2.sDiscountPerGrade[iGradeNum].sDiscount));
			lNumOfPosition = m_cPumpArray[lToPumpNumber -1].GetNumOfPositionForGrade(iGradeNum);

			if (lDiscount > 0)
			{	
				
				if(LOG_BASIC_FLOW_CONTROL)
				{
					str.Format("Prepay old discount is for nuzzle %ld, grade number %ld, discount = %ld", i, iGradeNum,lDiscount);
					m_cLogger.LogMsg(str);
				}
			
				iCountDiscount++;
				if((lNumOfPosition>0))	//&&(lDiscount!=0))
				{
					byNozzle = m_cPumpArray[lToPumpNumber-1].GetGradePosition(iGradeNum);
					while ((byNozzle > 0) && (byNozzle <= MAX_POSITIONS_PER_PUMP))
					{	
						if(LOG_BASIC_FLOW_CONTROL)
						{
							str.Format("Prepay new discount is for nuzzle %ld, grade number %ld, discount = %ld", byNozzle, iGradeNum,lDiscount);
							m_cLogger.LogMsg(str);
						}
						pNewExtraInfo->info.lDiscountArray[byNozzle -1] = lDiscount;
						++byNozzle;
						m_cPumpArray[lToPumpNumber-1].GetGradePosition(iGradeNum, &byNozzle);
					}
				}
			}
		}
		if (!iCountDiscount)
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{
				str.Format("MovePrepayGradesDiscounts: No discounts were found");
				m_cLogger.LogMsg(str);
			}

		}

		bRetCode = TRUE;	
	}
	return bRetCode;
} 

BOOL CServerMain::ConvertWideCharLoyaltyInfo2RegularInfo(long lPumpNumber ,BSTR *sLoyaltyInfo, TAG_DISCOUNT_LOYALTY_INFO4 *pRec)	//4.0.20.450 66977 //4.0.21.501 //4.0.23.270 111746 //4.0.24.60

{
	BOOL				bRetCode = FALSE;
	DWORD				dwLastErr = 0;
	char szFieldVal[sizeof(TAG_DISCOUNT_LOYALTY_INFO4) * 2]; //4.0.20.480 66977 //4.0.22.0  //4.0.23.723 //4.0.25.503 144328	
	TAG_DISCOUNT_MAP	sTmpDiscountArray; 
	long				lNumOfPosition = 0,lDiscount=0;  //4.0.11.122
	BYTE				byNozzle = 0;
	CString				str;
	
	memset(szFieldVal,0,sizeof(szFieldVal));
	memset(pRec , ' ' , sizeof(TAG_DISCOUNT_LOYALTY_INFO4)); //4.0.20.450 66977 //4.0.21.501 //4.0.23.270 111746 //4.0.24.60

	int iLen = WideCharToMultiByte(CP_ACP,0,*sLoyaltyInfo,-1,szFieldVal,sizeof(szFieldVal),NULL,NULL);
	
	str.Format("CServerMain::ConvertWideCharLoyaltyInfo2RegularInfo insert method PumpNumber = %ld Len = %ld",lPumpNumber,iLen);
	m_cLogger.LogMsg(str);
	
	if(iLen == 0)
	{
		dwLastErr = GetLastError();
	}
	else
	{
		if (lPumpNumber)  //4.0.11.514
		{
			//4.0.20.450 66977 start //4.0.21.501
			if (iLen < sizeof(TAG_DISCOUNT_LOYALTY_INFO4)) //4.0.23.190 105087 do not copy the null terminator for a shorter buffer. //4.0.23.270 111746 //4.0.24.60
				iLen -= 1;
			
			memcpy(pRec, szFieldVal, iLen); //4.0.23.190 105087 sizeof(TAG_DISCOUNT_LOYALTY_INFO3)); //4.0.24.60
			long lValue = 0; //4.0.23.260 111407  
			long lLoyaltyVolumeLimit = a2l(pRec->cDiscountLoyaltyInfo3.sLoyaltyVolumeLimit, sizeof(pRec->cDiscountLoyaltyInfo3.sLoyaltyVolumeLimit)); //4.0.23.270 111746 //4.0.24.60

			if (!lLoyaltyVolumeLimit)  //4.0.23.240
			{
			 	lLoyaltyVolumeLimit = a2l(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sLoyaltyVolumeLimit, sizeof(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sLoyaltyVolumeLimit)); //4.0.23.270 111746 //4.0.24.60
				lValue = lLoyaltyVolumeLimit;	//4.0.23.260 111407
			}
			else
			{
				lValue =  RoundDouble(lLoyaltyVolumeLimit , 1000);
			}

			l2a(lValue, pRec->cDiscountLoyaltyInfo3.sLoyaltyVolumeLimit, sizeof(pRec->cDiscountLoyaltyInfo3.sLoyaltyVolumeLimit)); //4.0.23.270 111746 //4.0.24.60
			//4.0.20.450 66977 end //4.0.21.501

			//4.0.23.680 140984 start 136174
			FillInPromotionsArrayByPumpNum(lPumpNumber);    // 4.0.23.???? TD 378454

			// in case we support nozzle restriction convert Grade discount to nozzle discount
			if(m_bControllerSupportNozzleRestrction)
			{
				str.Format("CServerMain::ConvertWideCharLoyaltyInfo2RegularInfo Work with position"); 
				sTmpDiscountArray = pRec->cDiscountLoyaltyInfo3.sDiscountArray; //4.0.23.270 111746 //4.0.24.60

				memset(&sTmpDiscountArray.sDiscount , ' ', sizeof(sTmpDiscountArray.sDiscount)); 
				
				for (int i =1 ; i<= MAX_GRADES; i++)
				{
					lDiscount = a2l(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount[i - 1],sizeof(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount[i - 1])); //4.0.23.270 111746 //4.0.24.60
					lNumOfPosition = m_cPumpArray[lPumpNumber -1].GetNumOfPositionForGrade((short)i);	//The number of positions holding the same grade.

					if(LOG_BASIC_FLOW_CONTROL)
					{
						str.Format("Prepay discount is for grade number %ld discount = %ld",i,lDiscount);
						m_cLogger.LogMsg(str);

					}

					long lLastIndex = 0;
					if((lNumOfPosition>0)&&(lDiscount!=0))
					{
						//str.Format("CServerMain::ConvertWideCharLoyaltyInfo2RegularInfo num of position = %ld  for grade number %ld discount = %ld",lNumOfPosition,i,lDiscount);
					//	m_cLogger.LogMsg(str);
						for(int count=0;count<lNumOfPosition;count++)
						{
							byNozzle = m_cPumpArray[lPumpNumber-1].GetGradePosition(i, &lLastIndex);
							if (byNozzle)
							{	
								if(LOG_BASIC_FLOW_CONTROL)
								{
									str.Format("Set nozzle %ld discount=%ld " ,byNozzle, lDiscount);
									m_cLogger.LogMsg(str);
								}

								memcpy(sTmpDiscountArray.sDiscount[byNozzle -1] ,pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount[i - 1] ,sizeof(sTmpDiscountArray.sDiscount[byNozzle -1]));//4.0.23.270 111746 //4.0.24.60
							}

						}
						lDiscount=0;	//4.0.19.506 55286

					}
					
				}

				memcpy(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount , sTmpDiscountArray.sDiscount , sizeof(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount)); //4.0.23.270 111746 //4.0.24.60

				memcpy(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscountType , sTmpDiscountArray.sDiscountType , sizeof(pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscountType)); //merge from 4.0.16.310 //4.0.23.270 111746 //4.0.24.60
				str.Format("Saved discounts Array 16X6 = %.96s" ,pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscount); //4.0.23.270 111746 //4.0.24.60
				m_cLogger.LogMsg(str);
				str.Format("Saved discounts type = %.10s , Gallon limit=%ld" ,pRec->cDiscountLoyaltyInfo3.sDiscountArray.sDiscountType  ,lLoyaltyVolumeLimit ); //4.0.23.270 111746 //4.0.24.60
				m_cLogger.LogMsg(str);
			}

			SortGradeLimitArrayByPosition(lPumpNumber,pRec); // TD 378403		

			
			//4.0.22.504 72936 initialize pump info for a later use
			PAY_AT_PUMP_INFO cInfo;
			m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cInfo);
			for(int j=0 ; j< MAX_GRADES; j++)
			{
				l2a(0,cInfo.CardSaleExtraData2.sDiscountPerGrade[j].sDiscount, sizeof(cInfo.CardSaleExtraData2.sDiscountPerGrade[j].sDiscount));
			}
			memset(cInfo.CardSaleInfo.extraData.sLoyalId,' ',sizeof(cInfo.CardSaleInfo.extraData.sLoyalId));
			memset(cInfo.CardSaleExtraData2.sPromotionNumber,' ',sizeof(cInfo.CardSaleExtraData2.sPromotionNumber));
			m_cPumpArray[lPumpNumber -1].SetPAPInfo(&cInfo);

			
		}

		
		bRetCode = TRUE;
	}

	return bRetCode;
}

BOOL CServerMain::IsActiveLoyaltyDiscount()
{
	return (m_bActiveLoyaltyDiscount);
}

long CServerMain::CheckForLoyaltyDiscount(long lPumpNumber, CMD_STRUCT_AUTHORIZE_LIMIT & cmdAuthorize)
{
	long lRtc = 0;
	PAY_AT_PUMP_INFO info;	
	CString str;

	m_cPumpArray[lPumpNumber - 1].GetPAPInfo(&info);
	memset(cmdAuthorize.lDiscountArray , 0,sizeof(cmdAuthorize.lDiscountArray));						
	//4.0.19.508
	if (((IsActiveLoyaltyDiscount() || (m_cFuelLoayaltyPS.GetLoyaltySrvInUse() == COPIENT)) &&	//4.0.22.504 69344
		(m_cPumpArray[lPumpNumber -1].IsLoyaltyClub())) || (m_cPumpArray[lPumpNumber -1].IsPapToPakTrs())	//4.0.22.506 67786
		|| a2l(info.CardSaleExtraData4.sLoyaltyVolumeLimit, sizeof(info.CardSaleExtraData4.sLoyaltyVolumeLimit)) > 0 )
	{
		//m_cPumpArray[lPumpNumber -1].GetPAPInfo(&info);

		cmdAuthorize.lFlags |= LOYALTY_DISCOUNT_DATA; //4.0.9.507

		for(int i = 0; i < MAX_GRADES ; i++)
		{
			cmdAuthorize.lDiscountArray[i] = a2l(info.CardSaleExtraData2.sDiscountPerGrade[i].sDiscount , sizeof(info.CardSaleExtraData2.sDiscountPerGrade[i].sDiscount));
		}
		memset(cmdAuthorize.sDiscountType, ' ', sizeof(cmdAuthorize.sDiscountType)); //4.0.20.380 //4.0.21.12 68431
		cmdAuthorize.sDiscountType[1] = info.CardSaleExtraData2.sGRDiscountType;	//4.0.20.10	62944 RFS takes the discount always from index 1
		//4.0.20.450 66977 //4.0.21.501
		long lExistLoyaltyLimit = a2l(&info.CardSaleExtraData4.sExistLoyaltyLimit, sizeof(info.CardSaleExtraData4.sExistLoyaltyLimit));
		long lLoyaltyLimit = a2l(info.CardSaleExtraData4.sLoyaltyVolumeLimit, sizeof(info.CardSaleExtraData4.sLoyaltyVolumeLimit));

		if (m_cPumpArray[lPumpNumber -1].IsLoyaltyClub() && (!lExistLoyaltyLimit) && (!lLoyaltyLimit)) //4.0.23.1430 TD 321469
		{
			long lCheckGallon =  a2l(info.CardSaleExtraData2.sVolumeLimit , sizeof(info.CardSaleExtraData2.sVolumeLimit));

			if (lCheckGallon)
			{
				for (long lPostion = 0 ; lPostion < MAX_POSITIONS_PER_PUMP ; lPostion++ )
				{					
					l2a(lCheckGallon,info.CardSaleExtraData3.GradeLimitsArray[lPostion].sGradeAmountLimit, sizeof(info.CardSaleExtraData3.GradeLimitsArray[lPostion].sGradeAmountLimit));
					info.CardSaleExtraData3.GradeLimitsArray[lPostion].sLimitType = '1'; // For RFS-Allied systems (Optic)
				}
			}
		}
		if (lExistLoyaltyLimit)
		{
			if (cmdAuthorize.lFlags & LIMIT_BY_VOLUME)
			{
				if (lLoyaltyLimit < cmdAuthorize.lMaxVolume)
					cmdAuthorize.lMaxVolume = lLoyaltyLimit;
			}
			else
			{
				cmdAuthorize.lMaxVolume = lLoyaltyLimit;
			}
			cmdAuthorize.lLoyaltyVolumeLimit = lLoyaltyLimit; 
		}
		else
		{
			cmdAuthorize.lLoyaltyVolumeLimit = 0;
		}
		str.Format("CheckForLoyaltyDiscount found=%d, cmdAuthorize.sDiscountType=%.2s", (lRtc)?0:1, cmdAuthorize.sDiscountType); //4.0.20.380 //4.0.21.12 68431
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);	

		if (m_cPumpArray[lPumpNumber -1].IsPapToPakTrs() || m_cPumpArray[lPumpNumber -1].IsLoyaltyClub()) // TD 320504
		{
			if (!ChrAll((char *)info.CardSaleExtraData3.GradeLimitsArray ,sizeof(info.CardSaleExtraData3.GradeLimitsArray)))			
			{
						
				if (!(cmdAuthorize.lFlags & PREPAY_INCLUDES_GRADES_RESTRICTIONS))
					cmdAuthorize.lFlags +=PREPAY_INCLUDES_GRADES_RESTRICTIONS;

					m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,"Add Gallon limit matrix to buffer");	

				
			}			
		} // 4.0.23.1230  TD 305131

		//4.0.22.506 67786
		memcpy(cmdAuthorize.GradeAmountLimit, info.CardSaleExtraData3.GradeLimitsArray, sizeof(info.CardSaleExtraData3.GradeLimitsArray));

	}	
	else
		lRtc = 1;


	return 0;
}

void CServerMain::SetApplicationToHighPriority()
{
	HANDLE hProcess = GetCurrentProcess();
	if (!SetPriorityClass(hProcess, HIGH_PRIORITY_CLASS))
	{
			DWORD dwErr = GetLastError();
			char szMsg[80];
			sprintf_s(szMsg, _countof(szMsg), "Failed to set process priority. Windows error = %ld", dwErr);
			m_cLogger.LogMsg(szMsg);
			
	}
}
//4.0.27.46 - returm In/Out TAG_OLA_REC12
long CServerMain::BuildRequestReceiptInfo(CMD_STRUCT_FORMAT_RECEIPT &pcmdInfo, CStringA cTrack2, long lIndex, long lFlags, long lPosNumber, TAG_OLA_REC13 *tagOlaRec)
{
	CReceiptInfo	    Info; 
	CPumpTransact		trs;
	PAY_AT_PUMP_INFO	PayAtPumpInfo;
	char				sBuff[MAX_XML_BUF_LEN];
	CXMLPointers		cTmpPtr;
	CPumpSrvDatabase & PumpSrvDatabase = CPumpSrvDatabase::GetInstance();
	memset(sBuff, 0x00, sizeof(sBuff));
	DWORD  dwMaxReceiptCopies;
	long lRtc;
	long lFound  = RECEIPT_NOT_FOUND;	
	pcmdInfo.lFlags = lFlags;
	pcmdInfo.lPosNumber = lPosNumber;

	cTrack2.Trim();

	//long lTrack2Length = min(strlen(sTrack2), sizeof(pcmdInfo.sTrack2));
	
	if (lPosNumber == MOBILE_SRV_POS_NUMBER)
		memset(pcmdInfo.sTrack2, 0, sizeof(pcmdInfo.sTrack2));

	memcpy(pcmdInfo.sTrack2, cTrack2.GetBuffer(), cTrack2.GetLength());
	
	m_cParam.LoadParam("Receipt", "MaxReceiptCopies",&dwMaxReceiptCopies,0,TRUE);

	if(LOG_DETAIL_FLOW_CONTROL)
	{//4.0.20.501 TD 60236		
		char szResult[MAX_FIELD_VAL] = {0};		
		m_cProtectedDataHandler.LogReplaceBufferUseSize(szResult, (char *)pcmdInfo.sTrack2, sizeof(pcmdInfo.sTrack2));
		
		CString	str;  
		str.Format("CServerMain::BuildRequestReceiptInfo Search receipt for Pos=%ld, Data=[%s], lIndex=%ld, lFlags=0x%x", lPosNumber, szResult, lIndex, lFlags);
		
		_LOGMSG.LogMsg(str);
	}			
	
	if (lFlags & RECEIPT_INDEX_IS_TRS || lFlags & RECEIPT_INDEX_IS_RECEPT_KEY)  //4.0.22.20
	{
		long lTrsNumber = 0;
		lRtc = CSQLReceiptDB::GetInstance().GetFirstReceiptRecord(Info);
		Info.m_HashedKey.Trim();

		if(lRtc == OK)
		{
			memset(&PayAtPumpInfo, ' ', sizeof(PAY_AT_PUMP_INFO));
			_Module.m_server.ConvertReceiptToOla(Info, &trs, &PayAtPumpInfo);
			lTrsNumber = a2l(PayAtPumpInfo.CardSaleInfo.cardData.sTranNbr, sizeof(PayAtPumpInfo.CardSaleInfo.cardData.sTranNbr));

			while(lRtc == OK) // RFUEL-1474
			{
				if ((lTrsNumber == lIndex) && (Info.m_HashedKey == cTrack2))
					break;

				lRtc = CSQLReceiptDB::GetInstance().GetNextReceiptRecord(Info.m_TrsIndex, Info);
				Info.m_HashedKey.Trim();
				memset(&PayAtPumpInfo, ' ', sizeof(PAY_AT_PUMP_INFO));
				_Module.m_server.ConvertReceiptToOla(Info, &trs, &PayAtPumpInfo);
				lTrsNumber = a2l(PayAtPumpInfo.CardSaleInfo.cardData.sTranNbr, sizeof(PayAtPumpInfo.CardSaleInfo.cardData.sTranNbr));
			}
		}

		if ((lRtc == OK) && (Info.m_HashedKey == cTrack2) &&((long)dwMaxReceiptCopies > Info.m_NumberOfCopies) && (lTrsNumber == lIndex))
		{
			pcmdInfo.lIndex = lIndex;

			lFound = RECEIPT_FOUND;
		}
		else
		{
			if (Info.m_NumberOfCopies >= (long)dwMaxReceiptCopies)
				lFound = TOO_MANY_RECEIPTS;
		}

	}
	else
	{
		Info.m_HashedKey = cTrack2;
		Info.m_TrsIndex = lIndex;

		//Eyal 4.0.0.37
		Info.m_NumberOfCopies = 0;

		lRtc = PumpSrvDatabase.LoadReceipt(Info.m_TrsIndex, Info) ? OK : 1;

		if (!lRtc)
		{
			if (Info.m_NumberOfCopies >= (long)dwMaxReceiptCopies)
				lFound = TOO_MANY_RECEIPTS;

			else
			{
				pcmdInfo.lIndex = lIndex;
				lFound = RECEIPT_FOUND;
			}
		}
	}

	if (lFound == RECEIPT_FOUND)
	{
		memset(tagOlaRec,' ', sizeof(TAG_OLA_REC13));								//4.0.22.61	TD 75605 //4.0.27.46
		memset(&PayAtPumpInfo,' ', sizeof(PAY_AT_PUMP_INFO));

		ConvertReceiptToOla(Info, &trs, &PayAtPumpInfo);
		
		memset(tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.lIndexNumber ,' ' , sizeof(tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.lIndexNumber));
		tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.cardData	 =  PayAtPumpInfo.CardSaleInfo.cardData;
		tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData =  PayAtPumpInfo.CardSaleInfo.extraData;
		tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData2 = PayAtPumpInfo.CardSaleExtraData2;
		trs.GetTag(&tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.tagTrs,2);
		tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData3 = PayAtPumpInfo.CardSaleExtraData3;
		tagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData4 = PayAtPumpInfo.CardSaleExtraData4;					//4.0.22.61	TD 75605
		tagOlaRec->tagOlaRec12.extraData5                         = PayAtPumpInfo.CardSaleExtraData5;                   //4.0.27.46
		tagOlaRec->extraData6 = PayAtPumpInfo.CardSaleExtraData6;
	}

	return lFound;
}

long CServerMain::InitTerminalsInfo()
{
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL];
	int i;

	BYTE byCardReaders = 0 , byCashAcceptors = 0;

	//Start Eyal 3.1.1.62
	for(i = 0; i < MAX_TERMINALS; i++)  //changed i to 0, and all subsequent calls to i to i + 1
	{
		CString str("Terminals\\Terminal");  //changed to Terminals
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",(i + 1));
		str += sNumber;		

		m_cParam.LoadParam((char *)((LPCTSTR)str), "DeviceAddress",			&dwTmp, (DWORD)(i + 1),	TRUE);

		//changed value to set to i / 4 + 2
		//so that terminals 1 - 4 will be at port number 2
		//terminals 5 - 8 will be at 3, etc.
		m_cParam.LoadParam((char *)((LPCTSTR)str), "CommPort",				&dwTmp, (DWORD)((i / 4) + 2),	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Simulator",				&dwTmp, (DWORD)0,	TRUE);


		m_cParam.LoadParam((char *)((LPCTSTR)str), "CardReader",			&dwTmp, (DWORD)1,	TRUE);

		//4.0.1.32
		if(dwTmp)
			byCardReaders = (BYTE)1;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptor",			&dwTmp, (DWORD)0,	TRUE);

		//4.0.1.32
		if(dwTmp)
			byCashAcceptors = (BYTE)1;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "KeyboardType",			sTmpStr, sizeof(sTmpStr) ,"1", TRUE);

		m_cParam.LoadParam((char *)((LPCTSTR)str), "EncryptionKey",			sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "KMEEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "MACEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PINEncryption",			&dwTmp, (DWORD)1,	TRUE);
		//4.0.0.47 moved to Messages Table
		//m_cParam.LoadParam((char *)((LPCTSTR)str), "TerminalMessageLength",	&dwTmp, (DWORD)20,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",				&dwTmp, (DWORD)0,	TRUE);

		//4.0.1.32
		if(dwTmp)
		{
			m_cTerminalDevices[i].SetNumberOfCardReaders(byCardReaders);
			m_cTerminalDevices[i].SetNumberOfCashAcceptors(byCashAcceptors);
		}

		m_cParam.LoadParam((char *)((LPCTSTR)str), "Type" , sTmpStr , sizeof(sTmpStr) , "PT3000" , TRUE);
		//m_cParam.LoadParam((char *)((LPCTSTR)str), "TerminalNumber",		&dwTmp, (DWORD)i,	TRUE);

		//The CRC field 
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ParamCRC",&dwTmp,(DWORD)0,TRUE);
	
		//4.0.2.24
		///m_cParam.LoadParam((char *)((LPCTSTR)str), "OfflineTimeOut(mSec)" , &dwTmp , (DWORD)100 , TRUE);

		//GraphicDevice
		m_cParam.LoadParam((char *)((LPCTSTR)str), "GraphicDevice",	&dwTmp, (DWORD)1 , TRUE);

		//End Eyal 3.1.1.62
		
		//3.2.0.69
		m_cParam.LoadParam((char *)((LPCTSTR)str), "OriginTrans",	sTmpStr, sizeof(sTmpStr), "P", TRUE);
		//3.2.0.69

		//4.0.1.35
		m_cParam.LoadParam((char *)((LPCTSTR)str), "BarcodeScanner",	&dwTmp, (DWORD)0 , TRUE);
		//4.0.1.35


		//4.0.2.15
		m_cParam.LoadParam((char *)((LPCTSTR)str), "IPAddress" , sTmpStr , sizeof(sTmpStr) , "" , TRUE);
				
		//4.0.1.32 - prepare variables for next iteration of loop.
		byCashAcceptors = byCardReaders = 0;
		m_cParam.LoadParam((char *)((LPCTSTR)str), "BaudRate" , &dwTmp , (DWORD)9600 , TRUE);
	}

	return (1);
}

long CServerMain::ConvertPumpInfo2TerminalInfo()
{
	long lRtc = 0;
	long lRtcLoadParam = 0;
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL];

	BYTE byCashAcceptors = 0 , byCardReaders = 0;

	int i;

	// exist in old struct 
	//if (!m_cParam.LoadParam((char *)((LPCTSTR)"Pumps\\Pump01"), "CardReader",			&dwTmp, (DWORD)1,	FALSE))

	if (m_cParam.LoadParam((char *)((LPCTSTR)"Terminals\\Terminal01"), "CardReader",			&dwTmp, (DWORD)1,	FALSE))
	{		 
		for(i = 0; i < MAX_TERMINALS; i++)
		{

			CString str("Pumps\\Pump");
			CString strTerminals("Terminals\\Terminal");
			
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));

			sprintf_s(sNumber, _countof(sNumber),"%02d",i + 1);
			str += sNumber;

			strTerminals +=sNumber;

			//Eyal 3.1.1.62 start always create new DeviceAddress
			//lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "DeviceAddress",			&dwTmp, (DWORD)i,	FALSE);
			m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "DeviceAddress",			&dwTmp, (DWORD)(i + 1),	TRUE);
			//Eyal 3.1.1.62 end
			
			//Eyal 3.1.1.62 start always create new CommPort
			m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "CommPort",				&dwTmp, (DWORD)(i / 4 + 2),	TRUE);
			//Eyal 3.1.1.62 end

			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "Simulator",				&dwTmp, (DWORD)0,	FALSE);

			if (!lRtcLoadParam)			
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "Simulator",				&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "Simulator",				&dwTmp, (DWORD)0,	TRUE);

			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "CardReader",			&dwTmp, (DWORD)1,	FALSE);
			
			if (!lRtcLoadParam)	
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "CardReader",			&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "CardReader",			&dwTmp, (DWORD)1,	TRUE);

			if(dwTmp)
				byCardReaders = (BYTE)1;
			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptor",			&dwTmp, (DWORD)0,	FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptor",			&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptor",			&dwTmp, (DWORD)0,	TRUE);

			if(dwTmp)
				byCashAcceptors = (BYTE)1;
			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "KeyboardType",			sTmpStr, sizeof(sTmpStr) ,"1", FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "KeyboardType",			sTmpStr, sizeof(sTmpStr) ,sTmpStr, TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "KeyboardType",			sTmpStr, sizeof(sTmpStr) ,"1", TRUE);
			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "EncryptionKey",			sTmpStr, sizeof(sTmpStr), "Non Valid Key", FALSE);
			
			if (!lRtcLoadParam)			
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "EncryptionKey",			sTmpStr, sizeof(sTmpStr), sTmpStr, TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "EncryptionKey",			sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);

			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "KMEEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "KMEEncryptionKey",		sTmpStr, sizeof(sTmpStr), sTmpStr, TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "KMEEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);

			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "MACEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", FALSE);
			
			if(!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "MACEncryptionKey",		sTmpStr, sizeof(sTmpStr), sTmpStr, TRUE);
			else					
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "MACEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);

			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "PINEncryption",			&dwTmp, (DWORD)1,	FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "PINEncryption",			&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "PINEncryption",			&dwTmp, (DWORD)1,	TRUE);

			
			lRtcLoadParam = m_cParam.LoadParam((char *)((LPCTSTR)str), "TerminalMessageLength",	&dwTmp, (DWORD)20,	FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "TerminalMessageLength",	&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "TerminalMessageLength",	&dwTmp, (DWORD)20,	TRUE);
			

			lRtcLoadParam =  m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",				&dwTmp, (DWORD)0,	FALSE);
			
			if (!lRtcLoadParam)
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "ValidEntry",				&dwTmp, dwTmp,	TRUE);
			else
				m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "ValidEntry",				&dwTmp, (DWORD)0,	TRUE);
			
			//4.0.1.32
			if(dwTmp)
			{
				m_cTerminalDevices[i].SetNumberOfCardReaders(byCardReaders);
				m_cTerminalDevices[i].SetNumberOfCashAcceptors(byCashAcceptors);
			}

			// new fields Eyal 3.1.1.62
			m_cParam.LoadParam((char *)((LPCTSTR)str), "GraphicDevice",	&dwTmp, (DWORD)1 , TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "DefaultLanguage",		&dwTmp, (DWORD)1,	TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "Type",			sTmpStr, sizeof(sTmpStr), "PT3000", TRUE);
			//4.0.2.24
			//m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "OfflineTimeOut(mSec)" , &dwTmp , (DWORD)40 , TRUE);
			//end 3.1.1.62

			// start 3.1.1.61
			//m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "TerminalNumber",		&dwTmp, (DWORD)i,	TRUE);		
			// end 3.1.1.61
			
			m_cParam.LoadParam((char *)((LPCTSTR)strTerminals), "ParamCRC",&dwTmp,(DWORD)0,TRUE);

			//4.0.1.32 - prepare variables for next iteration of loop.
			byCashAcceptors = byCardReaders = 0;
		}
	

		//DeleteOldPumpInfo();

		m_cLogger.LogMsg("PumpSrv convert Pump Info 2  Terminal Info  !!!!!!!!!!");
	}	

	return lRtc;
}

void CServerMain::DeleteOldPumpInfo()
{
	int i;
	long lTmp;
	for(i = 1; i <= MAX_TERMINALS; i++)
	{
		CString str("Pumps\\Pump");
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		m_cParam.DeleteParam((char *)((LPCTSTR)str), "DeviceAddress",			&lTmp);

		m_cParam.DeleteParam((char *)((LPCTSTR)str), "CommPort",				&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "Simulator",				&lTmp);

		m_cParam.DeleteParam((char *)((LPCTSTR)str), "CardReader",			    &lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "CashAcceptor",			&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "KeyboardType",			&lTmp);


		m_cParam.DeleteParam((char *)((LPCTSTR)str), "EncryptionKey",			&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "KMEEncryptionKey",		&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "MACEncryptionKey",		&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "PINEncryption",			&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "TerminalMessageLength",	&lTmp);
		m_cParam.DeleteParam((char *)((LPCTSTR)str), "ValidEntry",				&lTmp);
		
	}
}

void CServerMain::DoAutomaticRealTime()
{
	SYSTEMTIME cCurrentTime;
	long lTimeInterval = 0;
	long lRetVal = 0;

	GetLocalTime(&cCurrentTime);

	lRetVal = CompareSystemTime(&cCurrentTime,&m_cPrevSysTime,&lTimeInterval,INTERVAL_IN_MINUTES);

	//checking if interval time is bigger then 15 minutes
	if(lTimeInterval > 15)
	{
		SetRealTimeClock();	
	}
	m_cPrevSysTime = cCurrentTime;
}

long CServerMain::SetRealTimeClock()
{
	long lRetCode = 0;

	if (SERVER_STATE_STARTUP)
		lRetCode = CTRL_CONTROLLER_NOT_AVAILABLE;

	else if (SERVER_NOT_IDLE)
		lRetCode = CTRL_SERVER_NOT_READY;
	
	if(lRetCode == CTRL_OK)
	{
		SetCommand(CMD_SET_REALTIME_CLOCK,0,0);

		if(LOG_BASIC_FLOW_CONTROL)
		{
			m_cLogger.LogMsg("SetRealTimeClock");
		}
	}

	return lRetCode;
}

void CServerMain::SetPrevSysTime(SYSTEMTIME cCurrentTime)
{
	m_cPrevSysTime = cCurrentTime;	
}

BOOL CServerMain::IsAutoTimeChecker()
{
	return m_bAutoTimeCheck;
}

// Resert index counter....
void CServerMain::SetPumpTotalIndex(long lIndex)
{
	m_dwTotalIndex = 1;
	m_cParam.SaveParam("GeneralParam","PumpTotalIndex",m_dwTotalIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 //4.0.8.503
}

BOOL CServerMain::IsMeggitSite()
{
	BOOL bRtc = FALSE;

	if (!memcmp(m_strControllerName ,"MEGGITT PETROLEUM SYSTEM" , sizeof("MEGGITT PETROLEUM SYSTEM")))
		bRtc = TRUE;

	if (bRtc)
		_LOGMSG.LogMsg("PumpSrv is Master on Meggit WetStock");

	return bRtc;
}

void CServerMain::SetDeliveryReporIndex(long Index)
{
	m_dwDeliveryIndex = 1;	
	//4.0.8.503m_cParam.SaveParam("GeneralParam","FuelDeliveryIndex",m_dwDeliveryIndex,TRUE,_HOST.m_lGroupNum);//4.0.0.66
	m_cParam.SaveParam("GeneralParam","FuelDeliveryIndex",m_dwDeliveryIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503
}

void CServerMain::SetTankReadingIndex(long lIndex)
{
	m_dwTankReadIndex = 1;	
	//m_cParam.SaveParam("GeneralParam","TankReadIndex",m_dwTankReadIndex,TRUE,_HOST.m_lGroupNum);//4.0.0.66
	m_cParam.SaveParam("GeneralParam","TankReadIndex",m_dwTankReadIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503
}

//4.0.13.505
void CServerMain::SetInvoiceRefNumber(long lInvoiceRefNumber)
{
	m_lInvoiceRefNumber = lInvoiceRefNumber;
	m_cParam.SaveParam("GeneralParam","InvoiceRefNumber",(DWORD)m_lInvoiceRefNumber,TRUE);
}


//3.2.0.5


// Function name	: CServerMain::CreatePathsTable
// Description	    : Creates the HKEY_LOCAL_MACHINE\SOFTWARE\Pointofsale\PumpSrv\Paths 
//					  entry by PS according to where it is running.
// Return type		: void 
void CServerMain::LoadPathsTable()
{
	char szPumpSrvPath[MAX_FIELD_NAME];
	char tmpStr[100];

	//4.0.0.83
	char sTmpDefault[100];

	DWORD dwRes = 0;
	int iRes = 0;

	memset(szPumpSrvPath,0,MAX_FIELD_NAME);
	memset(tmpStr,0,sizeof(tmpStr));
	memset(sTmpDefault,0,sizeof(sTmpDefault));

	dwRes = GetCurrentDirectory(MAX_FIELD_NAME,szPumpSrvPath);

	if(dwRes)
	{
		//Eyal 4.0.0.53
		//We only want the drive name, not the whole path.
		//4.0.2.23
		//memset((char*)szPumpSrvPath + 2 , 0 , MAX_FIELD_NAME - 3);

		iRes = m_cParam.LoadParam("Paths\\Long", "HomeDir",tmpStr,sizeof(tmpStr),szPumpSrvPath,TRUE);
		
		//4.0.0.83 - if the parameter was found, use the value read from 
		//the registry, otherwise create.
		if(!iRes)
		{
			memcpy(sTmpDefault , tmpStr , sizeof(sTmpDefault));
			strcat_s(sTmpDefault, _countof(sTmpDefault),"\\Data");  //4.0.0.85

			iRes = m_cParam.LoadParam("Paths\\Long", "DataDir",tmpStr,sizeof(tmpStr),sTmpDefault,TRUE);
		}

		else
		{
		//  in case no  HomeDir path not exist  create default path
			//4.0.2.23	
			memcpy(sTmpDefault, szPumpSrvPath , sizeof(sTmpDefault));
			strcat_s(sTmpDefault, _countof(sTmpDefault),"\\Data");  //4.0.0.85

			iRes = m_cParam.LoadParam("Paths\\Long", "DataDir",tmpStr,sizeof(tmpStr),sTmpDefault,TRUE);
		//4.0.2.23	
			//iRes = m_cParam.LoadParam("Paths\\Long", "DataDir",tmpStr,sizeof(tmpStr),szPumpSrvPath,TRUE);
		}


		//4.0.13.503 
		//Always should be after taking DataDir! the defauld is the value in DataDir.
		iRes = m_cParam.LoadParam("Paths\\Long", "FirmwareDir",tmpStr,sizeof(tmpStr), tmpStr,TRUE);
		
		iRes = m_cParam.LoadParam("Paths\\Long", "LogDir",tmpStr,sizeof(tmpStr), szPumpSrvPath,TRUE);
		

		iRes = m_cParam.LoadParam("Paths\\Short", "HomeDir",tmpStr,sizeof(tmpStr),szPumpSrvPath,TRUE);
		iRes = m_cParam.LoadParam("Paths\\Short", "LogDir",tmpStr,sizeof(tmpStr),szPumpSrvPath,TRUE);

	//4.0.0.86	
		m_cParam.LoadParam("Paths\\Long","XML_PriceChangeFile",tmpStr,sizeof(tmpStr),"C:\\office\\PumpSrv\\FuelPriceChange.xml",TRUE);
		//4.0.2.23
		m_cParam.LoadParam("Paths\\Long","TerminalImagesPath",tmpStr,sizeof(tmpStr),"C:\\office\\PumpSrv\\Data\\Images",TRUE);
		//4.0.2.23

		m_cParam.LoadParam("Paths\\Long","ConfigThreadDataFilePath",tmpStr,sizeof(tmpStr),"C:\\Office\\PumpSrv\\ConfigData",TRUE);
		m_cParam.LoadParam("Paths\\Long","ExportDataPath",tmpStr,sizeof(tmpStr),"C:\\office\\PumpSrv\\ExportData",TRUE);

		
	}
	else
	{
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			dwRes = GetLastError();
			str.Format("CreatePathsTable:Fail in GetCurrentDirectory(), Error: %d,",dwRes);
			_LOGMSG.LogMsg(str);
		}	
	}
}
//4.0.0.20
BYTE CServerMain::GetPumpFileIndexNum()
{
	return m_cPumpFile.q_param.indx_num;
}

void CServerMain::LoadPumpStat(long lPumpNum, BOOL bSaveInfo)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	BOOL bOneCycle = FALSE;
	int index = 0;

	if(lPumpNum)//4.0.0.78
	{
		index = lPumpNum - 1;
		bOneCycle = TRUE;
	}
		
	for(long p = index ; p< m_lMaxPumps; p++)  //4.0.0.79
	{
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		//4.0.3.50
		CPumpStatus Currentstat = m_cPumpArray[p].GetStat();	
		
		// load info from Qdex

		SQLPumpSrvFile.LoadInfo(p + 1, TRUE); //4.0.12.513 (add send TRUE in the param bForMultiSync)
		
		SQLPumpSrvFile.LoadPAPInfo(p + 1);	

 		m_lAutoState[p] = PUMP_NONE_FIRST;
			
		CPumpStatus stat = m_cPumpArray[p].GetStat();
		m_lPrePayReTryReservation[p] = TIME_BETWEEN_RETRYING_RESERVED_PRE_PAID_PUMP;  //4.0.24.351 //4.0.124.355 //4.0.27.60 231255

	
		long lMisc = stat.GetMisc();
		
		//checking if manual mode. If so setting the Misc
		long lMode = m_lPumpsManualModeArray[p];
		
		if (lMode)
			lMisc |= MISC_MANUAL_MODE;
		else
			lMisc &= MISC_NOT_MANUAL_MODE;

		stat.SetMisc(lMisc);

		//4.0.5.20
		m_cPumpArray[p].SetStat(stat);
		
		// load Registry information: 
		m_cPumpArray[p].LoadDefinition();

		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			short n1,n2,n3;
			m_cPumpArray[p].GetTrsListCount(&n1,&n2,&n3);
			str.Format("Status %d, Res %d, ResExt %d, LockState %d, Shift %d, Waiting %d, Free %d, Unpaid %d, ",
						m_cPumpArray[p].GetStat().GetStatus(),
						m_cPumpArray[p].GetStat().GetRes(),
						m_cPumpArray[p].GetStat().GetResExt(),
						m_cPumpArray[p].GetLockStatus(),
						m_cPumpArray[p].GetShiftNumber(),									
						n1,n2,n3);
			m_cLogger.LogMsg(p+1,LOG_PUMP,str);
		}

		if(m_cPumpArray[p].GetLockStatus() == WAIT_LOCK)
			m_cPumpArray[p].SetLockStatus(STARTED);

		if(m_cPumpArray[p].GetLockStatus() == WAIT_RESPONSE)
			m_cPumpArray[p].SetLockStatus(LOCKED);

		//4.0.7.502
		m_cSinglePumpLock.SetInitiallyLockedPumps(lPumpNum);

		if(bSaveInfo)
			SavePumpInfo(p+1);

		if(bOneCycle)//4.0.0.78
			break;
	}
}

void CServerMain::RefreshRegistryTable(char *szTableName, char *szFiledName, long lRefreshType,long lClientEventData)
{
	long lTableId = 0;
	long lSubTableId = 0;
	long lRetVal = 0;
	//4.0.5.11
	//The CRC keys are our trigger for the reconfigure process
	if ( !strcmp(szFiledName, "ParamCRC") )
	{
		CRegTable cTable;
		//here to add the reconfigure logic
		lTableId = cTable.ConvertTableNameToTableId(szTableName);
		lSubTableId = lClientEventData;
		m_cCommonFunction.Reconfigure2(lTableId,lSubTableId,0,0,&lRetVal,FALSE);
		
		return;
	}
	if ( !strcmp(szTableName, "GeneralParam") )
	{
		switch(lRefreshType)
		{
			case REFRESH_REGISTRY_KEY:
			{
				RefreshGeneralParamKey(szFiledName);
				break;
			}
			case REFRESH_REGISTRY_TABLE:
			{
				LoadGeneralParamTable(FALSE);
				break;
			}
		}
	}//4.0.1.38
	if ( strstr(szTableName, "Modes\\Mode") != NULL)
	{
		long lMode = lClientEventData;
		RefreshModeDefinitions(lMode);		
	}
	if ( strstr(szTableName, "ModeScheme") != NULL)
	{
		long lIndex = lClientEventData;
		RefreshModeSchemeDefinitions(lIndex);		
	}
	if ( strstr(szTableName, "Pumps\\Pump") != NULL)
	{
		long lPumpNum = lClientEventData;
		RefreshPumpsKeys(szTableName,szFiledName,lPumpNum);		
	}
	if ( strstr(szTableName, "Receipt\\Receipt00") != NULL) //4.0.19.502
	{
		m_lReceipt00Counter = lClientEventData;	
	}
	if ( strstr(szTableName, "Tanks\\Tank") != NULL)    // TD 264908
	{
        long lTankNum = lClientEventData;
		
		m_cTankArray[lTankNum - 1].LoadDeliveryEmulationInfo();	
        m_cTankArray[lTankNum - 1].UpdateCanIncDeliveryEmulationSales();	
	}
}
//4.0.1.38 start
void CServerMain::RefreshModeDefinitions(long lMode)
{
	//checking if valid
	if(!MODE_NOT_VALID(lMode))
		m_cModeArray[lMode-1].LoadDefinition();
}

void CServerMain::RefreshModeSchemeDefinitions(long lIndex)
{
	//checking if valid
	if(lIndex >= 0 && lIndex < m_lMaxPumps * MAX_MODE_SCHEME)
		m_cModeSchemeArray[lIndex].LoadDefinition(1);
}

void CServerMain::RefreshPumpsKeys(char *szTableName,char *szFiledName,long lPumpNum)
{
	DWORD dwTmp = 0;
	
	//checking that the pump number is valid
	if(!PUMP_NOT_VALID(lPumpNum))
	{	
		if ( !strcmp(szFiledName, "ManualMode") )
		{
			long lMode = 0;
			m_cParam.LoadParam(szTableName, "ManualMode",&dwTmp,(DWORD)0,TRUE);
			lMode = dwTmp;
			m_lPumpsManualModeArray[lPumpNum-1] = lMode;
			
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

			CPumpStatus pumpStat = m_cPumpArray[lPumpNum -1].GetStat();
			long lMisc = pumpStat.GetMisc();

			if (lMode)
				lMisc |= MISC_MANUAL_MODE;
			else
				lMisc &= MISC_NOT_MANUAL_MODE;
			
			pumpStat.SetMisc(lMisc);
			m_cPumpArray[lPumpNum -1].SetStat(pumpStat);	
			
			CString sMsg; //4.0.15.501
			sMsg.Format("CServerMain::RefreshPumpsKeys, lPumpNum: %ld , lMode = %ld , lMisc = %ld" , lPumpNum, lMode, lMisc);
			m_cLogger.LogMsg(sMsg);
		}

		if ( !strcmp(szFiledName, "UnbalancePrePayCounter[I]") )//4.0.3.27
		{	
			m_cParam.LoadParam(szTableName, "UnbalancePrePayCounter",&dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.505
			m_cPumpArray[lPumpNum -1].SetUnBalancePrepayCounter(dwTmp);
		}
	}
}


//4.0.1.38 end
void CServerMain::RefreshGeneralParamKey(char *szFiledName)
{
	if ( !strcmp(szFiledName, "TransactNumber[I]") ) //4.0.12.506 (add [I])
	{
		//4.0.8.503m_cParam.LoadParam("GeneralParam","TransactNumber",&m_dwTransactNumber,1,FALSE);
		DWORD dwInitTrsNumber = GetFuelTransactionNumberMinValue(); //4.0.23.260 111318
		m_cParam.LoadParam("GeneralParam","TransactNumber",&m_dwTransactNumber,dwInitTrsNumber,FALSE,TRUE,_HOST.m_lGroupNum,HOP_DIRECT_LOCAL,TRUE); //4.0.8.512
	}
	
	
	if ( !strcmp(szFiledName, "ActiveShiftNumber[I]") )
	{
		m_cParam.LoadParam("GeneralParam","ActiveShiftNumber",&m_cCurrentShift.dwActiveShiftNumber, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
		m_cCurrentShift.dwFormalShiftNumber = m_cCurrentShift.dwActiveShiftNumber;
	}
	//4.0.0.66 start
	if (!strcmp(szFiledName, "PumpTotalIndex[I]") )
		//m_cParam.LoadParam("GeneralParam","PumpTotalIndex",&m_dwTotalIndex,1,FALSE); //4.0.8.503
		m_cParam.LoadParam("GeneralParam","PumpTotalIndex",&m_dwTotalIndex,1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	
	if (!strcmp(szFiledName, "TankReadIndex[I]") )
		//4.0.8.503m_cParam.LoadParam("GeneralParam","TankReadIndex",&m_dwTankReadIndex, 1,FALSE);
		m_cParam.LoadParam("GeneralParam","TankReadIndex",&m_dwTankReadIndex, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	if (!strcmp(szFiledName, "AlarmIndex[I]") )
		//4.0.8.503m_cParam.LoadParam("GeneralParam","AlarmIndex",&m_dwAlarmIndex, 1,FALSE);
		m_cParam.LoadParam("GeneralParam","AlarmIndex",&m_dwAlarmIndex, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
	
	if (!strcmp(szFiledName, "CarWashIndex[I]") )
		//4.0.8.503m_cParam.LoadParam("GeneralParam","CarWashIndex",&m_dwCarWashIndex, 1,FALSE);
		m_cParam.LoadParam("GeneralParam","CarWashIndex",&m_dwCarWashIndex, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);//4.0.8.503
	
	if (!strcmp(szFiledName, "OLAIndex[I]") )	
	//m_cParam.LoadParam("GeneralParam","OLAIndex",&m_dwOLAIndex, 1,FALSE); //4.0.8.503
	m_cParam.LoadParam("GeneralParam","OLAIndex",&m_dwOLAIndex, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	
	if (!strcmp(szFiledName, "ItemsIndex[I]") )	
		//4.0.8.503m_cParam.LoadParam("GeneralParam","ItemsIndex",&m_dwItemsIndex, 1,FALSE);
		m_cParam.LoadParam("GeneralParam","ItemsIndex",&m_dwItemsIndex, 1,FALSE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	
	if (!strcmp(szFiledName, "FuelDeliveryIndex[I]") )
		//m_cParam.LoadParam("GeneralParam","FuelDeliveryIndex",&m_dwDeliveryIndex, 1,FALSE);
		m_cParam.LoadParam("GeneralParam","FuelDeliveryIndex",&m_dwDeliveryIndex, 1,FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	//4.0.0.66 end

	if ( !strcmp(szFiledName, "PriceChangeBatchNumber[I]") ) //4.0.27.43 TD 226166 
	{
		m_cParam.LoadParam("GeneralParam","PriceChangeBatchNumber", &m_lPriceChangeBatchNumber,0,FALSE,TRUE,_HOST.m_lGroupNum,HOP_DIRECT_LOCAL,TRUE); //4.0.8.512
	}
	
	if (!strcmp(szFiledName, "SignInCashiersCounter[I]") ) //TD 233125 - merge from 4.0.25.121 4.0.27.60
	{
		m_cFuelingRestriction.Init(FALSE);
	}	
}

void CServerMain::LoadGeneralParamTable(BOOL bCreate)
{
	DWORD dwTmp;
	DWORD dwVal = 0;
	char sTmpStr[MAX_FIELD_VAL];
	char tmpStr[100];
	DWORD dwDefaultOlaSrv;
	//SZ_TAG_SYSTEMTIME szTagTime;
	//4.0.8.5001SYSTEMTIME curSysTime;

	CString sVersion = PUMPSRV_VERSION;
	if(m_cParam.SaveParam("GeneralParam", "Version", sVersion.GetBuffer(0)))
	{
		char tmpStr[100];
		m_cParam.LoadParam("GeneralParam","Version", tmpStr, sizeof(tmpStr) , sVersion.GetBuffer(0),TRUE,TRUE);
	}

	// Transaction Number generator:
	//4.0.8.503m_cParam.LoadParam("GeneralParam","TransactNumber",&m_dwTransactNumber,1,TRUE);
	DWORD dwInitTrsNumber = GetFuelTransactionNumberMinValue(); //4.0.23.260 111318
	m_cParam.LoadParam("GeneralParam","TransactNumber",&m_dwTransactNumber,dwInitTrsNumber,TRUE,TRUE,_HOST.m_lGroupNum,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	// Active Read Number generator: 
	m_cParam.LoadParam("GeneralParam","ActiveReadNumber",&m_dwActiveReadNumber, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	//m_cIniFile.ReadParam("GeneralParam","ActiveReadNumber",(long*)&m_dwActiveReadNumber , 1, TRUE);

	// Active Shift Number generator: 
 	m_cParam.LoadParam("GeneralParam","ActiveShiftNumber",&m_cCurrentShift.dwActiveShiftNumber, 1,TRUE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	// PumpTotalIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","PumpTotalIndex",&m_dwTotalIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","PumpTotalIndex",&m_dwTotalIndex, 1,TRUE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	
	// TankReadIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","TankReadIndex",&m_dwTankReadIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","TankReadIndex",&m_dwTankReadIndex, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);

	// FuelDeliveryIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","FuelDeliveryIndex",&m_dwDeliveryIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","FuelDeliveryIndex",&m_dwDeliveryIndex, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	// AlarmIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","AlarmIndex",&m_dwAlarmIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","AlarmIndex",&m_dwAlarmIndex, 1,TRUE , TRUE,0,HOP_DIRECT_LOCAL,TRUE);

	// CarWashIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","CarWashIndex",&m_dwCarWashIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","CarWashIndex",&m_dwCarWashIndex, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	// OLA Operating Mode (hot pumping ...) 
	m_cParam.LoadParam("GeneralParam","OLAMode",&m_dwOLAMode, OLA_MODE_WAIT,TRUE);

	// Automatic or single (pos control) shift mode
 	m_cParam.LoadParam("GeneralParam","ShiftMode",&m_dwShiftMode, SHIFT_MODE_SINGLE,TRUE);

	// Wet Stock mode - Get wet stock data: (0) not at all. (1) every X minute (2) at time hh:mm.
	m_cParam.LoadParam("GeneralParam","WetStockMode",&m_dwWetStockMode, 0,TRUE);

	m_cParam.LoadParam("GeneralParam","WetstockMemoCounter",&dwTmp, 0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.17.501

	// Wet Stock interval (in second), in case m_dwWetStockMode == 1.
	m_cParam.LoadParam("GeneralParam","WetStockInterval",&m_dwWetStockInterval, 60,TRUE);

	//Wet Stock flags, to use with the automatic process
	m_cParam.LoadParam("GeneralParam", "WetStockTime", (char *)sTmpStr, sizeof(sTmpStr), "0000",TRUE ,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
	
	//DWORD dwTmp;
	//Wet Stock flags, to use with the automatic process
	m_cParam.LoadParam("GeneralParam", "WetStockFlags",&dwTmp,(DWORD)0, TRUE);

	// Wet Stock interval (in second), in case m_dwWetStockMode == 1.
	m_cParam.LoadParam("GeneralParam","WetStockDone",&dwTmp, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503

	// Wet Stock clear time interval (in milliseconds) default = 10000(10 seconds)
	m_cParam.LoadParam("GeneralParam","WetStockClearTime",&m_dwWetStockClearTime,60000 ,TRUE);

	// Wet Stock timeout (maximum time for state) (in milliseconds) default = 900000(900 seconds = 15 minutes)    // TD 351225
	m_cParam.LoadParam("GeneralParam","WetStockStateTimeout",&m_dwWetStockStateTimeout,900000 ,TRUE); //TD 351225 - Wetstock report does not print after wetstock process had arrived into a bad state
	
	//Use OLA Decline Message
	m_cParam.LoadParam("GeneralParam","OLADeclineMessage",&dwTmp,0,TRUE);

	// Shift lock
 	m_cParam.LoadParam("GeneralParam","ShiftLock",&dwTmp,1,TRUE);
	// Shift EOD
 	m_cParam.LoadParam("GeneralParam","ShiftEOD",&dwTmp,1,TRUE); //CR_475695_Start_End

	// OLAIndex
	//4.0.8.503m_cParam.LoadParam("GeneralParam","OLAIndex",&m_dwOLAIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","OLAIndex",&m_dwOLAIndex, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);

	// Hot Pumping
	m_cParam.LoadParam("GeneralParam","HotPumping",&m_dwHotPumping, 0, TRUE);

	m_cParam.LoadParam("GeneralParam","PrePayAuthorizedTimeOut",&m_dwPrePayAuthorizedTimeOut, 300 ,TRUE);

	// 3.0.0.8
	//m_cParam.LoadParam("GeneralParam","CheckVITConflict",&m_dwCheckVITConflict, 0, TRUE); //4.0.0.52
	//m_cParam.LoadParam("GeneralParam","CheckAVIConflict",&m_dwCheckVITConflict, 0, TRUE); //4.0.0.52
	
	//4.0.0.55 (3.2.1.35) Eyal start
	//If the field CheckVITConflict exists and is set to 1, copy this value
	//into the new field, CheckAVIConflict.  Otherwise (the value is zero or
	//the entry does not exist), mimic old behaviour by creating CheckAVIConflict
	//and setting to zero.
	if(!m_cParam.LoadParam("GeneralParam","CheckVITConflict",&dwTmp, 0, FALSE)  && dwTmp)
	{
		m_cParam.LoadParam("GeneralParam","CheckAVIConflict",&m_dwCheckVITConflict , dwTmp , TRUE);
		m_cParam.SaveParam("GeneralParam","CheckVITConflict",(DWORD)0,FALSE);
	}

	else
		m_cParam.LoadParam("GeneralParam","CheckAVIConflict",&m_dwCheckVITConflict , 1000 , TRUE);
	//4.0.0.55 (3.2.1.35) Eyal end

	//3.2.1.36
	//m_cParam.LoadParam("GeneralParam","MaxVolumeForVITConflict",&m_dwMaxVolumeForVITConflict, 1000, TRUE);

	if(!m_cParam.LoadParam("GeneralParam","MaxVolumeForVITConflict",&dwTmp, 0, FALSE)  && dwTmp)
	{
		m_cParam.LoadParam("GeneralParam","MaxVolumeForAVIConflict",&m_dwMaxVolumeForVITConflict , dwTmp , TRUE);
		m_cParam.SaveParam("GeneralParam","MaxVolumeForVITConflict",(DWORD)0,FALSE);
	}
	else
		m_cParam.LoadParam("GeneralParam","MaxVolumeForAVIConflict",&m_dwMaxVolumeForVITConflict , 1000 , TRUE);
	//3.2.1.36

	
	//add by Yaron for memo interval
	//if no data was found setting to 0
	m_cParam.LoadParam("GeneralParam","MemoInterval",&m_dwMemoInterval,0 ,TRUE);
	if(LOG_DETAIL_FLOW_CONTROL)
	{
		CString str;
		str.Format("MemoInterval:  %d,",m_dwMemoInterval);
		_LOGMSG.LogMsg(str);
	}
	
	//end add by yaron

	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","Region",tmpStr,sizeof(tmpStr),"USA",TRUE);
	if(!memcmp(tmpStr,"USA",3))
	{
		m_dwRegion = REGION_USA;
		dwDefaultOlaSrv = OLASRV_POSITIVE;
	}
	else if(!memcmp(tmpStr,"UK",2))
	{
		m_dwRegion = REGION_UK;
		dwDefaultOlaSrv = OLASRV_PROGRESS;
	}
	else if(!memcmp(tmpStr,"ISR",3))
	{
		m_dwRegion = REGION_ISRAEL;
		dwDefaultOlaSrv = OLASRV_POSITIVE;
	}
	//4.0.12.506
	else if(!memcmp(tmpStr,"EUR",3))
	{
		m_dwRegion = REGION_EUROPE;
	}
	//4.0.12.506
	else if(!memcmp(tmpStr,"AUS",3))
	{
		m_dwRegion = REGION_AUSTRALIA;
	}

	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","PpdPath",tmpStr,sizeof(tmpStr),"C:\\POSPump",TRUE);
	
	//Eyal 4.0.0.22 Start
	DWORD dwIsOlaRemote = 0;
	m_cParam.LoadParam("GeneralParam","OLASrvInUse",&m_dwOLASrvInUse, dwDefaultOlaSrv ,TRUE);
	m_cParam.LoadParam("GeneralParam","IsOlaRemote",&dwIsOlaRemote, 0 ,TRUE);
	if(dwIsOlaRemote)
		m_dwOLASrvInUse |= IS_OLA_REMOTE;
	
	//m_cParam.LoadParam("GeneralParam","OLASrvInUse",&m_dwOLASrvInUse, dwDefaultOlaSrv ,TRUE);

	//Eyal 4.0.0.22 End

	m_cParam.LoadParam("GeneralParam","OLALogDeclineReq",&m_dwOLALogDeclineReq, 0 ,TRUE);
	m_cParam.LoadParam("GeneralParam","AllowAuthOnNonRequest",&m_dwAllowAuthOnNonRequest, 0 ,TRUE);
	m_cParam.LoadParam("GeneralParam","NozzleLevelLogic",&m_dwNozzleLevelLogic, 0 ,TRUE);
	m_cParam.LoadParam("GeneralParam","OLAByController",&m_dwOLAByController, 0 ,TRUE);


	dwVal = 0;

	m_cParam.LoadParam("GeneralParam","OLAAutoReceiptCheck",&m_dwAutoReceiptCheck, 0,TRUE);
	m_cParam.LoadParam("GeneralParam","OLAAutoForce",&m_dwAutoForce, 0 ,TRUE);
	
	//The parameters OLAResponseTimeOut and OLACheckingInterval scale, was second. 
	//since we change the scale to be millisecond, we need to update an old parameter in case it wasn't done manually. 
	//We assume that if the values are too small then it wasn't update, and we do it here automatically.
	m_cParam.LoadParam("GeneralParam","OLAResponseTimeOut",&m_dwOLAResponseTimeOut, 35 ,TRUE);
	if (m_dwOLAResponseTimeOut < 1000)
	{
		m_dwOLAResponseTimeOut *= 1000;
		m_cParam.SaveParam("GeneralParam","OLAResponseTimeOut",m_dwOLAResponseTimeOut);
	}
	m_cParam.LoadParam("GeneralParam","OLACheckingInterval",&m_dwOLACheckingInterval, 1000 ,TRUE);
	if (m_dwOLACheckingInterval < 10)
	{
		if (m_dwOLACheckingInterval <= 0)  // 2.9.1.2
			m_dwOLACheckingInterval  = 1;

		m_dwOLACheckingInterval *= 1000;
		m_cParam.SaveParam("GeneralParam","OLACheckingInterval",m_dwOLACheckingInterval);
	}

	//2.9.3.4
	m_cParam.LoadParam((char *)"GeneralParam", "OlaMaxDeclineMessToDisplay",&dwTmp,100,TRUE);

	m_cParam.LoadParam("GeneralParam","AlternateServerAutoSwitch",&m_dwAutoSwitch, 0 ,TRUE);
	m_cParam.LoadParam("GeneralParam","ProcessLockRequest",&dwTmp,0,TRUE);
	m_cParam.LoadParam("GeneralParam","ProcessLockStatus",&dwTmp,0,TRUE);

	m_cParam.LoadParam("GeneralParam","StationLimitType",&m_dwStationLimitType, STATION_LIMIT_BY_VALUE ,TRUE);
	m_cParam.LoadParam("GeneralParam","VolumeLimit",&m_dwVolumeLimit, 50 ,TRUE);
	

	m_cParam.LoadParam("GeneralParam","CashLimit",&m_dwCashLimit, 50 ,TRUE);
	m_cParam.LoadParam("GeneralParam","CreditLimit",&m_dwCreditLimit, 35 ,TRUE);

	m_cParam.LoadParam("GeneralParam","ContactlessCreditLimit",&m_dwContactlessCreditLimit, 150 ,TRUE);
	m_cParam.LoadParam("GeneralParam","ContactlessDebitLimit",&m_dwContactlessDebitLimit, 100 ,TRUE);


	//PrePay limit  //4.0.3.32	 
	dwVal = 0;
	m_cParam.LoadParam("GeneralParam","PrePayLimit",&dwVal, 0 ,TRUE);
	SetPrePayLimit(dwVal);

	m_cParam.LoadParam("GeneralParam","CreditLimitByUser",&m_dwCreditLimitByUser, 0 ,TRUE);
	m_cParam.LoadParam("GeneralParam","DebitLimitByUser", &m_dwDebitLimitByUser, 0 ,TRUE);


	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","SiteID",tmpStr,sizeof(tmpStr),"",TRUE);
	m_sSiteID = tmpStr;

	m_cParam.LoadParam("GeneralParam", "AviTrsTimeOut",&m_dwAviTrsTimeOut,(DWORD)60,TRUE);

	m_cParam.LoadParam("GeneralParam", "RollingAsRemaining" , (LPDWORD)m_bRollingAsRemaining,0,TRUE); // 4.0.25.600   CR 296433

	// Price change time and method 
	//-----------------------------
	//4.0.8.5001GetLocalTime(&curSysTime);		

	//4.0.8.5001szTagTime.sNull = 0;
	//4.0.8.5001SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	//4.0.8.5001m_cParam.LoadParam("GeneralParam", "PriceChangeTime",(char *)&szTagTime,sizeof(szTagTime),(char *)&szTagTime,TRUE);
	//4.0.8.5001m_cParam.LoadParam("GeneralParam", "PriceChangeDone",&dwTmp,(DWORD)1,TRUE);
	m_cPriceChangeFlags.LoadFlags();

	m_cParam.LoadParam("GeneralParam", "PriceChangeLock",&dwTmp,(DWORD)1,TRUE);
	

	m_cParam.LoadParam("GeneralParam", "SuppressedDriveoffTimeout", &m_dwSuppressedDriveoffTimeout,(DWORD)0,TRUE);

	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","EncryptionKey",tmpStr,sizeof(tmpStr),"Non Valid Key",TRUE);
	m_strEncryptionKey = tmpStr;


	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","MACEncryptionKey",tmpStr,sizeof(tmpStr),"Non Valid Key",TRUE);

	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","KMEEncryptionKey",tmpStr,sizeof(tmpStr),"Non Valid Key",TRUE);

	m_cParam.LoadParam("GeneralParam", "StationLevelEncryption",&m_dwStationLevelEncryption,(DWORD)1,TRUE);

	m_cParam.LoadParam("GeneralParam", "MaxMemCreditDisplay",&m_dwMaxMemCreditDisplay,(DWORD)3,TRUE);

	m_cParam.LoadParam("GeneralParam", "UseServiceFee",&dwTmp,(DWORD)0,TRUE);

	if ( dwTmp)
		m_bUseServiceFee = TRUE;
	else
		m_bUseServiceFee = FALSE;

	m_cParam.LoadParam("GeneralParam", "AllowParallelAVIUsage",&dwTmp,(DWORD)1,TRUE);

	if ( dwTmp)
		m_bAllowParallelAVIUsage = TRUE;
	else
		m_bAllowParallelAVIUsage = FALSE;	

	dwTmp = 0;
	m_cParam.LoadParam("GeneralParam", "PaidAllAviTrs",&dwTmp,(DWORD)0,TRUE);
	
	//All the CRC fields in General Param
	m_cParam.LoadParam("GeneralParam", "GradesCRC",&dwTmp,(DWORD)0,TRUE);
	m_cParam.LoadParam("GeneralParam", "PumpsCRC",&dwTmp,(DWORD)0,TRUE);
	m_cParam.LoadParam("GeneralParam", "PureProductsCRC",&dwTmp,(DWORD)0,TRUE);
	m_cParam.LoadParam("GeneralParam", "TanksCRC",&dwTmp,(DWORD)0,TRUE);
	m_cParam.LoadParam("GeneralParam", "CarWashCRC",&dwTmp,(DWORD)0,TRUE);

	m_cParam.LoadParam("GeneralParam", "PostVoidActive",&dwTmp,(DWORD)0,TRUE);
	bPostVoidActive = (dwTmp)? TRUE: FALSE;  

	//4.0.12.502
	m_cParam.LoadParam("GeneralParam", "CashAcceptorActive",&dwTmp,(DWORD)0,TRUE);
	bCashAcceptorActive = (dwTmp)? TRUE: FALSE;  //4.0.12.502
	//4.0.0.30 changed to 3000
	//4.0.3.12
	m_cParam.LoadParam("GeneralParam", "OlaWaitingMessTimeOut",&dwOlaWaitingMessTimeOut,(DWORD)8000,TRUE);
	//4.0.0.30

	//3.1.1.5
	dwTmp = 0;
	m_cParam.LoadParam("GeneralParam", "ActiveLoyaltyDiscount",&dwTmp,(DWORD)0,TRUE);
		
	
	if ( dwTmp)
		m_bActiveLoyaltyDiscount = TRUE;
	else
		m_bActiveLoyaltyDiscount = FALSE;
	
	//3.1.1.5
	dwTmp = 0;
	m_cParam.LoadParam("GeneralParam", "AutoTimeCheck",&dwTmp,(DWORD)0,TRUE);
	if ( dwTmp)
		m_bAutoTimeCheck = TRUE;
	else
		m_bAutoTimeCheck = FALSE;
	
	//3.2.0.69
	//m_cParam.LoadParam("GeneralParam", "OLADebitShiftInProcess",&dwTmp,(DWORD)0,TRUE);
	//m_cParam.LoadParam("GeneralParam", "OLADebitShiftTimeOut",&dwTmp,(DWORD)60,TRUE);
	
	//3.2.0.69

	//4.0.0.45
	memset(tmpStr,0,sizeof(tmpStr));
	m_cParam.LoadParam("GeneralParam","ControllerFileFullPath",tmpStr,sizeof(tmpStr)," ",TRUE);
	//4.0.0.45
	
	//3.2.1.23
	m_cParam.LoadParam("GeneralParam", "ForceCreditLimitCheck",&m_dwForceCreditLimitCheck,(DWORD)0,TRUE);
	//3.2.1.23

	//3.2.1.63
	m_cParam.LoadParam("GeneralParam", "ClearTrsOnIdlePump",&m_dwClearTrsOnIdlePump,(DWORD)0,TRUE);
	//3.2.1.63
	

	// Items Index
	//4.0.8.503m_cParam.LoadParam("GeneralParam","ItemsIndex",&m_dwItemsIndex, 1,TRUE);
	m_cParam.LoadParam("GeneralParam","ItemsIndex",&m_dwItemsIndex, 1,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);

	m_cParam.LoadParam("GeneralParam" , "PrePayEnabled" , &m_dwPrePayEnabled , 1 , TRUE);

	//4.0.0.79
	m_cParam.LoadParam("GeneralParam", "Buy@PumpActive",&dwTmp,(DWORD)0,TRUE);

	//4.0.0.83
	m_cParam.LoadParam("GeneralParam" , "WatchdogInterval(mSec)" , &m_dwWatchdogInterval , 5000 , TRUE);

	//4.0.0.84  //4.0.0.85
	m_cParam.LoadParam("GeneralParam", "SetWaitingPrePayToTimeOut",&m_dwSetWaitingPrePayToTimeOutFlags,(DWORD)0,TRUE);

	//4.0.1.32  PumpSrv wetstock maintainance flag
	m_cParam.LoadParam("GeneralParam", "WetstockMaint",&m_dwWetStockMaint,(DWORD)0,TRUE);

	//4.0.1.38  PumpSrv VP managment flag start
	m_dwVpActive = 0;
	m_cParam.LoadParam("GeneralParam", "VpActive",&m_dwVpActive,(DWORD)0,TRUE);

	// 4.0.29.500 TD 264908
	dwVal = 0;  
	m_cParam.LoadParam("GeneralParam","VPRecoveryRetries",&dwVal,(DWORD)0,TRUE); 
	m_lVpRecoveryMaxRetries = dwVal;
	m_dwNozzleLeftOut = 0;
	m_cParam.LoadParam("GeneralParam" , "NozzleOutTimeout(Sec)" , &m_dwNozzleLeftOut , (DWORD)0 , TRUE);
	//4.0.1.38 end
	//4.0.2.15
	m_cParam.LoadParam("GeneralParam", "DebitSingleSession",&m_dwDebitSingleSession,(DWORD)0,TRUE);

	//4.0.2.15
	//4.0.2.36
	//m_cParam.LoadParam("GeneralParam" , "OLARetries" , &dwTmp , (DWORD)MAX_OLA_RETRIES , TRUE);

	//4.0.3.49
	m_dwLockPumpByMode = FALSE;
	m_cParam.LoadParam("GeneralParam","LockPumpByMode",&m_dwLockPumpByMode, 0, TRUE);
	
	//4.0.12.515
	m_cParam.LoadParam("GeneralParam","RollbackOnPriceChangeFailure",&m_dwRollbackOnPriceChangeFailure,(DWORD)0,TRUE);

	//4.0.13.500
	m_cParam.LoadParam("GeneralParam", "MinAlertSeverity_SoundAlert",&m_dwMinAlertSeverity_SoundAlert,(DWORD)0,TRUE);

	//4.0.5550.1504
	m_cParam.LoadParam("GeneralParam" , "DataBaseMaintenanceTimeout(Sec)" , &m_dwDataBaseMaintenanceTimeout , (DWORD)300 , TRUE);

	//4.0.13.512
	m_cParam.LoadParam("GeneralParam" , "SimTb" , &dwTmp,(DWORD)0,TRUE);

	//4.0.14.501
	m_cParam.LoadParam("GeneralParam", "LoyaltyTransactionCount",&m_dwLoyaltyTransactionCount,(DWORD)4,TRUE);
	m_cParam.LoadParam("GeneralParam", "LoyaltyTransactionTimeout(Min)",&m_dwLoyaltyTransactionTimeout,(DWORD)0,TRUE);

	m_cParam.LoadParam("GeneralParam", "CheckAndReserveTimeout", &m_dwCheckAndReserveTimeOut, (DWORD)120, TRUE);//4.0.17.20 - TD 26384

	//4.0.17.501 - CR 44000
	m_cParam.LoadParam("GeneralParam","SendZeroValuesWhenOffline",&m_dwSendZeroValuesWhenOffline,(DWORD)0,TRUE);

	//4.0.15.280
	dwVal = 0;
	m_cParam.LoadParam("GeneralParam","CanMoveToIdleMaxCount",&dwVal,(DWORD)10,TRUE); 
	m_lCanMoveToIdleMaxCount = dwVal;

	//4.0.18.501 merge from 4.0.15.291
	dwVal = 0;
	m_cParam.LoadParam("GeneralParam","ActiveReOrganizeReceiptQdx",&dwVal,(DWORD)1,TRUE); 
	if (dwTmp)
		m_bActiveReOrganizeReceiptQdx = TRUE;
	else
		m_bActiveReOrganizeReceiptQdx = FALSE;
	//4.0.21.500 TD 66935:
	m_cParam.LoadParam("GeneralParam","PumpLockTimeOut(Sec)",&m_dwPumpLockTimeOut, 0 ,TRUE);

	// TD 339257
	m_cParam.LoadParam("GeneralParam","PayPalActive",(unsigned long *)&m_bPayPalActive,(DWORD)0,TRUE);

	// CR 407579
	m_cParam.LoadParam("GeneralParam", "AutomaticAuthForLoyaltyCustomer", (unsigned long *)&m_bAutomaticAuthForLoyaltyCustomer, (DWORD)0, TRUE);

	m_cParam.LoadParam("GeneralParam", "ReduceCWDiscountFromCWAmount", (unsigned long *)&m_bReduceCWDiscountFromCWAmount, (DWORD)0, TRUE);

	// CR 438993
	m_cParam.LoadParam("GeneralParam", "PriceProtectionActive", &dwVal, 0, TRUE);
	m_lPriceProtectionActive = dwVal;

	m_cParam.LoadParam("GeneralParam", "PriceProtectionLevel", &dwVal, 0, TRUE);
	m_lPriceProtectionLevel = dwVal;

	m_cParam.LoadParam("GeneralParam", "AddRollingUpdateDataToLog", &dwVal, 0, TRUE);
	m_dwAddRollingUpdateDataToLog = dwVal;

	m_cParam.LoadParam("GeneralParam", "WaitForFinalizeResponse", &dwVal, 0, TRUE);//RFUEL-2117
	m_bWaitForFinalizeResponse = dwVal;
}

void CServerMain::LoadPumpsTable(BOOL bCreate , BOOL bRun)
{
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL];
	int i;
	DWORD dwVal = 0;

	//4.0.1.32 Start
	BYTE byNumBlenders = 0 , byNumRFID = 0;
	long lLinkedTerminalIndex = 0;
	//4.0.1.32 End

	CString sLogMsg;

	//3.2.0.34
	m_cParam.LoadParam("Pumps", "VolumeMultiply", &dwTmp, (DWORD)1,	TRUE);
	//3.2.0.34
	
	//Eyal 4.0.0.79 start
	m_cParam.LoadParam("Pumps" , "Support64Pumps" , &dwTmp , (DWORD)0 , TRUE);

	if(dwTmp)
	{
		m_lMaxPumps = MAX_PUMPS_64;  //set max pumps to 64
		m_cLogger.LogMsg("PumpSrv initialized with 64 pumps");
	}
	
	else
	{
		m_lMaxPumps = MAX_PUMPS;  //set max pumps to 32
		m_cLogger.LogMsg("PumpSrv initialized with 32 pumps");
	}

	//Eyal 4.0.0.79 end

	// If Pump Section not available - set defaults 											
	//------------------------------------------------

	for(i = 1; i <= MAX_PUMPS_64; i++)  //4.0.0.79  initialize/read 64 registry entries in any case.
	{
		CString str("Pumps\\Pump");
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		//
		// CREATE PARAMETERS THAT ARE NOT IN PUMPSRV USE 
		// all the rest will be created in first LoadDefinition() of each pump.
		//
		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ManufacturerName",		sTmpStr, sizeof(sTmpStr) ,"Tokheim", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Brand",					sTmpStr, sizeof(sTmpStr) ,"T", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Model",					sTmpStr, sizeof(sTmpStr) ," ", TRUE);
		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "BlenderType",			&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ServiceMode",			&dwTmp, (DWORD)SELF_SERVICE_MODE, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PriceLevelSelect",		&dwTmp, (DWORD)PRICE_LEVEL_ALLOW_DEFAULT, TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SingleHose",			&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "StartButton",			&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TerminalNumber",		&dwTmp, (DWORD)i,	TRUE);

		if(dwTmp && (dwTmp <= MAX_TERMINALS))
			lLinkedTerminalIndex = dwTmp - 1;
		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AntennaNumber",			&dwTmp, (DWORD)0,	TRUE);

		if(dwTmp)
			byNumRFID = 1;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "BaudRate",				&dwTmp, (DWORD)9600,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "DeviceAddress",			&dwTmp, (DWORD)i,	TRUE);

		//Eyal 3.1.1.62 Start
		m_cParam.LoadParam((char *)((LPCTSTR)str), "CommPort" ,	&dwTmp , (DWORD)1 ,	TRUE);
		//Eyal 3.1.1.62 End

		//The CRC field 
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ParamCRC",&dwTmp,(DWORD)0,TRUE);
		//add by yaron for the mode manual/auto
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ManualMode",&dwTmp,(DWORD)0,TRUE);
		//setting the manual values in the array
		m_lPumpsManualModeArray[i-1] = dwTmp;

		if((i == 1) || (i == 2))
		{
			m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)1,TRUE);
		}
		else
		{
			m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
		}

		//Eyal 4.0.0.79
		if(dwTmp)  //if this pump is valid
		{	
			//4.0.0.81
			//It is possible for a mistake in registry config to cause
			//m_lLastValidpump > m_lMaxPumps.  This will lead to a system
			//crash.
			if(i <= m_lMaxPumps)
				m_lLastValidPump = i;

			else
			{
				sLogMsg.Format("LoadPumpsTable, Pump %d configured, but max pumps supported is %d" , i , m_lMaxPumps);
				_LOGMSG.LogMsg(i,LOG_PUMP,sLogMsg);
			}

			//4.0.1.32
			m_cTerminalDevices[lLinkedTerminalIndex].SetNumberOfBlenders(byNumBlenders);
			m_cTerminalDevices[lLinkedTerminalIndex].SetNumberOfRFID(byNumRFID);
		}

		//3.1.1.69 start
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ReportNozzleOut",&dwTmp,(DWORD)0,TRUE); //2.9.4.0
		//3.1.1.69 end
		
		//3.2.0.5 start
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpVolumePrecision",&dwTmp,(DWORD)3,TRUE);
		//3.2.0.5 end

		//4.0.15.501 - TD 35841
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SlowDownVolume",&dwTmp,(DWORD)600,TRUE);

		//4.0.16.500 - TD 37522
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValueScaleFactor",&dwTmp,(DWORD)2,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PPGScaleFactor",&dwTmp,(DWORD)3,TRUE);


		CString tmpStr;
		for(int p = 1; p<= MAX_POSITIONS_PER_PUMP; p++)
		{
			tmpStr = str;
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%ld",p);
			tmpStr += "\\Position";
			tmpStr += sNumber;

			m_cParam.LoadParam((char *)(LPCTSTR)tmpStr, "Grade1", &dwVal, p,TRUE);

			//Set ValidEntry to pumps 1,2 and to postions 1,2,3
			if( (p == 1) || (p == 2) || (p == 3) ) //Positions 1,2,3
			{
				if ( (i == 1) || (i == 2) ) //Pumps 1,2
				{
					m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)1,TRUE);
				}
				else
				{	
					m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
				}
			}
			else
			{
				m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
			}

			//4.0.1.32 start
			//If this is a valid entry AND 
			//if a valid grade number has been configured 
			if(dwTmp && dwVal && (dwVal <= MAX_GRADES_99))//amram 4.0.10.502
			{
				//Check to see whether we have already been updated by this pump
				//(this can happen if the same grade has been configured
				//for more than one nozzle.
				if(m_cDevicesPerGrade[dwVal - 1].CanUpdate(i))
				{
					m_cDevicesPerGrade[dwVal - 1] += m_cTerminalDevices[lLinkedTerminalIndex];
					m_cDevicesPerGrade[dwVal - 1].UpdateMap(i);
				}
			}
			//4.0.1.32 start
		}

		for(int m = 1; m<= MAX_MODE_SCHEME; m++)
		{
			tmpStr = str;
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%1d",m);
			tmpStr += "\\ModeScheme";
			tmpStr += sNumber;
			
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ModeNumber",&dwTmp,(DWORD)1,TRUE);

			if(m==1)
			{
				m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)1,TRUE);
			}
			else
			{
				 m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
			}

			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "AutoDaily",&dwTmp,(DWORD)1,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "AutoWeekly",&dwTmp,(DWORD)0,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "AutoYearly",&dwTmp,(DWORD)0,TRUE);

			SYSTEMTIME curSysTime;
			GetLocalTime(&curSysTime);		
			SZ_TAG_SYSTEMTIME szTagTime;
			szTagTime.sNull = 0;
			SystemTime2Tag(&curSysTime,&szTagTime.sTime);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "StartTime", (char *)&szTagTime, sizeof(SZ_TAG_SYSTEMTIME) ,(char *)&szTagTime,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "EndTime", (char *)&szTagTime, sizeof(SZ_TAG_SYSTEMTIME) ,(char *)&szTagTime,TRUE);

			//memset(&szTagTime , ' ' , sizeof(szTagTime));
			memcpy(&szTagTime , "2000 1 1 0 0 0" , sizeof(szTagTime) -1);
			szTagTime.sNull = 0;

			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "PeriodStartTime", (char *)&szTagTime, sizeof(SZ_TAG_SYSTEMTIME) ,(char *)&szTagTime,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "PeriodEndTime", (char *)&szTagTime, sizeof(SZ_TAG_SYSTEMTIME) ,(char *)&szTagTime,TRUE);

			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ServiceFeeSet",&dwTmp,(DWORD)0,TRUE);  
			//4.0.2.21
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ServiceMode",&dwTmp,(DWORD)0,TRUE);  
			//4.0.2.21

		}

		m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ServiceFeeSet",&dwTmp,(DWORD)0,TRUE);  

		//4.0.2.21
		m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ServiceMode",&dwTmp,(DWORD)0,TRUE);  
		//4.0.2.21


		//4.0.2.15
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AutoPayOff",					sTmpStr, sizeof(sTmpStr) ,"A", TRUE);
		//4.0.3.61
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SaleStacking",&dwTmp,(DWORD)0,TRUE);  
		//4.0.2.15
		
		 
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);

		//4.0.1.32 - prepare variables for next iteration of loop.
		byNumRFID = byNumBlenders = 0;
	}

	//4.0.0.79 Start
	CString sMsg;
	sMsg.Format("LoadPumpsTable, last valid pump detected is %d" , m_lLastValidPump);
	m_cLogger.LogMsg(sMsg);
	//4.0.0.79 End
}

void CServerMain::LoadPureProductsTable(BOOL bCreate,BOOL bRun)
{
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL];
	int i;

	for(i = 1; i <= MAX_PURE_PRODUCTS; i++)
	{
		CString str("PureProducts\\PureProduct");
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;
			
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
		ZeroMemory((char *)sTmpStr, sizeof(sTmpStr));
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Name", (char *)sTmpStr, sizeof(sTmpStr),"",TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Code",&dwTmp,(DWORD)i,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Blendable",&dwTmp,(DWORD)0,TRUE);
		//Add by Yaron for tank configuration
		m_cParam.LoadParam((char *)((LPCTSTR)str), "TermalExpansion",&dwTmp,(DWORD)0,TRUE);
		//The CRC field in PureProducts\\PureProduct
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ParamCRC",&dwTmp,(DWORD)0,TRUE);

		//4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);
	}
	
}

void CServerMain::LoadShiftsTable(BOOL bCreate, BOOL bRun)
{
	CString str;
	DWORD dwTmp;
	int i;
	SYSTEMTIME curSysTime;
	SZ_TAG_SYSTEMTIME szTagTime;
	
	memset(&curSysTime , 0 , sizeof(curSysTime));
	GetLocalTime(&curSysTime);		
	memset(&szTagTime , 0 , sizeof(szTagTime));
	szTagTime.sNull = 0;
	SystemTime2Tag(&curSysTime,&szTagTime.sTime);

	for(i = 1; i<9; i++)
	{
		char sNumber[8];
		str = "Shifts\\Day";
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%d",i);
		str += sNumber;			

		str += "\\Shift";						
		for(int s=1; s<7; s++)
		{
			char sShiftNumber[8];
			memset(sShiftNumber,0,sizeof(sNumber));
			sprintf_s(sShiftNumber, _countof(sShiftNumber),"%d",s);
			CString shiftStr = str;
			shiftStr += sShiftNumber;
		
			if(s==1)
			{
				m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ValidEntry",&dwTmp,(DWORD)1,TRUE);
			}
			else
			{
				m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
			}

			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "StartTime", (char *)&szTagTime, sizeof(SZ_TAG_SYSTEMTIME) ,(char *)&szTagTime,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); //4.0.8.503
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ReadPumpTotals",&dwTmp,(DWORD)0,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ReadTanks",&dwTmp,(DWORD)0,TRUE);

			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ShiftEOD",&dwTmp,(DWORD)0,TRUE);//CR_475695_Start_End
			// 2.9.2.1 start
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "LockForeCourt",&dwTmp,(DWORD)0,TRUE);
			// 2.9.2.1 end 	

			//4.0.3.39
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ForceShiftOLA",&dwTmp,(DWORD)0,TRUE);

			//4.0.5550.1504
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "DataBaseMaintenance",&dwTmp,(DWORD)0,TRUE);

			//4.0.26.508 TD 146575
			m_cParam.LoadParam((char *)((LPCTSTR)shiftStr), "ExportSiteConfig", &dwTmp, (DWORD)0, TRUE);
	
			if (i==8)
				break;

		}

		//4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);
	}
}

void CServerMain::LoadReceiptTable(BOOL bCreate, BOOL bRun)
{
	CString str;
	DWORD dwVal;
	char sTmpStr[MAX_FIELD_VAL];
	
	memset(sTmpStr , 0 , sizeof(sTmpStr));

	m_cParam.LoadParam("Receipt", "HeaderCount",&dwVal,1,TRUE);	
	m_cParam.LoadParam("Receipt", "ReceiptRecordTimeout",&dwVal,0,TRUE);    //Default - 0 (if the parameter set to zero, then all the process should be shut down).
	m_cParam.LoadParam("Receipt", "MaxReceiptCopies",&dwVal,0,TRUE);        //If it set to 0 then there is no limit

	CString strHead("Header");

	for(int h = 1; h < 10 ; h++)
	{
		CString str;	
		str = strHead;
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%1d",h);
		str += sNumber;

		if(h == 1) 
		{
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"Welcome !!!",TRUE);
		}
		else
		{
			ZeroMemory((char *)sTmpStr, sizeof(sTmpStr));
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"",TRUE);
		}
	}

	m_cParam.LoadParam("Receipt", "TrailerCount",&dwVal,1,TRUE);
	CString strTrail("Trailer");
	for(int t = 1; t < 10 ; t++)
	{
		CString str;	
		str = strTrail;
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%1d",t);
		str += sNumber;

		if(t == 1)
		{
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"Thank You !!!",TRUE);
		}
		else
		{
			ZeroMemory((char *)sTmpStr, sizeof(sTmpStr));
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"",TRUE);
		}
	}
	
	m_cParam.LoadParam("Receipt", "HotPumpingCount",&dwVal,1,TRUE);
	
	//4.0.0.47
	m_cParam.LoadParam("Receipt", "MaxReceiptLineLen",&dwVal,20,TRUE);	
	
	CString strHotPumping("HotPumping");
	for(int t = 1; t < 4 ; t++)
	{
		CString str;	
		str = strHotPumping;
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%1d",t);
		str += sNumber;

		if(t == 1)
		{
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"Please pay cashier",TRUE);
		}
		else
		{
			ZeroMemory((char *)sTmpStr, sizeof(sTmpStr));
			m_cParam.LoadParam("Receipt", (char *)((LPCTSTR)str), (char *)sTmpStr, sizeof(sTmpStr) ,(char *)"",TRUE);
		}
	}

		//4.0.1.0
	if (bRun == FALSE)
		Sleep(REGISTRATION_SLEEP_TIME);

}

void CServerMain::LoadMessagesTable(BOOL bCreate)
{
	DWORD dwVal = 0;
	char sTmpStr[MAX_FIELD_VAL];
	
	memset(sTmpStr , 0 , sizeof(sTmpStr));

	m_cParam.LoadParam("Messages", "ScreenBasedMessagest",&dwVal,0,TRUE);

	memset(sTmpStr , 0 , sizeof(sTmpStr));
	m_cParam.LoadParam("Messages", "Idle"							, sTmpStr, sizeof(sTmpStr) ,"     Insert Card             or            Lift Handle to         Pay Inside    ",TRUE);
	m_cParam.LoadParam("Messages", "Promotion"						, sTmpStr, sizeof(sTmpStr) ,"Welcome to our smart fueling point",TRUE);
	m_cParam.LoadParam("Messages", "IdleScreen"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "PromotionScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "Odometer"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "OdometerScreen"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "VehicleId"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "VehicleIdScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "PIN"							, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "PINScreen"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "ReturnTank"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "ReturnTankScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "DriverId"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "DriverIdScreen"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardPrompt"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardPromptScreen"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardVoucherNumber"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardVoucherNumberScreen"	, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GeneralId"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GeneralIdScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardKeyCode"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "GasRewardKeyCodeScreen"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "Track2"							, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "Track2Screen"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyExpired"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyExpiredScreen"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyInvalid"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyInvalidScreen"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyNotMatchPayment"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyNotMatchPaymentScreen"	, sTmpStr, sizeof(sTmpStr) ,"",TRUE);

	m_cParam.LoadParam("Messages", "Unit"							, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "UnitScreen"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TripNumber"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TripNumberScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "CustomerReference"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "CustomerReferenceScreen"		, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TractorHub"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TractorHubScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TrailerNumber"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TrailerNumberScreen"			, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TrailerHub"						, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "TrailerHubScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);

	// start 3.1.1.61
	m_cParam.LoadParam("Messages", "LoyaltySwipePrompt"						, sTmpStr, sizeof(sTmpStr) ,"Swipe Pref Card or YES = Key-in#",TRUE);
	m_cParam.LoadParam("Messages", "LoyaltyManualPrompt"				, sTmpStr, sizeof(sTmpStr) ,"Key # and ENTER",TRUE);	
	// end 3.1.1.61

	//3.2.0.31
	m_cParam.LoadParam("Messages", "IdleIPT"				, sTmpStr, sizeof(sTmpStr) ," Welcome to Husky  please swipe your card",TRUE);	
	//3.2.0.31

	//4.0.0.47
	m_cParam.LoadParam("Messages", "MaxMessageLineLen",&dwVal,20,TRUE);	
	//4.0.0.47	
	
	//4.0.1.1
	m_cParam.LoadParam("Messages", "ChargeTo"					, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	m_cParam.LoadParam("Messages", "ChargeToScreen"				, sTmpStr, sizeof(sTmpStr) ,"",TRUE);
	//4.0.1.1

	//4.0.22.500 70766
	m_cParam.LoadParam("Messages", "MaxCouponsEntered",(char *)sTmpStr, sizeof(sTmpStr), (char *)SCREEN_MAX_COUPONS_STR,TRUE);

}

void CServerMain::LoadScreenLayoutsTable(BOOL bCreate, BOOL bRun)
{
	DWORD dwTmp = 0;
	char sTmpStr[MAX_FIELD_VAL];
	int i;

	memset(sTmpStr , 0 , sizeof(sTmpStr));

	for(i = 1; i <= MAX_SCREEN_LAYOUT; i++)
	{
		CString str("ScreenLayouts\\ScreenLayout");
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ScreenName", sTmpStr, sizeof(sTmpStr) ,sNumber,TRUE);

		char sSoftKey[64] = "SoftKeyXX";
		for (int iKey = 1 ; iKey <= 10 ; iKey++)
		{
			sprintf_s(sSoftKey, _countof(sSoftKey), "SoftKey%02d", iKey);
			ZeroMemory(sTmpStr, sizeof(sTmpStr));
			m_cParam.LoadParam((char *)((LPCTSTR)str), sSoftKey, (char *)sTmpStr, sizeof(sTmpStr) ,"",TRUE);
			//2.9.3.5
			sprintf_s(sSoftKey, _countof(sSoftKey), "Numeric%d", iKey - 1);
			ZeroMemory(sTmpStr, sizeof(sTmpStr));
			m_cParam.LoadParam((char *)((LPCTSTR)str), sSoftKey, (char *)sTmpStr, sizeof(sTmpStr) ,"",TRUE);
		}
		//4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);

	}

}

void CServerMain::LoadModesTable(BOOL bCreate, BOOL bRun)
{
	DWORD dwTmp = 0;
	char sTmpStr[MAX_FIELD_VAL];
	int i;

	for(i = 1; i <= MAX_MODES; i++)
	{
		CString str("Modes\\Mode");
		CString strModeName("Mode");
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;
		strModeName += sNumber;

		if(i==1)	
		{
			m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)1,TRUE);
		}
		else
		{
			m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
		}

		m_cParam.LoadParam((char *)((LPCTSTR)str), "Name",(char *)sTmpStr, sizeof(sTmpStr), (char *)((LPCTSTR)strModeName),TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAKValid",&dwTmp,(DWORD)1,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAKAuto",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAPValid",&dwTmp,(DWORD)1,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAPAuto",&dwTmp,(DWORD)1,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PrePayValid",&dwTmp,(DWORD)1,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PrePayAuto",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PayAttendValid",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PayAttendAuto",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PayAVIValid",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PayAVIAuto",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAMValid", &dwTmp, (DWORD)0, TRUE);// CR 444830
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PAMAuto", &dwTmp, (DWORD)0, TRUE);// CR 444830

		m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptorValid",&dwTmp,(DWORD)0,TRUE); //4.0.3.51
		m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptorAuto",&dwTmp,(DWORD)0,TRUE); //4.0.3.51
		m_cParam.LoadParam((char *)((LPCTSTR)str), "IdlePromptNum",&dwTmp,(DWORD)1,TRUE); //4.0.5.41	
		
				//4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);

	}

}

void CServerMain::LoadServiceFeeTable(BOOL bCreate, BOOL bRun)
{
	DWORD dwTmp = 0;
	char sTmpStr[MAX_FIELD_VAL];	
	int i;

	//4.0.2.21

	
	m_cParam.LoadParam("ServiceFee", "MinFullingToChargeServiceFee",(DWORD *)&m_lMinFullingToChargeServiceFee,(DWORD)0,TRUE);

	for(i=1; i <= MAX_SERVICE_FEE; i++)
	{
		CString str("ServiceFee\\ServiceFee");
		CString strModeName("ServiceFee");
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;
		strModeName += sNumber;

		m_cParam.LoadParam((char *)((LPCTSTR)str), "Valid",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Name",(char *)sTmpStr, sizeof(sTmpStr), (char *)((LPCTSTR)strModeName),TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PakService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PapService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PrePayService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AviService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "AttendService",&dwTmp,(DWORD)0,TRUE);		
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SelfPakService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SelfPapService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SelfPrePayService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SelfAviService",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "SelfAttendService",&dwTmp,(DWORD)0,TRUE);			

		//4.0.1.0
		if (bRun == FALSE)
			Sleep(REGISTRATION_SLEEP_TIME);

	}

}

void CServerMain::ConnectToHydService()
{
	long lHydraRes = 0;
	DWORD dwTmp = 0;
	
	m_dwHydraActive = 0;
	m_cParam.LoadParam("GeneralParam","HydraActive",&m_dwHydraActive,0,TRUE);
	m_cParam.LoadParam("GeneralParam","HydRecoveryTime",&dwTmp,10,TRUE);

	SetRedundancyByCL(m_dwHydraActive);			//4.0.23.508

	if ( IsRedundancyByCL() == TRUE )			//4.0.23.508 TD 89049
	{
		HandleRedundancyByCL(); 
	}
	
	if(m_dwHydraActive)
	{	
		/*31 = all the three interfaces with RTEVents and CFGEvents.
		  HydraActive will hold also the interfaces flags to connect to.*/
		lHydraRes = m_cHydra.InitHydra(m_dwHydraActive,"Software\\PointOfSale\\PumpSrv",(char *)(LPCTSTR)m_cIniFile.GetFilePath(),m_dwHydraActive,1,"PumpSrv",dwTmp);
		if(lHydraRes == 0)
		{
			if(LOG_BASIC_FLOW_CONTROL)		
				m_cLogger.LogMsg("PumpSrv is running with HydService");
		}
		else
		{
			//setting PumpSrv not to work with HydService
			m_dwHydraActive = 0;
			if(LOG_BASIC_FLOW_CONTROL)		
				m_cLogger.LogMsg("PumpSrv fail to init HydService");
		}
	}
}

//Eyal 4.0.0.22 Start
void CServerMain::CreateOLAServer()
{
	long OLA_in_use = GetOLAInUse();
	BOOL bRemoteOla = OLA_in_use & IS_OLA_REMOTE;
	
	if(bRemoteOla)  //Make M.S. bit 0
		OLA_in_use ^= IS_OLA_REMOTE;

	//Eyal 4.0.0.33
	OLAClassFactory(OLA_in_use , bRemoteOla);

	//4.0.0.73
	m_lNewOLAServer = NO_NEW_SERVER;
	
	//Eyal 4.0.0.52 Create registry entries for OLA
	//in case PumpSrv has been registered without proper installation.
	CreateRegEntries("SOFTWARE\\Positive\\System\\Servers\\PSRemote_OLA",
		             (BYTE*)"OLASrv.Services");
}
//Eyal 4.0.0.22 End

//Yaron 4.0.0.24 Start

/******************************************************************************
 Description:	Resets server info. Simulate state when loading
				PumpStat file with no signature.
 Returns:      	void  	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/3/2002   8:41		Start
******************************************************************************/

void CServerMain::ResetPSServerInfo()
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	m_cServerInfo.ResetServerInfo();

	SQLPumpSrvFile.SaveServerInfo();

}

/******************************************************************************
 Description:	Resets shift info. Simulate state when loading
				PumpStat file with no signature.
 Returns:      	void  	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/3/2002   8:41		Start
******************************************************************************/

void CServerMain::ResetPSShiftInfo()
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	// load and save current shift info.		
	FindCurrentShift(&m_cCurrentShift);				
	m_cCurrentShift.dwFormalShiftNumber = m_cCurrentShift.dwActiveShiftNumber;

	SQLPumpSrvFile.SaveShiftInfo();
}

/******************************************************************************
 Description:	Resets shift info. Simulate state when loading
				PumpStat file with no signature.
 Returns:      	void  
 Parameters:   	long lFileValid - use in InitServer for no signiture state.
				long lPumpNumber - pump number to reset.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/3/2002   8:41		Start
******************************************************************************/
void CServerMain::ResetPSPumpInfo(long lFileValid,long lPumpNumber)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	PAY_AT_PUMP_INFO	PAPInfo;
	CPumpTransact		trs;
	PUMP_INFO			pumpInfo;
	long				lRtc;

	//4.0.1.40 changed memset from 0 to spaces
	memset(&PAPInfo , ' ' , sizeof(PAY_AT_PUMP_INFO));
	memset(&pumpInfo,0,sizeof(PUMP_INFO));

	m_cPumpArray[lPumpNumber-1].SetNumber(lPumpNumber);	
	m_cPumpArray[lPumpNumber-1].SetLockStatus(UNLOCK,0);
	m_cPumpArray[lPumpNumber-1].SetShiftNumber(GetActiveShiftNumber());			

	//Yaron start
	m_cPumpArray[lPumpNumber-1].SetPAPInfo(&PAPInfo);
	//Yaron end

	SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);

	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	CPumpStatus cPumpStatus; //4.0.24.60 - clear also pump info
	m_cPumpArray[lPumpNumber-1].SetStat(cPumpStatus);

	
	//setting the trs to 0

	for (int t = 0; t < MAX_TRS_IN_LIST; t++)
	{		
		m_cPumpArray[lPumpNumber-1].GetTrsByIndex(t,&trs);
		if(trs.m_lNumber)
		{
			CString str;
			str.Format("ResetPSPumpInfo: trs number: %d ,volume: %d , Res:%d, Status:%d was deleted",trs.m_lNumber,trs.m_lRoundedValue,trs.m_lRes,trs.m_lStatus);
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
			
			//4.0.6.501
			if ((trs.m_nLinkFlags & TRS_LINK_PAK_AND_LOYALTY) ||
				(trs.m_nLinkFlags & TRS_LINK_PREPAY_NUMBER_AND_LOYALTY) ||
				(trs.m_nLinkFlags & TRS_LINK_EXTRA_INFO))
				lRtc = TrsLinkOperation(REC_DELETE,&trs,NULL);
		}

		trs.Clear();	//4.0.22.501 71055
		m_cPumpArray[lPumpNumber-1].SetTrsByIndex(t,&trs,FALSE);	
	}

	// load Registry information: 
	m_cPumpArray[lPumpNumber-1].LoadDefinition();

	m_lPrePayReTryReservation[lPumpNumber-1] = TIME_BETWEEN_RETRYING_RESERVED_PRE_PAID_PUMP;  //4.0.24.351 //4.0.124.355 //4.0.27.60 231255

	if (lFileValid == 1)
		SavePumpInfo(lPumpNumber);

	m_lAutoState[lPumpNumber-1] = PUMP_NONE_FIRST;		
}

/******************************************************************************
 Description:	Resets PumpStat Qdx file 	
 Returns:      	long - 0 succeed, 1 - invalid pump number
 Parameters:   	long lPumpNum - Pump to reset. 0 - all pumps.
				long lFlags - ResetServerInfo  	0x00000001
							  ResetShiftInfo  	0x00000002
							  ResetPumpInfo  	0x00000004
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/3/2002   8:44		Start
******************************************************************************/

long CServerMain::ResetPumpStatQdxData(long lPumpNum, long lFlags)
{
	long lRetVal = 0;
	long lValid = 1;

	
	if(SERVER_STATE_IDLE)//4.0.3.37
	{
		//To avoid from POS to do actions on the server.
		SetServerState(SERVER_STARTUP);
	}
	
	if (PUMP_NOT_VALID(lPumpNum) && lPumpNum != RESET_ALL_PUMPS)
		lRetVal = 1;

	if(lRetVal == 0)
	{
		if (lFlags & RESET_SERVER_INFO)
			ResetPSServerInfo();

		if (lFlags & RESET_SHIFT_INFO)
			ResetPSShiftInfo();
		
		if (lFlags & RESET_PUMP_INFO)
		{
			if(lPumpNum)	//specific pump
			{
				if ( !(lFlags & RESET_WITHOUT_REPORT_TO_CL) )			//4.0.23.508 TD 89049
				{
					SetCommand(CMD_RESET_CONTROLLER, lPumpNum ,0);
				}

				ResetPSPumpInfo(lValid,lPumpNum);					
			}
			else			
			{
				//All Pumps
				for( long p = 1; p <= m_lMaxPumps; p++)  //4.0.0.79
				{
					if ( !(lFlags & RESET_WITHOUT_REPORT_TO_CL) )			//4.0.23.508 TD 89049
					{
						SetCommand(CMD_RESET_CONTROLLER, p ,0);
					}
					
					ResetPSPumpInfo(lValid,p);						
				}
			}
		}	
	}

	return lRetVal;
}

//Yaron 4.0.0.24 End

//Eyal 4.0.0.25 Start
void CServerMain::SetNewOLAServer(long lNewSrv)
{
	EnterCriticalSection(&m_csNewOLAServer);
	m_lNewOLAServer = lNewSrv;
	LeaveCriticalSection(&m_csNewOLAServer);
}

long CServerMain::GetNewOLAServer()
{
	EnterCriticalSection(&m_csNewOLAServer);
	long lNewSrv = m_lNewOLAServer;
	LeaveCriticalSection(&m_csNewOLAServer);
	
	return lNewSrv;
}

/******************************************************************************
 Description:	Change active OLA server 	
 Returns:      	void
 Parameters:   	long lNewServerType - server to change to (see OLABase.h)
 Assumptions:   Validity of server type has been checked by CGPI::SwitchServer__
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Eyal			27/3/2002   14:30		Start
******************************************************************************/
void CServerMain::SwitchServer__(long lNewServerType)
{
	long lTmpSrvType = lNewServerType;
	COLABase * pNewSrv = NULL;
	COLABase * pOldSrv = m_cOLASrv;
	BOOL bCurrentServerRemote = (GetOLAInUse()) & IS_OLA_REMOTE;
	BOOL bNewServerRemote = lNewServerType & IS_OLA_REMOTE;

	if(bNewServerRemote)  //make M.S. bit zero
		lTmpSrvType = lNewServerType ^ IS_OLA_REMOTE;

	//If both the new server and the old server
	//are remote servers, switch to a new remote server.
	if(bCurrentServerRemote && bNewServerRemote)
	{
		COLATcpBase * pTmpTcpOla = dynamic_cast<COLATcpBase*>(pOldSrv);
		if(pTmpTcpOla)
			pTmpTcpOla->SwitchServer();
		
		else
			m_cLogger.LogMsg("Failed to switch between remote OLA servers");

		//Reset OLA server to NO_NEW_SERVER, so that
		//we do not attempt to change OLA server again
		//(this function is called periodically by the
		//CmdTX thread).
		SetNewOLAServer(NO_NEW_SERVER);
	}

	else
	{
		pOldSrv->ReleaseService(TRUE);
		delete pOldSrv;
						
		if(m_enmOlaThreadStatus == OLA_SERVER_OFF)
		{
			//Eyal 4.0.0.33
			OLAClassFactory(lTmpSrvType , bNewServerRemote);
											
			SetOLAInUse(lNewServerType);

			m_cOLASrv->RecreateService();

			//Reset OLA server to NO_NEW_SERVER, so that
			//we do not attempt to change OLA server again
			//(this function is called periodically by the
			//CmdTX thread).
			SetNewOLAServer(NO_NEW_SERVER);

			m_cLogger.LogMsg("SwitchServer() switched to new server" , LOG_LEVEL_0);
			
			//4.0.2.16 a new OLA server resets the OLA retry count
			m_cOLASrv->ResetRetryAttemps();
		}

		else		
		{
			m_cOLASrv = pOldSrv;
			m_cLogger.LogMsg("CGPI::SwitchServer() - OLA thread did not terminate, server change aborted" , LOG_LEVEL_0);
		}
	}
	
	return;
}

//Eyal 4.0.0.25 End
// 3.2.0.65 start
void CServerMain::InitTerminalIPT()
{
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL];
	int i;


	for(i = 0; i < MAX_IPT; i++)  //changed i to 0, and all subsequent calls to i to i + 1
	{
		CString str("IPT\\IPT"); 
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",(i + 1));
		str += sNumber;		

		m_cParam.LoadParam((char *)((LPCTSTR)str), "DeviceAddress",			&dwTmp, (DWORD)(i + 1),	TRUE);

		//changed value to set to i / 4 + 2
		//so that terminals 1 - 4 will be at port number 2
		//terminals 5 - 8 will be at 3, etc.
		m_cParam.LoadParam((char *)((LPCTSTR)str), "CommPort",				&dwTmp, (DWORD)((i / 4) + 2),	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Simulator",				&dwTmp, (DWORD)0,	TRUE);


		m_cParam.LoadParam((char *)((LPCTSTR)str), "CardReader",			&dwTmp, (DWORD)1,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "CashAcceptor",			&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "KeyboardType",			sTmpStr, sizeof(sTmpStr) ,"1", TRUE);


		m_cParam.LoadParam((char *)((LPCTSTR)str), "EncryptionKey",			sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "KMEEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "MACEncryptionKey",		sTmpStr, sizeof(sTmpStr), "Non Valid Key", TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PINEncryption",			&dwTmp, (DWORD)1,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",				&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "Type" , sTmpStr , sizeof(sTmpStr) , "PT3000" , TRUE);

		//The CRC field 
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ParamCRC",&dwTmp,(DWORD)0,TRUE);
	
		m_cParam.LoadParam((char *)((LPCTSTR)str), "OfflineTimeOut(mSec)" , &dwTmp , (DWORD)40 , TRUE);

		//GraphicDevice
		m_cParam.LoadParam((char *)((LPCTSTR)str), "GraphicDevice",	&dwTmp, (DWORD)1 , TRUE);

		m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpGroup01",	&dwTmp, (DWORD)0,	TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpGroup02",	&dwTmp, (DWORD)0,	TRUE);
				

		
	}
}

//Eyal 4.0.0.33 Start
/******************************************************************************
 Description:	Create an OLA server wrapper class 	
 Returns:      	
 Parameters:   	lType - number representing an OLA server type.  See OLABAse.h
                bRemote - TRUE when server is a remote OLA server, FALSE otherwise
 Assumptions:   
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Eyal			21/4/2002   16:04		Start
 Eyal           31/7/2002   4.0.0.73    Added OLASRV_NOT_CONFIGURED
 Amit H         10/04/2007  Support OLA . Net
 Alex M         17/07/2011  Support OLA EService 
******************************************************************************/
void CServerMain::OLAClassFactory(long lType, BOOL bRemote)
{
	switch(lType)
	{
	case OLASRV_NOT_CONFIGURED:  //No OLA configured or server not installed
		{
			m_cOLASrv = new COLASkeleton;
			if (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())	//4.0.23.504 66705
				m_cOLASrv->LoadAllProductSoldOnPump(0);
			
			break;
		}

	case OLASRV_POSITIVE:
		if(!bRemote)
			m_cOLASrv = new COLAPositiveSrv;

		else
			m_cOLASrv = new COLATcpPositiveSrv;
		break;
	case OLASRV_POSITIVE_US: //TD 72894 - 4.0.14.1640 //4.0.23.90 85955 //4.0.23.504
		{
			m_cOLASrv = new COLAPositiveUS;
			break;
		}

	case OLASRV_POSITIVE_EVENTS:
		m_cOLASrv = new COLAPositiveEventSrv;
		break;

	case OLASRV_PROGRESS:
		m_cOLASrv = new COLAProgressSrv;
		break;

	case OLASRV_POSWARE:
		m_cOLASrv = new COLARouteSrv;
		break;

	case OLASRV_POSITIVE_FIPAY:
		m_cOLASrv = new COLAPositive_FIPAYSrv;
		break;

	case OLASRV_POSITIVE_32:
		m_cOLASrv = new COLA32Srv;
		break;

	case OLASRV_POSITIVE_32_EVENTS:
		m_cOLASrv = new COLA32EventSrv;
		break;

	case OLASRV_POSITIVE_IFSF:
		m_cOLASrv = new COLAPositiveIFSF;  // 4.0.5.39
		break;
	case OLASRV_TRAVEL_CENTER:
		m_cOLASrv = new COLATravelCenter;  //4.0.9.511
		break;

	case OLASRV_SIMULATOR:
		m_cOLASrv = new COLASimulator;  // 4.0.5.42
		break;
	case OLASRV_PROGRESS_EX :
		m_cOLASrv = new COLAProgressSrvEx;//4.0.12.505
		break;
	case OLASRV_DOT_NET :
		m_cOLASrv = new COLADotNet;//4.0.16.504
		break;
	case OLASRV_STORE_LINE:
		m_cOLASrv = new CStoreLineOLA; //TD 42728		
		break;	
		
	case OLASRV_SIM_LINK_SRV: //4.0.20.500 TD 27377		
		m_cOLASrv = new COLASimLinkSrv;		
		break;

	case OLASRV_EService_SRV: // 4.0.20.500 TD 212899
		  m_cOLASrv = new COLAEserviceSrv;   
		  break;

	case OLASRV_CONNECTED_PAYMENTS:
		m_cOLASrv = new COLAConnectedPayments;
		break;

	case OLASRV_EPS:
		m_cOLASrv = new COLAEps;
		break;

	case OLASRV_EPSILON:
		m_cOLASrv = new COLAEpsilon;
		break;

	// RFUEL-2817,use a new Epsilon Server
	case OLASRV_EPSILON_DISCOUNT:
		m_cOLASrv = new COLAEpsilonDiscount;
		break;

	default:
		m_cOLASrv = new COLASkeleton;
		if (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())	//4.0.19.820 66705
		{
			m_cOLASrv->LoadAllProductSoldOnPump(0);
			_LOGMSG.LogMsg("OLAClassFactory, COLASkeleton called LoadAllProductSoldOnPump"); //4.0.19.980 111671
			
		}
		
		break;
	}
}
//Eyal 4.0.0.33 End

/******************************************************************************
 Description:	Checks if PS can move to IDLE state, checks 2 conditions:
				1. If working with MultiSync, is data update completed.
				2. If PumpStat qdex is ready and was successfully read/save
 Returns:      	BOOL - TRUE can move, FALSE can't move.
 Parameters:	BOOL* bNeedAllPumpStatus - returns if need a all pump status
				request for status sync.
  	
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			22/4/2002   16:17		Start
 Yaron			02/4/2004   11:30		Change
 Amit H         18/9/2007               Change - Add a counter of max retries to let PumpSrv switch to IDLE
										even if Hydservice is NOT updated complete

******************************************************************************/
BOOL CServerMain::CanMoveToIDLE(BOOL* pbNeedAllPumpStatus)
{
	BOOL bRetVal = FALSE;
	long lHydServiceErrors = 0;
	BOOL bStatusChangeToReady = FALSE;
	BOOL bNeedAllPumpStatus = FALSE;
	static long lCanMoveToIdleMaxCount = 0; //4.0.18.501 merge from 4.0.15.280

	//4.0.5.24 - check first if PumpStat qdex is ready.
	if( m_cPumpFile.IsFileReady(&bStatusChangeToReady) )
	{
		//if qdex status was change to ready need pump status 
		bNeedAllPumpStatus = bStatusChangeToReady;
		if( _HOST.m_lHydraActive )
		{
			//if active always need status request
			bNeedAllPumpStatus = TRUE;
			//cheching if to computers are connected
			if( _HOST.IsHydSrvConnected() )
			{
				//checking if no errors at HydService operation
				lHydServiceErrors = _HOST.GetHydServiceErrors();
				if( lHydServiceErrors == 0 ) //no errors
				{
					/*if we got to here HydService works ok and we can check
					  if the update between two computers was complete*/
					if( _HOST.IsUpdateComplete() )
					{
						bRetVal = TRUE;
						lCanMoveToIdleMaxCount = 0;  //reset the counter 4.0.18.501 merge from 4.0.15.280
					}
					else
					{
						bRetVal = FALSE;
						if(LOG_LOGIC_ERROR)		
							m_cLogger.LogMsg("CanMoveToIDLE, Update between two computers not completed");
						//4.0.18.501 merge from 4.0.15.280
						lCanMoveToIdleMaxCount++;
						if (lCanMoveToIdleMaxCount >= m_lCanMoveToIdleMaxCount) 
						{
							lCanMoveToIdleMaxCount = 0;
							bRetVal = TRUE;
							if(LOG_LOGIC_ERROR)	
							{
								CString cMsg;
							    cMsg.Format("CanMoveToIDLE (reached max retry %ld), Update between two computers not completed - Switch anyway !",m_lCanMoveToIdleMaxCount);
								m_cLogger.LogMsg(cMsg);
							}
						}
					}
				}
				else
				{
					//if errors during HydService operation there is no use to stop he switching
					bRetVal = TRUE;
					if(LOG_LOGIC_ERROR)
					{
						CString cMsg;
						cMsg.Format("CanMoveToIDLE, HydService has errors:%d",lHydServiceErrors);
						m_cLogger.LogMsg(cMsg);
					}
				}
			}
			else
			{
				//if not connecting there is no use to stop he switching
				bRetVal = TRUE;
				if(LOG_LOGIC_ERROR)		
					m_cLogger.LogMsg("CanMoveToIDLE, HydService is not connected to other computer");
			}
		}
		else	//if not having HydService can switch.
		{
			bRetVal = TRUE;
		}
	}
	else
	{
		bRetVal = FALSE;
		if(LOG_LOGIC_ERROR)		
			m_cLogger.LogMsg("CanMoveToIDLE, Pump stat qdex is not ready");
		SetQdxIsGone(TRUE);
	}
	if(pbNeedAllPumpStatus)
		*pbNeedAllPumpStatus = bNeedAllPumpStatus;
	
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString cMsg;
		cMsg.Format("CanMoveToIDLE, return:%d,requied pump status return:%d",bRetVal,bNeedAllPumpStatus);
	}

	return bRetVal;
}


void CServerMain::InitDebitShiftParameter()
{
	if (m_cServerInfo.GetDebitShiftProcessFlags())
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{		
			m_cLogger.LogMsg("InitDebitShiftParameter  ");	
		}

		for(int i = 1; i <= m_lMaxPumps; i++)  //4.0.0.79
		{
			DWORD dwTmp =0;
			CString str("Pumps\\Pump");
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",i);
			str += sNumber;							
		}
	}
}
//4.0.0.45 start
/******************************************************************************
 Description:	Loads data from the Pump dqx according to load parameter 	
 Returns:      	long
 Parameters:   	long lLoadFlag - can be:LOAD_SERVER_INFO,
										LOAD_SHIFT_INFO,
										LOAD_PUMPSTAT_INFO
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			9/5/2002   11:38		Start
******************************************************************************/
long CServerMain::LoadPumpFileInfo(long lLoadFlag)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	long lRetVal = 0;
	long lPumpNum = 0;
	CString cDebugMsg = "LoadPumpFileInfo, ";
	CString cPumpNum;

	//4.0.12.509
	//if the server is not in IDLE state - we need to update the status from the other computer 
	if (GetServerState() == SERVER_IDLE)
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			str.Format("LoadPumpFileInfo , Received new pump status form secondary machine while serevr IDLE,  Ignore change status");
			m_cLogger.LogMsg(lPumpNum,LOG_PUMP,str);
		}
	}
	else
	{
		if( lLoadFlag & LOAD_SERVER_INFO )
		{
			SQLPumpSrvFile.LoadServerInfo();
	
			cDebugMsg += " (SERVER_INFO)";
		}	
		if( lLoadFlag & LOAD_SHIFT_INFO )
		{

			SQLPumpSrvFile.LoadShiftInfo();

			UpdateShiftAtPumps();//4.0.0.78
			cDebugMsg += " (SHIFT_INFO)";
		}	
		if( lLoadFlag & LOAD_PUMPSTAT_INFO )
		{
			//4.0.0.78 - Pump number data is passed in bit 17 and higher.
			lLoadFlag &= NOT_LOAD_PUMPSTAT_INFO;
			lPumpNum = lLoadFlag >> 16;
			
			LoadPumpStat(lPumpNum,FALSE);
			cDebugMsg += " (PUMPSTAT_INFO)";
			cPumpNum.Format(" ,Pump:%d",lPumpNum);
			cDebugMsg += cPumpNum;
		}
		if(LOG_DETAIL_FLOW_CONTROL)
			m_cLogger.LogMsg(cDebugMsg);
	}

	return lRetVal;
}
//4.0.0.45 end

BOOL CServerMain::IsNeedCreditLimitCheck()
{
	if (m_dwForceCreditLimitCheck)
		return TRUE;
	else
		return FALSE;
}


/******************************************************************************
 Description:	Send debit data 	
 Returns:      	none
 Parameters:   	SendDebitResult(long lPumpNumber , long lSessionId)
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			21/5/2002   14:32		Start
******************************************************************************/
void CServerMain::SendDebitResult(long lPumpNumber , long lSessionId)
{
	CMD_STRUCT_DEBIT_PROCESS  cmdInfo;
	memset(&cmdInfo , ' ' , sizeof(CMD_STRUCT_DEBIT_PROCESS));

	cmdInfo.lFlags = 0;
	cmdInfo.lPumpNumber = lPumpNumber;
	cmdInfo.lSessionId =  lSessionId;

	m_cDebitInfoArray[lPumpNumber -1].GetDebitInfo(&cmdInfo.cOLaDebitInfo);	
			
	SetCommand(CMD_DEBIT_PROCESS, 
		SERVER_POS_NUMBER, 
		lPumpNumber,
		&cmdInfo,
		sizeof(CMD_STRUCT_DEBIT_PROCESS));
}


long CServerMain::CreateRegEntries(char * sEntry , BYTE * sVal)
{
	HKEY hkeyRes;
	DWORD dwDisposition = 0;

	long lErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				               sEntry,
				               0,
				               NULL,
							   0,
							   KEY_WRITE|KEY_READ|KEY_QUERY_VALUE,
							   NULL,
							   &hkeyRes,
							   &dwDisposition);

	if(dwDisposition == REG_CREATED_NEW_KEY)
	{
		if(!lErr)
		{
			lErr = RegSetValueEx(hkeyRes,
								 "",
								 0,
								 REG_SZ,
								 sVal,
								 (strlen(sEntry) + 1));

		}

		//Eyal 4.0.0.34 Start
		if(!lErr)
		{
			lErr = RegSetValueEx(hkeyRes,
								 "MasterHost",
								 0,
								 REG_SZ,
								 (BYTE*)"localhost",
								 9);
		}
		//Eyal 4.0.0.34 End
	}
	
	RegCloseKey(hkeyRes);
	
	return lErr;
}

void CServerMain::LoadDataBaseTable()
{
	CString str;
	DWORD dwTmp;

	m_cParam.LoadParam("Database", "RFS",&dwTmp,(DWORD)10,TRUE);
	str = "Database\\RFS";

	m_cParam.LoadParam((char *)((LPCTSTR)str), "UseBackUp",&dwTmp,0,TRUE);


	m_cParam.LoadParam("Database", "ShiftDeliveryTotals",&dwTmp,(DWORD)SHIFT_DELIVERY_FILE,TRUE);
	str = "Database\\ShiftDeliveryTotals";

	m_cParam.LoadParam((char *)((LPCTSTR)str), "UseBackUp",&dwTmp,0,TRUE);


	m_cParam.LoadParam("Database", "ShiftTankTotals",&dwTmp,(DWORD)SHIFT_TANKS_FILE,TRUE);
	str = "Database\\ShiftTankTotals";

	m_cParam.LoadParam((char *)((LPCTSTR)str), "UseBackUp",&dwTmp,0,TRUE);


	m_cParam.LoadParam("Database", "ShiftPumpTotals",&dwTmp,(DWORD)SHIFT_PUMP_FILE,TRUE);
	str = "Database\\ShiftPumpTotals";

	m_cParam.LoadParam((char *)((LPCTSTR)str), "UseBackUp",&dwTmp,0,TRUE);
}

/******************************************************************************
 Description:	Sending the PumpMode2 events for all pumps
 Returns:      	
 Parameters:    

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Udi F			29/06/2004   18:58		Start
******************************************************************************/
void CServerMain::SendPumpMode2Events()
{
	m_cLogger.LogMsg("CServerMain::SendPumpMode2Events Start Change Modes");
	for (int p = 0; p < GetLastValidPump(); p++)  
	{
		CMD_STRUCT_MODE2 cmdInfo;
		memset(&cmdInfo, 0, sizeof(CMD_STRUCT_MODE2) );
		cmdInfo.lMode = m_cPumpArray[p].GetStat().GetMode();

		if (cmdInfo.lMode == 0)
		{
			return;
		}
		cmdInfo.lServiceMode = m_cPumpArray[p].GetModeSchemeServiceMode();
		cmdInfo.lServiceFee = m_cPumpArray[p].GetCurrentServiceFee();
		cmdInfo.lFlags = m_cModeArray[cmdInfo.lMode - 1].GetFlags(); //4.0.14.500

		//4.0.20.504- TD 65134
		if (p == GetLastValidPump()-1)
		{
			cmdInfo.lFlags |= MODE_DEF_END_OF_LIST; 
			if(LOG_BASIC_FLOW_CONTROL)
			{
				m_cLogger.LogMsg(p,LOG_PUMP,"Send MODE_DEF_END_OF_LIST flag to CL on the last valid pump");
			}
		}

		SetCommand(CMD_SET_PUMP_MODE2, SERVER_POS_NUMBER, p + 1,&cmdInfo,sizeof(CMD_STRUCT_MODE2));						
	}
}


/******************************************************************************
 Description:   Sending the PumpMode3 events for all pumps
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Roni 			14/6/2005   11:32		Start
******************************************************************************/
void CServerMain::SendPumpMode3Events()
{
	m_cLogger.LogMsg("CServerMain::SendPumpMode3Events Start Change Modes");
	for (int p = 0; p < GetLastValidPump(); p++)  
	{
		CMD_STRUCT_MODE3 cmdInfo;
		memset(&cmdInfo, 0, sizeof(CMD_STRUCT_MODE3) );
		cmdInfo.lMode = m_cPumpArray[p].GetStat().GetMode();
		cmdInfo.lServiceMode = m_cPumpArray[p].GetModeService();
		cmdInfo.lServiceFee = m_cPumpArray[p].GetCurrentServiceFee();
		cmdInfo.lPriceLevel = m_cPumpArray[p].GetPriceLevel();
		cmdInfo.lFlags = m_cModeArray[cmdInfo.lMode - 1].GetFlags(); //4.0.14.500

		//4.0.12.503
		if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse())
			m_cGPIEventMgr.AddSetPumpMode(p + 1, cmdInfo.lMode, cmdInfo.lServiceMode, cmdInfo.lServiceFee, cmdInfo.lPriceLevel, 0);

		//4.0.20.504 - TD 65134
		if (p == GetLastValidPump()-1)
		{
			cmdInfo.lFlags |= MODE_DEF_END_OF_LIST; 
			if(LOG_BASIC_FLOW_CONTROL)
			{
				m_cLogger.LogMsg(p,LOG_PUMP,"Send MODE_DEF_END_OF_LIST flag to CL on the last valid pump");
			}
		}
		SetCommand(CMD_SET_PUMP_MODE3, SERVER_POS_NUMBER, p + 1,&cmdInfo,sizeof(CMD_STRUCT_MODE3));						
	}
}

/******************************************************************************
 
 Description:	Move database parmeter to directory.
 Returns:       None	
 Parameters:   	None
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			12/6/2002   18:48		Start
******************************************************************************/
void CServerMain::ConvertDataBaseInfo()
{
	DWORD dwTmp;
	CString str("Database\\PumpStat"); 
	
	if (m_cParam.LoadParam((char *)((LPCTSTR)str), "PumpStat",&dwTmp,(DWORD)0,FALSE))
	{
		str = "Database\\Alarm"; 
			
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);
		
		str = "Database\\CarWash";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp", (DWORD)0);


		str = "Database\\Delivery";
				
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);


		str = "Database\\ExtraInfo";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\OLA";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);


		str = "Database\\PrePay";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\PumpStat";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);


		str = "Database\\PumpTotals";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\Receipt";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\RFS";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\TankRead";
					
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);

		str = "Database\\Items";
		
		m_cParam.SaveParam((char *)((LPCTSTR)str), "UseBackUp",(DWORD)0);
	}	
}


/******************************************************************************
 Description:	Generate new index to items file 	
 Returns:      	New index
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			18/6/2002   12:26		Start
******************************************************************************/
long CServerMain::NewItemsIndex()
{
	// 4.0.5.28
	if(m_dwItemsIndex >= MAX_INDEX_NUMBER - 4)
		m_dwItemsIndex = 1;
	else
		m_dwItemsIndex +=4;

	m_cParam.SaveParam("GeneralParam","ItemsIndex",m_dwItemsIndex,TRUE,_HOST.m_lGroupNum,0,0,TRUE);//4.0.0.66 4.0.8.503
	
	return ((long)m_dwItemsIndex);
}

GCIRetCode CServerMain::SetAttendantTrs(long lPumpNumber, long lTrsNumber, long lState, long lFlags, BSTR sData, long *plRetVal)
{
	CPumpTransact cTrs , cTmpTrs;
	long lPump = lPumpNumber - 1;
	long lTerminalNumber = (TRS_ATTEND_IS_ACCEPTED_PUMP & lFlags )? (BASE_TERMINAL_NUMBER +lTrsNumber): (BASE_TERMINAL_NUMBER + lPumpNumber); //4.0.2.23
	BOOL bNotFound = FALSE , bCreditCardSale = TRUE;
	BOOL bIfPaidQDX = FALSE;//4.0.11.504

	CARD_SALE_ALL3   cCardData;
	int iLen = 0;
	CString sMsg;
	GCIRetCode retCode = GCI_OK;

	memset(&cCardData , ' ' , sizeof(cCardData));
	//4.0.9.508 if lflag than we will bring the trs by her number
	//it's becuase there more then on unpaid PAK att
	if((lFlags & TRS_LOYALTY_CARD)||(lFlags & TRS_PAK_PAYMENT_CARD))
	{
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,"CServerMain::SetAttendantTrs get trs by Number");
		bNotFound = m_cPumpArray[lPump].GetTrsByNumber(lTrsNumber,&cTrs);
		if (cTrs.m_lRes != PAY_AT_KIOSK)  //4.0.14.504
			bNotFound = TRUE;
	}
	else
	{
		long lNumberOftrs = 0;
		//remove comment upon removing debug section above
		bNotFound = m_cPumpArray[lPump].GetAttendTrs(lFlags , &cTrs , lNumberOftrs); ////4.0.22.501 - merged from 4.0.22.12 TD 73062
	//bFound = m_cPumpArray[lPump].GetTrsByNumber(lTrsNumber , &cTrs);
	}

	//4.0.11.504
	//need to get the trs from paid qdx
	if(!(bNotFound)&&(lFlags & TRS_LOYALTY_CARD) )//in case the trs still inPS
	{
		if (cTrs.GetStatus() == PAID)
		{
			bIfPaidQDX = TRUE;//need to work with QDX
			m_cLogger.LogMsg("CGCI::SetTrsStateAttendant Work With QDX1");
		}
	}
	if((bNotFound)&&(lFlags & TRS_LOYALTY_CARD) )
	{
		if(GetTrsFromPaidQdx(lPumpNumber,lTrsNumber,cTrs))
		{
			bNotFound =0;
			bIfPaidQDX = TRUE;//need to work with QDX
			m_cLogger.LogMsg("CGCI::SetTrsStateAttendant Work With QDX");
		}
	}
	if(bNotFound)
	{
		CString sMsg;
		sMsg.Format("CGCI::SetTrsStateAttendant information not found for PumpNumber=%02ld not found", lPumpNumber);
		_LOGMSG.LogMsg(sMsg);
		retCode =  GCI_TRS_MISMATCH;
	}
	//4.0.9.508
	else if ((cTrs.m_lResExt == RES_EXT_ATTENDANT)||
			(lFlags & TRS_LOYALTY_CARD) ||(lFlags & TRS_PAK_PAYMENT_CARD))//agip
	{		
		TAG_OLA_REC10  cTagOlaRec10;    //4.0.22.70 TD 74387
		long		lOlaRecordSize = 0;
		long		lTagOlaRecordSize = 0;

		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString sMsg;
			sMsg.Format("CGCI::SetTrsStateAttendant information for PumpNumber=%02ld, lFlags=%ld", lPumpNumber , lFlags);
			_LOGMSG.LogMsg(sMsg);
		}

		lTagOlaRecordSize= (lFlags & TRS_OLA_THREE_REC) ? ((lFlags & TRS_WITH_EXTRA_ITEM)? sizeof(TAG_OLA_REC7_EX):sizeof(TAG_OLA_REC6_EX)) : sizeof(TAG_OLA_REC4_EX);
		if(lFlags & TRS_INCLUDE_ZONE)
			lTagOlaRecordSize = sizeof(TAG_OLA_REC10); //4.0.22.70 TD 74387

		BYTE sTmp[sizeof(TAG_OLA_REC10) + 2];	//4.0.5.15  //4.0.5.27 //4.0.22.70 TD 74387
		memset(sTmp , 0, sizeof(TAG_OLA_REC10) + 2); //4.0.5.15 //4.0.22.70 TD 74387
		memset(&cTagOlaRec10 , ' ' , sizeof(cTagOlaRec10)); //4.0.22.70 TD 74387

		
		//4.0.0.69
		if (lFlags & TRS_ATTEND_MOVE_TO_PAK)
		{			
			if( (cTrs.GetStatus() == UNPAID) && (cTrs.GetOnOffer() == 0))
			{				
				cTrs.m_lResExt = NULL_RES_EXT;
				CentralUpdateTrs(lPumpNumber,cTrs.m_lNumber,&cTrs,FALSE);
			}
			else
			{
				retCode = GCI_TRS_NOT_FOR_SALE; 
			}
			iLen = 1;

		}
		//4.0.14.500
		else if (m_bUseXmlBuffer)
		{
			char sXmlBuff[MAX_XML_BUF_LEN];
			memset(&sXmlBuff,0,sizeof(sXmlBuff)); //4.0.22.70 TD 74387
			iLen = Bstr2Buffer(sData,(char *)sXmlBuff,MAX_XML_BUF_LEN ); //4.0.22.70 TD 74387
			//Convert to struct
			// 4.0.15.500
			if (lState == STATE_PAID)
				m_cXmlConvertorEx.ConvertFromXmlToStruct(sXmlBuff,&cCardData);
			else
				memset(&cCardData, ' ', sizeof(cCardData));
		}
		else if (lFlags & TRS_INCLUDE_ITEMS)
		{			

			if(LOG_DETAIL_FLOW_CONTROL)   //4.0.11.451
			{
				CString str;
				str.Format("GCI::SetTrsState received Before Parsing");
				_LOGMSG.LogMsg( str ); 
			}	

			iLen = Bstr2Buffer(sData,(char *)&sTmp,lTagOlaRecordSize);

			if (iLen)
			{
				if (lFlags & TRS_OLA_THREE_REC)
				{
					memcpy (&cTagOlaRec10 , sTmp ,lTagOlaRecordSize); //4.0.22.70 TD 74387
					cCardData.extData3 = cTagOlaRec10.extraData3; //4.0.22.70 TD 74387
					cCardData.extData4 = cTagOlaRec10.extraData4; //4.0.22.70 TD 74387
				}
				else
				{
					TAG_OLA_REC4_EX  cTagOlaRec4;
					memcpy (&cTagOlaRec4 , sTmp ,lTagOlaRecordSize);
					cTagOlaRec10.cardData = cTagOlaRec4.cardData;
					cTagOlaRec10.extraData = cTagOlaRec4.extraData;
					cTagOlaRec10.extraData2 = cTagOlaRec4.extraData2;					
				}
				
				cCardData.CardSaleAll.data		= cTagOlaRec10.cardData;
				cCardData.CardSaleAll.extData	= cTagOlaRec10.extraData;
				cCardData.extData2				= cTagOlaRec10.extraData2;				
			}			 
		}
		else
		{
			lOlaRecordSize= (lFlags & TRS_OLA_THREE_REC) ? sizeof(CARD_SALE_ALL3):sizeof(CARD_SALE_ALL2);  //4.0.5.15
			iLen = Bstr2Buffer(sData,(char *)&sTmp,lOlaRecordSize);


			if (lFlags & TRS_OLA_THREE_REC)
			{
				memcpy(&cCardData, sTmp,lOlaRecordSize);				
			}
			else
			{				
				memcpy(&cCardData, sTmp,lOlaRecordSize);
			}			
		}
 
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			str.Format("GCI::SetTrsState received buffer  : Flags=%ld ,TrsNumber=%ld, Size=%ld", lFlags, lTrsNumber,iLen);					
			_LOGMSG.LogMsg( str ); 
		}	

	
		//Zero indicates failure
		if(!iLen)
		{
			sMsg = "CGCI::SetTrsState() error in converting BSTR : ";

			DWORD dwError = GetLastError();

			switch(dwError)
			{
			case ERROR_INSUFFICIENT_BUFFER:
				sMsg += "ERROR_INSUFFICIENT_BUFFER";
				break;

			case ERROR_INVALID_FLAGS:
				sMsg += "ERROR_INVALID_FLAGS";
				break;

			case ERROR_INVALID_PARAMETER:
				sMsg += "ERROR_INVALID_PARAMETER";
				break;
			}

			if(LOG_BASIC_FLOW_CONTROL)
				_LOGMSG.LogMsg(sMsg);

			retCode = GCI_FAILED_IO;
		}
		else
		{
			if (lState == STATE_PAID)
			{
				if (iLen < sizeof(CARD_SALE_ALL2)) 
				{
					if(LOG_BASIC_FLOW_CONTROL)
					{
						sMsg.Format("Messages to short ilen=%ld !!!!!!" , iLen);
						_LOGMSG.LogMsg(sMsg);
					}

					retCode = GCI_FAILED_IO;
				}
			}
			else
			{
				memset(sTmp , ' ' , sizeof(sTmp));	
			}
		}

		if ((retCode == GCI_OK) && (!(lFlags & TRS_ATTEND_MOVE_TO_PAK)))
		{
			// Record already fill  before...
			//memcpy(&cCardData , sTmp,lOlaRecordSize);
			//if( lFlags & TRS_PAID_TO_ATTEND)
			//This method is invoked upon payment.
			//If this is a cash transaction, that means the
			//attendant has received the money.

			CMD_STRUCT_TRS cTrsCmd;
			size_t size = sizeof(CMD_STRUCT_TRS);
			cTrsCmd.lTrsNumber = cTrs.m_lNumber;

			switch(lState)
			{
				case STATE_PAID_LOYLATY://4.0.11.503
				{
					CString str;
					if(!(bIfPaidQDX))
					{
						EXTRA_INFO_REC	cExtraInfoRec;
						cExtraInfoRec.ClearRecord(); // RFUEL-3708
						cExtraInfoRec.info.sLoyalId[0] = '1';//boolean just to know that loyalty card swiped
						cExtraInfoRec.info.lIndexNumber = lTrsNumber; 
						long lRtc = IndexOperation(EXTRA_INFO_FILE,REC_INSERT, &cExtraInfoRec);
						str.Format("CServerMain::SetAttendantTrs Update extra info with loyalty card lRtc = %ld trsNumber  = %ld ",lRtc,lTrsNumber);
						retCode = ChangeTrsToNotOnOffer(cTrs,lTerminalNumber,lPumpNumber);
					}
					else
					{
						long  lRtc = DeleteFromPaidTrsQDX(cTrs);
						if(!(lRtc))
						{
							str.Format("CServerMain::SetAttendantTrs Delete trs num %ld from paid QDX",cTrs.m_lNumber);
							
						}
						else
						{
							str.Format("CServerMain::SetAttendantTrs Can't Delete trs num %ld from paid QDX",cTrs.m_lNumber);
						}						
					}

					m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);						
				}
				break;
			
				case STATE_NOT_ON_OFFER: 
				case STATE_FORCE_RELEASE: 
				{
					if(bIfPaidQDX)
						UpdatePaidTrsQDX(cTrs,FALSE);
					
					else
					{
						retCode = ChangeTrsToNotOnOffer(cTrs,lTerminalNumber,lPumpNumber);				
					}
				}
				
				break;
				case STATE_ON_OFFER:
				{
					if(bIfPaidQDX)
						UpdatePaidTrsQDX(cTrs,TRUE);
					
					else
					{
						if(cTrs.GetStatus() == UNPAID)
						{
							if(cTrs.GetOnOffer() == 0)
							{																				
								if ((GetRegion() == REGION_UK) && (!IsAllowedMultiPosOwnersOfPumpTrs())) //4.0.23.501 78146
								{
									//pump currently on offer at another pos.
									if(m_cPumpArray[lPumpNumber-1].AnyTrsOnOffer(cTrs))				
										retCode = GCI_ONE_OF_PUMP_TRS_ON_OFFER;
								}
							
								if(retCode == GCI_OK)
								{
									CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

									if(LOG_DETAIL_FLOW_CONTROL)
									{
										CString str;
										str.Format("Pump - %02ld trs=%ld was offered to POS %ld",lPumpNumber, cTrs.m_lNumber, lTerminalNumber); 
										m_cLogger.LogMsg(str);
									}


									cTrs.SetOnOffer(lTerminalNumber);												
									// M.L 8/5/98 Lock PumpArray in large scope 
									CentralUpdateTrs(lPumpNumber,cTrs.m_lNumber,&cTrs,FALSE);
									
									retCode = GCI_OK;
								}
							}
							else if(cTrs.GetOnOffer() == lTerminalNumber)
							{
								retCode = GCI_OK;
							}
							else
							{
								retCode = GCI_TRS_LOCKED;
							}
						}
						else if(cTrs.GetStatus() == ACCEPTED)
						{
							if(cTrs.GetOnOffer() == lPumpNumber)
								retCode = GCI_OK;
							else
								retCode = GCI_TRS_LOCKED;
						}	
						else 
							retCode = GCI_TRS_NOT_FOR_SALE; // NULL_TRS, IN_PROGRESS, PAID, INCOMPLETE
					}
				}
				break;
				case STATE_ACCEPTED:
				{
					if(cTrs.GetStatus() == UNPAID)
					{
						if(LOG_DETAIL_FLOW_CONTROL)
						{
							CString str;
							str.Format("Pump - %02ld trs=%ld was accepted by POS %ld, it offer by =%ld",lPumpNumber, cTrs.m_lNumber, lTerminalNumber, cTrs.GetOnOffer()); 
							m_cLogger.LogMsg(str);
						}

						if(cTrs.GetOnOffer() == lTerminalNumber)
						{	
							CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

							cTrs.SetStatus(ACCEPTED);
							CentralUpdateTrs(lPumpNumber,cTrs.m_lNumber,&cTrs,FALSE);										
							
							retCode = GCI_OK;
						}
						else if(cTrs.GetOnOffer() == 0)
							retCode = GCI_TRS_NOT_RESERVED;
						else
							retCode = GCI_TRS_LOCKED;
					}
					else if(cTrs.GetStatus() == ACCEPTED)
					{
						if(cTrs.GetOnOffer() == lTerminalNumber) // second try 
							retCode = GCI_OK;
						else if(cTrs.GetOnOffer() == 0)
							retCode = GCI_TRS_NOT_RESERVED;
						else
							retCode = GCI_TRS_LOCKED;
					}	
					else 
						retCode = GCI_TRS_NOT_FOR_SALE; // NULL_TRS, IN_PROGRESS, PAID, INCOMPLETE
				}
				break;
				case STATE_PAID:
				{
					
					if((cTrs.GetStatus() == ACCEPTED) ||  //4.0.5.0
						((lFlags & TRS_FORCE_PAID) && (cTrs.GetOnOffer() == lTerminalNumber)))  // Force paid ooffer trs
					{							
						if(LOG_BASIC_FLOW_CONTROL)
						{
							sMsg.Format("Paid attendant transaction=%.5s !!!!!!" , cCardData.CardSaleAll.data.sTranNbr);
							_LOGMSG.LogMsg(sMsg);
						}
						InsertToPaidQDX(cTrs);

						retCode = PaidAttendantTrs(lPumpNumber,lFlags, &cCardData , &cTrs);
					} // accepted end
					else if(cTrs.GetStatus() == UNPAID)
					{
						if(cTrs.GetOnOffer())
						{
							if(cTrs.GetOnOffer() == lTerminalNumber)
							{
								retCode = GCI_TRS_NOT_ACCEPTED;
							}
							else
							{
								retCode = GCI_TRS_LOCKED;
							}
						} 											
						else
							retCode = GCI_TRS_NOT_RESERVED;
					}	
					else 
						retCode = GCI_TRS_NOT_FOR_SALE; // NULL_TRS, IN_PROGRESS, PAID, INCOMPLETE				
				}
				break; // 4.0.5.0
				case STATE_FORCE_PAID:
				{
					long lRtc = 0;

					if(cTrs.GetOnOffer() == lTerminalNumber)
					{							
						if(LOG_BASIC_FLOW_CONTROL)
						{
							sMsg.Format(" Force Paid attendant transaction=%.5s !!!!!!" , cCardData.CardSaleAll.data.sTranNbr);
							_LOGMSG.LogMsg(sMsg);
						}
						retCode = PaidAttendantTrs(lPumpNumber,lFlags, &cCardData , &cTrs);						

					} // accepted end
					else if(cTrs.GetStatus() == UNPAID)
					{
						if(cTrs.GetOnOffer())
						{
							if(cTrs.GetOnOffer() == lTerminalNumber)
							{
								retCode = GCI_TRS_NOT_ACCEPTED;
							}
							else
							{
								retCode = GCI_TRS_LOCKED;
							}
						} 											
						else
							retCode = GCI_TRS_NOT_RESERVED;						
					}	
					else 
						retCode = GCI_TRS_NOT_FOR_SALE; // NULL_TRS, IN_PROGRESS, PAID, INCOMPLETE
				}
				break;
				case STATE_SUPRESS_TIMOUT:
					break;
				default: 
					retCode = GCI_UNKNOWN_TRS_STATE;
					break;
			}
		}
	}
	else
		retCode =  GCI_TRS_MISMATCH;

	return retCode;
}

/******************************************************************************
 Description:	Paid Attendant transaction 	
 Returns:      	operation RetCode
 Parameters:   	long lPumpNumber, long lFlags, CARD_SALE_ALL2 *pInfo, CPumpTransact *pcTrs
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			29/5/2002   14:55		Start
******************************************************************************/
GCIRetCode CServerMain::PaidAttendantTrs(long lPumpNumber, long lFlags, CARD_SALE_ALL3 *pInfo, CPumpTransact *pcTrs)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	EXTRA_INFO_REC		cExtraInfoRec;
	PAY_AT_PUMP_INFO	 PAPInfo;
	CString strTmp;
	OLA_STAT ola;
	long lVal = 0 , lSeqNumber = 0;
	long lRetCode = 0;	
	GCIRetCode retCode = GCI_OK;
	CPumpTransact cTmpTrs = *pcTrs;
	

	if (lFlags & TRS_IGNOR_OLA)
	{
		cTmpTrs.m_lStatus = PAID;
		long lRtc =  CentralUpdateTrs(lPumpNumber,cTmpTrs.m_lNumber,&cTmpTrs,FALSE);							
		
		//4.0.3.49

		m_cSQLExtraInfoFile.DeleteRecord(&cTmpTrs);

		//4.0.3.49	
	}
	else
	{
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		memset(&ola,0,sizeof(OLA_STAT));
		m_cPumpArray[lPumpNumber - 1].GetOlaStat(&ola);

		if( OLA_STATE(ola.m_byState) == OLA_NONE ) 		
		{																		
			memset(&ola,0,sizeof(OLA_STAT));
			
			if( lFlags & CHARGE_ATTEND_TRS)
				ola.m_byState = SESSION_CAPTURE | OLA_REQUEST_TO_SEND;
			else
				ola.m_byState = SESSION_SALE | OLA_REQUEST_TO_SEND;
			m_cPumpArray[lPumpNumber - 1].SetOlaStat(&ola);
											
			pcTrs->m_nLinkFlags = TRS_LINK_OLA_NUMBER;
			long lRtc =  CentralUpdateTrs(lPumpNumber,pcTrs->m_lNumber,pcTrs,FALSE);							

			memset(&PAPInfo,' ',sizeof(PAY_AT_PUMP_INFO));

			pInfo->CardSaleAll.data.sTranType = CD_TYPE_ATTENDANT;
			l2a0(pcTrs->m_lLinkNumber ,pInfo->CardSaleAll.data.sTranNbr , sizeof(pInfo->CardSaleAll.data.sTranNbr));	
			
			PAPInfo.CardSaleInfo.cardData = pInfo->CardSaleAll.data;
			PAPInfo.CardSaleInfo.extraData = pInfo->CardSaleAll.extData;
			PAPInfo.CardSaleExtraData2 = pInfo->extData2;

			PAPInfo.CardSaleExtraData3 = pInfo->extData3;   //4.0.5.17
			
			cTmpTrs.SetLink(TRS_LINK_ATTEND,0);
			cExtraInfoRec.info.lIndexNumber = cTmpTrs.m_lNumber;
			lRtc = TrsLinkOperation(REC_READ , &cTmpTrs, &cExtraInfoRec);

			if (lRtc)
			{
				CString strTmp;
				strTmp.Format("Fail !!! Read  Attend record=%ld form ExtaInfo Rtc=%d" , cTmpTrs.m_lNumber , lRtc); 																	
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp,LOG_LEVEL_1);	 //4.0.23.500							
			}
			else							
			{
				memcpy(PAPInfo.CardSaleExtraData2.sAttendantID , cExtraInfoRec.info.sAttendantID ,sizeof(PAPInfo.CardSaleExtraData2.sAttendantID));
				memcpy(PAPInfo.CardSaleExtraData2.sAttendantName , cExtraInfoRec.info.sAttendantName ,sizeof(PAPInfo.CardSaleExtraData2.sAttendantName));
				memcpy(PAPInfo.CardSaleInfo.cardData.sFullVehicleId ,  cExtraInfoRec.info.sFullVehicleId , sizeof(PAPInfo.CardSaleInfo.cardData.sFullVehicleId));
			}
		
			// in session capture update the total transaction.
			if ( SESSION_TYPE(ola.m_byState) == SESSION_CAPTURE )
			{
				BYTE sTmpValue[11] = {0};								
				l2a0(cTmpTrs.m_lRoundedValue, sTmpValue , 10);
				memcpy(PAPInfo.CardSaleInfo.extraData.sTotalAmt , &sTmpValue[5] ,sizeof(PAPInfo.CardSaleInfo.extraData.sTotalAmt));
				memcpy(PAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb , sTmpValue ,sizeof(PAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb));
			}
			
			m_cPumpArray[lPumpNumber-1].SetPAPInfo(&PAPInfo);	

			SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);


			{
				CString strTmp;
				strTmp.Format("Attendant start, paid=%.5s", PAPInfo.CardSaleInfo.cardData.sTranNbr ); 																	
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
			}
		}
		else if((( SESSION_TYPE(ola.m_byState) == SESSION_CAPTURE )||( SESSION_TYPE(ola.m_byState) == SESSION_SALE )) && (OLA_STATE(ola.m_byState) == OLA_WAIT_FOR_MORE_INFO))
		{
			m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PAPInfo);
			{				
				strTmp.Format("Attendant Need more param, paid=%.5s", PAPInfo.CardSaleInfo.cardData.sTranNbr );
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
			}

			memcpy(pInfo->CardSaleAll.data.sTranNbr, PAPInfo.CardSaleInfo.cardData.sTranNbr, sizeof(pInfo->CardSaleAll.data.sTranNbr));
			memset(&PAPInfo,' ',sizeof(PAY_AT_PUMP_INFO));
			
			PAPInfo.CardSaleInfo.cardData = pInfo->CardSaleAll.data;
			PAPInfo.CardSaleInfo.extraData = pInfo->CardSaleAll.extData;
			PAPInfo.CardSaleExtraData2 = pInfo->extData2;
			PAPInfo.CardSaleExtraData3 = pInfo->extData3;   //4.0.5.17


			ola.m_byState = OLA_NEW_STATE(ola.m_byState,OLA_REQUEST_TO_SEND_MORE);

			m_cPumpArray[lPumpNumber-1].SetOlaStat(&ola);
			m_cPumpArray[lPumpNumber-1].SetPAPInfo(&PAPInfo);

			SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);


			{				
				strTmp.Format("Attendant Need more param1 , paid=%.5s", PAPInfo.CardSaleInfo.cardData.sTranNbr );
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
			}
		}
		else
		{
			retCode =  GCI_PUMP_ALREADY_HAVE_IN_PROGRESS_TRS;
		}
	}		
	
	return (retCode);
}

GCIRetCode  CServerMain::UpdateAttendantSale(long lPumpNumber, long lTrsNumber, long lState, long lFlags, BSTR sData, long *plRetVal)
{
	CString				strTmp;
	GCIRetCode			retCode = GCI_OK;	
	TAG_OLA_REC10       cTagOlaRec10; //4.0.11.502  //4.0.22.70 TD 74387
	RECEIPT_INFO		cReceiptInfo;
	PAY_AT_PUMP_INFO	cPAPInfo;
	CPumpTransact		cTrs;
	ITEMS_INFO          cItemInfo; 
	LONG				lItemIndex;
	int					iLen = 0;
	BOOL				bNoFuelInTicket = TRUE;
	BYTE				byIndex=0;  //4.0.10.50
	CString				str;
	BOOL				bRet;
	
	BYTE sTmpTrack2[TRACK_2_DATA_SIZE];//4.0.9.503 to save the track2 before the change
	//using for the gpi reprint 
	long lOlaRecordSize= (lFlags & TRS_OLA_THREE_REC) ? sizeof(TAG_OLA_REC6_EX): sizeof(TAG_OLA_REC4_EX);  //4.0.5.15 

	if(lFlags & TRS_INCLUDE_ZONE)
		lOlaRecordSize = sizeof(TAG_OLA_REC10); //4.0.22.70 TD 74387

	BYTE sTmp[sizeof(TAG_OLA_REC10)  + 2]; //4.0.22.70 TD 74387

	memset(sTmp , 0 , sizeof(sTmp));					//4.0.22.70 TD 74387
	memset(&cPAPInfo , ' ' , sizeof(PAY_AT_PUMP_INFO));	//4.0.21.0 68079
	memset(&cReceiptInfo, ' ' , sizeof(RECEIPT_INFO));  //4.0.21.0 68079

	memset(&cTagOlaRec10,' ',sizeof(cTagOlaRec10));     //4.0.22.70 TD 74387


	//4.0.14.500
	if (m_bUseXmlBuffer)
	{
		char sXmlBuff[MAX_XML_BUF_LEN];
		memset(&sXmlBuff,0,sizeof(sXmlBuff));						 //4.0.22.70 TD 74387
		iLen = Bstr2Buffer(sData,(char *)sXmlBuff,MAX_XML_BUF_LEN ); //4.0.22.70 TD 74387
		//Convert to struct
		bRet = m_cXmlConvertorEx.ConvertFromXmlToStruct(sXmlBuff,&cTagOlaRec10); //4.0.22.70 TD 74387
		if (!bRet)
			_LOGMSG.LogMsg("XmlProblem: UpdateAttendantSale, ConvertFromXmlToStruct",LOG_LEVEL_1);
	}
	else
	{
		if (lFlags & TRS_INCLUDE_ITEMS)
		{
			BOOL bExtraItemRec = FALSE;
			lOlaRecordSize= (lFlags & TRS_OLA_THREE_REC) ? sizeof(TAG_OLA_REC6_EX): sizeof(TAG_OLA_REC4_EX);  

			//4.0.5.27
			if ((lFlags & TRS_OLA_THREE_REC) && (lFlags &TRS_WITH_EXTRA_ITEM))
			{
				lOlaRecordSize = sizeof(TAG_OLA_REC7_EX);
				bExtraItemRec = TRUE;
			}
			//4.0.11.502
			if ((lFlags & TRS_INCLUDE_ZONE) && (lFlags &TRS_WITH_EXTRA_ITEM))
			{
				lOlaRecordSize = sizeof(TAG_OLA_REC10); //4.0.22.70 TD 74387
				bExtraItemRec = TRUE;
			}


			iLen = Bstr2Buffer(sData,(char *)sTmp,lOlaRecordSize ); // 4.0.5.15

			if (lFlags & TRS_OLA_THREE_REC) 
			{
				memcpy(&cTagOlaRec10,sTmp, lOlaRecordSize);  //4.0.22.70 TD 74387
				l2a(lPumpNumber ,cTagOlaRec10.tagTrs.sPump,sizeof(cTagOlaRec10.tagTrs.sPump)); //4.0.14.510 //4.0.22.70 TD 74387
			}
			else
			{
				TAG_OLA_REC4_EX cTagOlaRec4;
				memcpy(&cTagOlaRec4,sTmp, lOlaRecordSize);
				cTagOlaRec10.cardData =		cTagOlaRec4.cardData;      //4.0.22.70 TD 74387
				cTagOlaRec10.extraData =		cTagOlaRec4.extraData; //4.0.22.70 TD 74387
				cTagOlaRec10.extraData2 =	cTagOlaRec4.extraData2;    //4.0.22.70 TD 74387
				cTagOlaRec10.Items = cTagOlaRec4.Items;                //4.0.22.70 TD 74387
			}
		}	
		else
		{
			CARD_SALE_ALL3    cCardSaleAll3;
			lOlaRecordSize= (lFlags & TRS_OLA_THREE_REC) ? sizeof(CARD_SALE_ALL3): sizeof(CARD_SALE_ALL2);  //4.0.5.15 
			//4.0.11.502
			if ((lFlags & TRS_INCLUDE_ZONE) && (lFlags &TRS_WITH_EXTRA_ITEM))
			{
				lOlaRecordSize = sizeof(TAG_OLA_REC10);  //4.0.22.70 TD 74387
			}

			try   //4.0.11.410
			{
				iLen = Bstr2Buffer(sData,(char *)sTmp,lOlaRecordSize);
				memcpy(&cCardSaleAll3,sTmp,min(lOlaRecordSize,sizeof(cCardSaleAll3))); //4.0.22.70 TD 74387 to be on the safe side...

				cTagOlaRec10.cardData =cCardSaleAll3.CardSaleAll.data;
				cTagOlaRec10.extraData =cCardSaleAll3.CardSaleAll.extData;
				cTagOlaRec10.extraData2 = cCardSaleAll3.extData2;
							
				if (lFlags & TRS_OLA_THREE_REC)    // 4.0.5.15
					cTagOlaRec10.extraData3 = cCardSaleAll3.extData3; //4.0.22.70 TD 74387
			}
			catch(...)
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{		
					CString str;
					str.Format("Pump=%ld ,exception detect while  parse input BSTR  iLen=%d , buffer size=%ld  ",lPumpNumber ,iLen,lOlaRecordSize);
					m_cLogger.LogMsg(str,LOG_LEVEL_1);			
				}
				
				iLen = 0;
			}
		}
	}
						
	if (iLen)
	{
		//4.0.21.0 68079
		long lRtc;
		//4.0.22.70 TD 74387 - begin
		cPAPInfo.CardSaleInfo.cardData  = cTagOlaRec10.cardData;
		cPAPInfo.CardSaleInfo.extraData = cTagOlaRec10.extraData;
		cPAPInfo.CardSaleExtraData2	    = cTagOlaRec10.extraData2;
		//4.0.22.70 TD 74387 - end

		//rttttt temp!!!!!!!! remove after fix
		if (cTagOlaRec10.extraData3.sPreSetlimitType < 48)	 //4.0.22.70 TD 74387			
			cTagOlaRec10.extraData3.sPreSetlimitType += 48;


		if (lFlags & TRS_OLA_THREE_REC)    // 4.0.5.15
		{
			cPAPInfo.CardSaleExtraData3  = cTagOlaRec10.extraData3;	//4.0.21.0 68079 //4.0.22.70 TD 74387
			cPAPInfo.CardSaleExtraData4  = cTagOlaRec10.extraData4; //4.0.22.70 TD 74387

			//4.0.5.17
			if (!GetOLAFlags(cPAPInfo.CardSaleExtraData2.sFlags ,FL_PAP_AS_THIRD_REC))
			{			
				long lTmp = a2l(cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags))  + FL_PAP_AS_THIRD_REC;
				l2a(lTmp ,cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags)); 				

				if(LOG_BASIC_FLOW_CONTROL)
				{		
					CString str;
					str.Format("CServerMain::UpdateAttendantSale  signed flags three record Pump=%ld ",lPumpNumber);
					m_cLogger.LogMsg(str);			
				}
			}
//4.0.21.0 68079
	
		}
			

		//4.0.1.34	
		// Get trs information if exist.
		//4.0.11.500 take the trs by number 
		if(lFlags & TRS_PAK_PAYMENT_CARD)
			bNoFuelInTicket =m_cPumpArray[lPumpNumber - 1].GetTrsByNumber(lTrsNumber, &cTrs);
		else
		{
			long lNumOfTrs = 0;//4.0.22.501 - merged from 4.0.22.12 TD 73062
			bNoFuelInTicket =m_cPumpArray[lPumpNumber - 1].GetAttendTrs(lFlags, &cTrs, lNumOfTrs); //4.0.22.12
		}


		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			str.Format("UpdateAttendantSale, trs=%ld, not Found trs Fuel =%d ", cTrs.m_lNumber,bNoFuelInTicket);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);			
		}

		
		if (lFlags & TRS_INCLUDE_ITEMS)
		{//4.0.21.0 68079
			CItemsFile			  cTmpItemsFile;
			BAP_ALL_DATA_STRUCTS  cItemRec;   //4.0.5.27

			memset(&cItemRec , ' ' , sizeof(cItemRec));

			lItemIndex = NewItemsIndex();

			l2a(lItemIndex ,cPAPInfo.CardSaleExtraData2.sItemsLinkIndex, sizeof(cPAPInfo.CardSaleExtraData2.sItemsLinkIndex));					

			cItemRec.cBAPReceiptItem = cTagOlaRec10.Items; //4.0.22.70 TD 74387
				
			if (lFlags & TRS_WITH_EXTRA_ITEM)  //4.0.5.27
			{//4.0.21.0 68079
				cItemRec.cBAPReceiptItem2 = cTagOlaRec10.Items2; //4.0.22.70 TD 74387
				if (!GetOLAFlags(cPAPInfo.CardSaleExtraData2.sFlags ,FL_EXTRA_ITEM_REC))
				{
					long lTmp = a2l(cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags))  + FL_EXTRA_ITEM_REC;
					l2a(lTmp ,cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags)); 
				}
	
				//4.0.5.28
			}
			
			if(LOG_BASIC_FLOW_CONTROL) //4.0.5.383
			{
				strTmp.Format("Add new Items Record Index=%ld" , lItemIndex ); 																	
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);								
			}
			//4.0.21.0 68079
			cTmpItemsFile.SplitBAPRecorToItems(lItemIndex,cItemRec,cItemInfo);
			lRtc = IndexOperation(ITEMS_FILE,REC_INSERT,&cItemInfo); //4.0.10.50
			if(LOG_BASIC_FLOW_CONTROL)	//4.0.21.0 68079
			{
				CString strMsg;
				if (lRtc)
				{
					strMsg.Format("Fail !!!! insert Index=%ld to Items file" , cItemInfo.ItemRec.lIndexNumber);
					_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strMsg);
				}
				else
				{
					strMsg.Format("Insert Index=%ld to Items file succeeded" , cItemInfo.ItemRec.lIndexNumber);
					_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strMsg);
				}
			}

			/********** Support Zones from CL: ************/

			if (lFlags & TRS_INCLUDE_ZONE) //4.0.15.780 75376 //4.0.23.20
			{
				//4.0.11.502
				//insert the zone into file 22
				PS::RECEIPT_EXTRA_INFO_REC	cReceiptExtraRec;
				memset(&cReceiptExtraRec, ' ', sizeof(PS::RECEIPT_EXTRA_INFO_REC));
				cReceiptExtraRec.info.lIndexNumber = a2l(cPAPInfo.CardSaleInfo.cardData.sTranNbr, sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr));//cTrs.m_lNumber;4.0.15.780 75376

				memcpy(cReceiptExtraRec.info.sFiler2043, cTagOlaRec10.ReceiptExtraInfo.sFiler2043, sizeof(cTagOlaRec10.ReceiptExtraInfo.sFiler2043));	//4.0.22.70 TD 74387
				lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_INSERT, cReceiptExtraRec);
				//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_INSERT,&cReceiptExtraRec);

				//4.0.23.20 77298
				if (lRtc == ERR_EXISTS)
				{
					lRtc = 0;
					lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_UPDATE, cReceiptExtraRec);
					//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_UPDATE,&cReceiptExtraRec);

					if (LOG_DETAIL_FLOW_CONTROL)
					{
						CString strTmp;   //4.  //4.0.5.40 
						strTmp.Format("UpdateAttendantSale, Update receipt extra data information Index=%ld , Rtc=%ld", cReceiptExtraRec.info.lIndexNumber, lRtc);
						_LOGMSG.LogMsg(strTmp);
					}
				}

				long lTmp = a2l(cPAPInfo.CardSaleExtraData2.sFlags, sizeof(cPAPInfo.CardSaleExtraData2.sFlags));

				CString strTmp;
				if (lRtc)
				{
					strTmp.Format("UpdateAttendantSale, Fail !!!! Update zones for index=%ld , Rtc=%ld", cReceiptExtraRec.info.lIndexNumber, lRtc);
					_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, strTmp);

					// in spite the record not save continue, paid process.  	
				}
				else //succsess
				{
					if (!(lTmp & FL_EXTRA_RECEIPT_REC)) //4.0.23.20 77298
						lTmp |= FL_EXTRA_RECEIPT_REC;
					l2a(lTmp, cPAPInfo.CardSaleExtraData2.sFlags, sizeof(cPAPInfo.CardSaleExtraData2.sFlags));

					strTmp.Format("Update zones succeeded for index=%ld , Rtc=%ld", cReceiptExtraRec.info.lIndexNumber, lRtc);
					_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, strTmp);
				}
			}
		}
	
		if(!(lFlags & TRS_PAK_PAYMENT_CARD))//4.0.11.509
		{
			if (cPAPInfo.CardSaleInfo.cardData.sTranType != CD_TYPE_ATTENDANT)
				cPAPInfo.CardSaleInfo.cardData.sTranType = CD_TYPE_ATTENDANT;
		}

		//4.0.1.34
		if (cTrs.m_lPump <=0)
		{
			cTrs.m_lPump =lPumpNumber;

			if (bNoFuelInTicket)   //4.0.5.41
			{
				cTrs.m_lNumber = a2l(cTagOlaRec10.Items.sInvoiceNumber,sizeof(cTagOlaRec10.Items.sInvoiceNumber)); //4.0.22.70 TD 74387
			}
			
		}
		//4.0.1.34
		if (ChrAll((char*)cPAPInfo.CardSaleInfo.cardData.sTranNbr, sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr)))
		{
			l2a(cTrs.m_lNumber,cPAPInfo.CardSaleInfo.cardData.sTranNbr,sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr)); 
		}

		if (lFlags  & TRS_OVERWRITE_TRS)   // 4.0.5.48
		{
			//4.0.22.70 TD 74387	- begin 	
			cTrs.m_lRawVolume = a2l(cTagOlaRec10.tagTrs.sRawVolume,sizeof(cTagOlaRec10.tagTrs.sRawVolume));
			cTrs.m_lRoundedVolume = a2l(cTagOlaRec10.tagTrs.sRoundedVolume,sizeof(cTagOlaRec10.tagTrs.sRoundedVolume));
			cTrs.m_lRoundedValue = a2l(cTagOlaRec10.tagTrs.sRoundedValue,sizeof(cTagOlaRec10.tagTrs.sRoundedValue));	
			//4.0.22.70 TD 74387 - end
		}
													  
		//4.0.9.503
		if(cTrs.m_lResExt == RES_EXT_ATTENDANT)//4.0.11.503 TD 19197
		{//4.0.21.0 68079
			memset(cPAPInfo.CardSaleInfo.cardData.sTrack2Data,' ',sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data));
			memcpy(cPAPInfo.CardSaleInfo.cardData.sTrack2Data,
					cPAPInfo.CardSaleExtraData2.sAttendantID,
					sizeof(cPAPInfo.CardSaleExtraData2.sAttendantID));
			ConvertOlaToReceipt(&cTrs, &cPAPInfo, &cReceiptInfo,0);
			_LOGMSG.LogMsg("CServerMain::UpdateAttendantSale Att Trs save to QDX the att ID");			
		}
		else
		{
			CComBSTR			sAccountNumber("");//4.0.9.503
			CComBSTR			sShortCardNumber("");//4.0.9.503
			CComBSTR			sTrack1("");//4.0.9.503
			CComBSTR			sRetData;//4.0.9.503
			CARD_SALE_ALL3		cTmpCardSaleData;//4.0.9.503
			long				lSessionType = 0 ;//4.0.25.0
			BOOL                bDoNotUseXmlBuffer = TRUE;//4.0.25.0 - internally work with structure since GetCardInfo can return xml according to Pumpsrv init by CL.
			
			CComBSTR sBstrTrack2;
			//4.0.21.0 68079
			MultiByteToWideChar(CP_ACP,0,(char*)cPAPInfo.CardSaleInfo.cardData.sTrack2Data,sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data),sBstrTrack2.m_str,0);	
			memset(&cTmpCardSaleData,' ',sizeof(CARD_SALE_ALL3));
			
			lRtc = GetCardInfo(sAccountNumber,
												sTrack1,
												sBstrTrack2,
												sShortCardNumber,
												&sRetData,
												0,
												&lSessionType,
												0,
												bDoNotUseXmlBuffer);//4.0.25.0

			int len = WideCharToMultiByte(CP_ACP,0,sRetData,-1,(char*)&cTmpCardSaleData,sizeof(cTmpCardSaleData),NULL,NULL);//4.0.25.0
			if (!len)
			{
				str.Format("UpdateAttendantSale, WideCharToMultiByte failed"); 
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str,LOG_LEVEL_1); //4.0.25.0
			}
			memcpy(cPAPInfo.CardSaleInfo.cardData.sAccountNumber,cTmpCardSaleData.CardSaleAll.data.sAccountNumber,sizeof(cPAPInfo.CardSaleInfo.cardData.sAccountNumber));
			memcpy(sTmpTrack2,cPAPInfo.CardSaleInfo.cardData.sTrack2Data,sizeof(sTmpTrack2));//4.0.9.503
			m_cProtectedDataHandler.GenerateIndex(&cPAPInfo);							//4.0.22.13	TD 72716
			m_cBaseReceipt->ConvertOlaToReceipt(&cTrs, &cPAPInfo, &cReceiptInfo,0);//4.0.9.503

			memcpy(cPAPInfo.CardSaleInfo.cardData.sTrack2Data, cReceiptInfo.cReceipt1.Index.sTrack2 , sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data));
		}
		
		CReceiptInfo ReceiptInfo;
		_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(&cTrs, &cPAPInfo, ReceiptInfo);//4.0.9.503
		long lRtc1 = CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

		if (lRtc)
		{
			CString strTmp;
			strTmp.Format("Fail !!!! Update Attendant Receipt Record Index=%ld , Rtc=%ld" , lItemIndex ,lRtc );
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
		}

		if (!lRtc)
		{
			
			//4.0.1.0
			cPAPInfo.CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;


			//4.0.1.32	//4.0.21.0	68079
			if(!cTrs.m_lRoundedValue)
			{
				long  lTotalSale= ConvertStringsToLong(cPAPInfo.CardSaleInfo.extraData.sTotalAmt,
					sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt),cPAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb,sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb));

				cTrs.m_lRoundedValue =  lTotalSale;
				Convertl2Str2((lTotalSale/10),cPAPInfo.CardSaleInfo.extraData.sFuelAmt_Msb,sizeof(cPAPInfo.CardSaleInfo.extraData.sFuelAmt_Msb) , cPAPInfo.CardSaleInfo.extraData.sFuelAmt, sizeof(cPAPInfo.CardSaleInfo.extraData.sFuelAmt));
			}

			if (ChrAll((char*)cPAPInfo.CardSaleInfo.cardData.sTranNbr,sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr)))
			{
				memcpy(cPAPInfo.CardSaleInfo.cardData.sTranNbr , &cTagOlaRec10.Items.sInvoiceNumber[5],sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr)); 	//4.0.22.70 TD 74387
			}
			//copy the original track2 for the reprint from pos pump
			memcpy(cPAPInfo.CardSaleInfo.cardData.sTrack2Data,sTmpTrack2,sizeof(sTmpTrack2));
			if(cTrs.m_lResExt == RES_EXT_ATTENDANT)//4.0.11.503 TD 19197
			{
	 			memset(cPAPInfo.CardSaleInfo.cardData.sTrack2Data,' ',sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data));
				memcpy(cPAPInfo.CardSaleInfo.cardData.sTrack2Data,
						cPAPInfo.CardSaleExtraData2.sAttendantID,
						sizeof(cPAPInfo.CardSaleExtraData2.sAttendantID));			
			}

			m_cMemPumpArray[lPumpNumber -1 ].SetMemPumpInfo(&cPAPInfo ,&cTrs , &cReceiptInfo , byIndex); //4.0.10.50 //4.0.30.0 270322
			
			if(LOG_BASIC_FLOW_CONTROL)
			{											
				CString str;
				str.Format("SetMemPumpInfo step 12 Update only decline Code Pump=%ld item", lPumpNumber);
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
			}

			//4.0.0.82
		}

		
		//if flag is on then insert the data into OLA
		//so vp will pull it
		if(lFlags & TRS_PAK_PAYMENT_CARD)
		{//4.0.21.0 68079
			cPAPInfo.CardSaleInfo.lIndexNumber = NewOLAIndex();
			
			cTrs.SetLink(TRS_LINK_OLA_NUMBER, cPAPInfo.CardSaleInfo.lIndexNumber);		
			 			
			cPAPInfo.CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;
			
			if(LOG_BASIC_FLOW_CONTROL)
			{
				long lamount = a2l(cPAPInfo.CardSaleInfo.extraData.sTotalAmt, sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt));
				long lFuelAmt = a2l(cPAPInfo.CardSaleInfo.extraData.sFuelAmt, sizeof(cPAPInfo.CardSaleInfo.extraData.sFuelAmt));

				str.Format("UpdateAttendantSale, Added PAK  record to  OLA Index Number  - %ld (Trs %ld) total = %ld ",cPAPInfo.CardSaleInfo.lIndexNumber,cTrs.m_lNumber,cTrs.m_lRoundedValue,cTrs.m_lRoundedVolume); 
				_LOGMSG.LogMsg(str);
				str.Format("UpdateAttendantSale, The Total Values are TotalAmt = %ld , FuelAmt =  %ld",lamount,lFuelAmt); 
				_LOGMSG.LogMsg(str);
			}
			str.Format("UpdateAttendantSale ,sTranType=%c ",cPAPInfo.CardSaleInfo.cardData.sTranType);
			_LOGMSG.LogMsg(str);

			l2a0(cTrs.m_lRoundedValue,cPAPInfo.CardSaleInfo.extraData.sTotalAmt,sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt));//4.0.11.507
			l2a0(cTrs.m_lRoundedValue/10,cPAPInfo.CardSaleInfo.extraData.sFuelAmt,sizeof(cPAPInfo.CardSaleInfo.extraData.sFuelAmt));//4.0.11.507
			
			cTrs.m_lStatus = (TrsStatus)PAID;
			lRtc = TrsLinkOperationEx(REC_INSERT,&cTrs, &cPAPInfo);
			//4.0.18.501				
		}
	}
	else
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			str.Format("UpdateAttendantSale, Error buffer length=%d",iLen);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);			
		}
	}

	return (retCode);
}
void CServerMain::UpdateDebitTimeOutParmeters(long lPumpNumber, OLA_STAT *pOla, CXMLInterface *pXMLInterface)
{
	int  iPosition = 0;
	char sVal[MAX_FIELD_VAL]; 
	
	if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
	{
					
		iPosition = TIME_OUT_BEBIT_SESSION;
	}
	else
	{
		iPosition = TIME_OUT_USUAL_SESSION;
	}

	memset(sVal,' ',sizeof(sVal));
	pXMLInterface->GetXmlField((char*)ATT_MESSAGE_TIME_OUT,sVal);

	if ((pXMLInterface->GetXmlByteField(ATT_PIN_PAD_ACTION) != ' ' && 
		 pXMLInterface->GetXmlByteField(ATT_PIN_PAD_ACTION) != 0) &&
		 (!ChrAll((char *)sVal,sizeof(sVal))))
	{
		long lTimeOut = pXMLInterface->GetXmlLongField(ATT_MESSAGE_TIME_OUT);
				
		GetLocalTime(&m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].cSysTime);
		m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].lInterval = lTimeOut;

		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			str.Format("Debit Timeout information, Timeout=%ld, position=%d ", lTimeOut, iPosition);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);			
		}
	}
	else
		m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].lInterval = 0;
}

void CServerMain::UpdateDebitTimeOutParmeters(long lPumpNumber, OLA_STAT *pOla, CARD_SALE_ALL3 *pCardSaleAll2)
{
	int  iPosition = 0;
	
	if ((SESSION_TYPE(pOla->m_byState) == SESSION_SHIFT_DEBIT) ||
		(SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT))
	{
					
		iPosition = TIME_OUT_BEBIT_SESSION;
	}
	else
	{
		iPosition = TIME_OUT_USUAL_SESSION;
	}

	if ((pCardSaleAll2->extData2.sPinPadAction != ' ') &&
		 (!ChrAll((char *)pCardSaleAll2->extData2.sMessageTimeOut,sizeof(pCardSaleAll2->extData2.sMessageTimeOut))))
	{
		long lTimeOut = a2l(pCardSaleAll2->extData2.sMessageTimeOut ,sizeof(pCardSaleAll2->extData2.sMessageTimeOut));
				
		GetLocalTime(&m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].cSysTime);
		m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].lInterval = lTimeOut;

		if(LOG_BASIC_FLOW_CONTROL)
		{		
			CString str;
			str.Format("Debit Timeout information, Timeout=%ld, position=%d ", lTimeOut, iPosition);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);			
		}
	}
	else
		m_cOLADebitMessageTimeout[iPosition][lPumpNumber - 1].lInterval = 0;
}

/******************************************************************************
 Description:	Create connection to AlarmSrv  	
 Returns:      	None
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			13/8/2002   9:36		Start
******************************************************************************/
void CServerMain::ConnectToAlarmSrv()
{	
	DWORD dwTmp = 0;
	long lRetCode;
	
	m_dwAlarmSrvActive = 0; //4.0.3.16
	m_cParam.LoadParam("GeneralParam","AlarmSrvActive",&m_dwAlarmSrvActive,0,TRUE);

	if(m_dwAlarmSrvActive)
	{	
		lRetCode = m_cAlarm.InitAlarmSrv(m_dwAlarmSrvActive);
		if(lRetCode == 0)
		{
			if(LOG_BASIC_FLOW_CONTROL)		
				m_cLogger.LogMsg("PumpSrv is running with AlarmSrv");
		}
		else
		{
			if(LOG_BASIC_FLOW_CONTROL)		
				m_cLogger.LogMsg("PumpSrv fail to init AlarmSrv");
		}
	}
}

/******************************************************************************
 Description:	Close Connection  Encrypt Dll 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			04/07/2005   9:53		Start
 Gena									Update 4.0.20.501 TD 60236
******************************************************************************/
void CServerMain::CloseConnectionToEncryptDll()
{
	m_cProtectedDataHandler.CleanUp();		
	m_cLogger.LogMsg("ProtectedDataHandler released successfully.");	
}


/******************************************************************************
 Description:	Close Connection  To AlarmSrv 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			13/8/2002   9:53		Start
******************************************************************************/
void CServerMain::CloseConnectionToAlarmSrv()
{
	if (m_dwAlarmSrvActive)
	{
		m_cAlarm.CloseConnectToAlarmSrv();
		m_cLogger.LogMsg("AlarmSrv released successfully.");
	}
}
/******************************************************************************
 Description:	Send Alarm to AlarmSrv 	
 Returns:      	
 Parameters:   	long lPumpNumber, BOOL bErrorRep, long lError, BOOL bWarningRep, long lWarning, BOOL bDeviceRep, long lDevice, long lDeviceCode, BOOL bMiscRep, long lMisc, long *pVal
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			11/9/2002   16:29		Start
******************************************************************************/
long CServerMain::WriteToAlarmSrv(long lPumpNumber, BOOL bErrorRep, long lError, BOOL bWarningRep, long lWarning, BOOL bDeviceRep, long lDevice, long lDeviceCode, BOOL bMiscRep, long lMisc, long *pVal)
{
	long lAlarmNumber =0;
	long lCategory =0 ;
	long lSubCategory= 0;
	long lAlarmStatus =0 ;
	long lAlarmDevice =0;
	long lAlarmValue=0;
	long lFlags	=0;
	long lRetVal = 0;
	GCIRetCode retCode =GCI_OK;


	if (m_dwAlarmSrvActive)
	{
		CAlarmConvert cAlarmConvert;

		if (bErrorRep)
			cAlarmConvert.ConvertErrorToAlarmCode(lPumpNumber, lDevice, bErrorRep, lError, lCategory, lSubCategory, lAlarmNumber, lAlarmDevice, lAlarmStatus);
		else if (bWarningRep)
			cAlarmConvert.ConvertWarningToAlarmCode(lPumpNumber, lDevice ,lWarning , lCategory, lSubCategory, lAlarmNumber,lAlarmDevice, lAlarmStatus);		
		//4.0.3.14
		else if ((_ALARM_SRV.m_lAlarmSrvActive) && (lDevice == TERMINAL_CARD_READER)  &&  (lMisc == PUMP_MSG_CARD_ENCRYPTION))
		{
			if (bMiscRep)
				lAlarmStatus = TRUE;
			else
				lAlarmStatus = FALSE;			

			lCategory = CATEGORY_PUMP;
			lSubCategory  = SUB_TERMINAL_ENCRYPTION;
			lAlarmNumber  = CARD_READER_NON_SPECIFIC_ERROR;			
			lAlarmDevice = lPumpNumber;
			lAlarmValue = 0 ;
			lFlags=0;
		}
		//4.0.3.14
		lRetVal = m_cAlarm.AddSendMessage(lCategory, lSubCategory, lAlarmNumber, lAlarmDevice,lAlarmStatus, lAlarmValue ,lFlags);

		if (lRetVal)
			retCode = GCI_FAILED_IO;

		if(pVal != NULL)
			*pVal = retCode;			

	}	
	return lRetVal;
}

//4.0.0.78
/******************************************************************************
 Description:	Updates the shift number in the Pump array and to the qdx in 
				cases we are not backuping pump stat information.
 Returns:      	void  	
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			20/8/2002   11:34		Start
******************************************************************************/
void CServerMain::UpdateShiftAtPumps()
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	//saving to qdx only if not set by configuration.

	if( !(m_cPumpFile.m_lBackUpFlags & MS_PUMP_STATE_INFO_DEFAULT_CONFIG) )
	{
	
		for (int p=0;p< m_lLastValidPump;p++)   //4.0.0.79
		{
			m_cPumpArray[p].SetShiftNumber( m_cCurrentShift.dwFormalShiftNumber );
			SQLPumpSrvFile.SaveInfo(p + 1, __FUNCTION__, __LINE__, TRUE);	

		}
	}
}

//4.0.0.84
BOOL CServerMain::IsNotAllowedWaitingPrePay()
{
	return ((m_dwSetWaitingPrePayToTimeOutFlags)?TRUE:FALSE);
}

//4.0.1.31
void CServerMain::UpdateUnbalancedPrePay(long lPumpNumber)
{
	PRE_PAY_INFO	cTmpPrePayinfo;
	long lVal = 0;
	long lRetVal=0;
	long lRtc = 0;
	CPumpTransact trs;

	lRtc = TrsLinkOperation(REC_READ,&trs,&cTmpPrePayinfo);

	//3.2.1.50
	GetServiceFeeInfo(lPumpNumber,SERVICE_TYPE_PREPAY,0,NULL,GET_FEE_BY_TRANSACTION_TYPE,&lVal,&lRetVal); //marik12345		

	//4.0.3.29 Changed from != to <, so if we fueled for more
	//than we paid for, we do not count it as an unbalanced prepay
	if (( (trs.m_lRoundedValue + lVal) < cTmpPrePayinfo.lMaxValue) && (!lRtc))
		m_cPumpArray[lPumpNumber - 1].IncreaseUnBalancePrePayCounter();

	if (!lRtc) // 
	{
		//Save latest PrePay info
		m_cPumpArray[lPumpNumber - 1].SetLatestPrePaySyncNumber(cTmpPrePayinfo.lSyncNumber);
		m_cPumpArray[lPumpNumber - 1].SetLatestPrePayPosNumber(cTmpPrePayinfo.lPOSNumber);							
	}

	return;
}

#ifdef USE_XML_PRICE_CHANGE  //4.0.0.86
void CServerMain::XMLPriceChange(char *cFileName)
{
	CXMLInterface	m_cXmlAlert;
	CXMLPointers m_pNodeRootPtr;
	CXMLPointers m_pNodeCurrentPtr;
	CXMLPointers m_pNodeCurrentPtr1;
	CXMLPointers m_pNode1DocRoot;
	CXMLPointers m_pNode2DocRoot;
	CXMLPointers m_pNode3DocRoot;
	CXMLPointers m_pNode4DocRoot;

	CString strGradeTable;
	char sNumber[8];
	DWORD dwTmp = 0;	
	BOOL bRetCode= FALSE;
	double dbTmp = 0;

	_variant_t vResult1,vResult2;
	BSTR bstr_Tmp = SysAllocString(L" ");

	CString strMessges;
	CString str;
	SYSTEMTIME curSysTime;
	SZ_TAG_SYSTEMTIME szTagTime;
	GetLocalTime(&curSysTime);	
	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));

	strMessges.Format("Find XML File to Process File=%s" ,cFileName);
	m_cLogger.LogMsg(strMessges);


	try
	{
		m_cXmlAlert.InitDoc();	
		bRetCode = m_cXmlAlert.LoadFile(cFileName);
		
		_LOGMSG.LogMsg(strMessges);		
		
		// Build node list
		bRetCode = m_cXmlAlert.selectNodes("FuelGradeMaintenance" ,&m_pNodeRootPtr,NULL);
		

		while (m_cXmlAlert.GetNextItem(m_pNodeRootPtr,m_pNodeCurrentPtr))
		{
			//4.0.1.32 - Support two types of XML		 
			m_cXmlAlert.GetChildNodesList(&m_pNodeCurrentPtr,&m_pNodeCurrentPtr1);
			// search list FGTDetail		
			while (m_cXmlAlert.GetNextItem(m_pNodeCurrentPtr1,m_pNode1DocRoot))
			{			
				strGradeTable = "Grades\\Grade";
				memset(sNumber,0,sizeof(sNumber));						

				bRetCode = m_cXmlAlert.SelectSingleElementNode("FuelGradeID" ,&m_pNode2DocRoot, &m_pNode1DocRoot);

				m_pNode2DocRoot.m_pMSElement->get_text(&bstr_Tmp); 		
				str = 	bstr_Tmp;
				
				// select Grade table
				sprintf_s(sNumber, _countof(sNumber),"%02d",atoi(str));
				strGradeTable += sNumber;			
				strMessges  = strGradeTable;   // 11111

				
				bRetCode = m_cXmlAlert.SelectSingleElementNode("DescriptionID" ,&m_pNode2DocRoot, &m_pNode1DocRoot);
				m_pNode2DocRoot.m_pMSElement->get_text(&bstr_Tmp); 		

				str = 	bstr_Tmp;	

				strMessges  +=  "        "; 
				strMessges  += str;   

				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "FullName",(char *)((LPCTSTR)str));
						
				bRetCode = m_cXmlAlert.SelectSingleElementNode("FuelGradeActiveFlag" ,&m_pNode2DocRoot, &m_pNode1DocRoot);
				vResult2 = m_cXmlAlert.GetAttribute("value",&m_pNode2DocRoot);

				if (!strcmp(((const char *)((_bstr_t) vResult2)),"Yes"))	//4.0.25.80	TD 142857
				{
					strMessges  +=  ",";   // 11111
					strMessges  += "Valid" ;   // 11111

					dwTmp = 1;
				}				
				else
				{
					strMessges  +=  ",";   // 11111
					strMessges  += "not Valid" ;   // 11111

					dwTmp = 0;
				}
											
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "ValidEntry",(DWORD)dwTmp);
			
				bRetCode = m_cXmlAlert.SelectSingleElementNode("FGTData" ,&m_pNode3DocRoot, &m_pNode1DocRoot);
				bRetCode = m_cXmlAlert.SelectSingleElementNode("RegularSellPrice" ,&m_pNode4DocRoot, &m_pNode3DocRoot);
 		 				
				m_pNode4DocRoot.m_pMSElement->get_text(&bstr_Tmp);
				str = 	bstr_Tmp;

				strMessges  +=  ",Price="; 
				strMessges  += str ;  

				_LOGMSG.LogMsg(strMessges);

				//4.0.1.32 Add by Yaron to support 1.22 prices and not 1220.
				dbTmp = atof(str);
				dwTmp = (DWORD)(dbTmp * 1000);
				long lGrade = a2l((unsigned char*)sNumber, sizeof(sNumber));

				//4.0.8.503
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "Old_PriceCash_FullService",dwTmp,TRUE,0,0,0,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "New_PriceCash_FullService",dwTmp,0,0,0,TRUE);
				SetGradePriceToArray(lGrade, dwTmp, 1);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "Old_PriceCredit_FullService",dwTmp,0,0,0,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "New_PriceCredit_FullService",dwTmp,0,0,0,TRUE);
				SetGradePriceToArray(lGrade, dwTmp, 3);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "Old_PriceCash_SelfService",dwTmp,0,0,0,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "New_PriceCash_SelfService",dwTmp,0,0,0,TRUE);
				SetGradePriceToArray(lGrade, dwTmp, 0);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "Old_PriceCredit_SelfService",dwTmp,0,0,0,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)strGradeTable), "New_PriceCredit_SelfService",dwTmp,0,0,0,TRUE);
				SetGradePriceToArray(lGrade, dwTmp, 2);
				//4.0.8.503		 
				
				DWORD dwLowestPrice;
				dwLowestPrice = GetGradePriceFromArray(lGrade, PRICE_PROTECTION_LOWEST_PRICE);
				if (dwTmp < dwLowestPrice)
				{
					m_cParam.SaveParam((char *)((LPCTSTR)str), "Day_Lowest_Price", dwTmp, TRUE, 0, 0, 0, TRUE);
					SetGradePriceToArray(lGrade, dwTmp, PRICE_PROTECTION_LOWEST_PRICE);
				}

			}
		}
		SystemTime2Tag(&curSysTime,&szTagTime.sTime);	

		m_cPriceChangeFlags.SavedFlags(szTagTime , 0); //4.0.8.501
		
		m_cXmlAlert.CloseDoc();

	}
	catch(...)
	{
		m_cLogger.LogMsg("Problem to parse Xml file abort....",LOG_LEVEL_1);
	}			
	
	int iDelFlags = _unlink(cFileName );
	str.Format("Delete XML File=%s" ,cFileName );
	m_cLogger.LogMsg(str);

	//4.0.2.15  BSTR allocated in all cases, so we must free in all cases
	SysFreeString(bstr_Tmp);
}


long CServerMain::CheckForIncomingNewPrice()
{
	long lRetCode = 1;
	SERVER_INFO sInfo;

	m_cServerInfo.GetInfo(sInfo);
	if (sInfo.bRequiredShiftProcess || sInfo.bRequiredPriceChange || sInfo.bRequiredModeProcess 
			|| sInfo.byRequiredMaintenanceProcess )
	{
			lRetCode = 1;
	}
//4.0.8.500
	else
	{
		int iDelFlags = 0;
		char tmpStr[MAX_FILE_PATH];
		memset(tmpStr,0,sizeof(tmpStr));
		m_cParam.LoadParam("Paths\\Long","XML_PriceChangeFile",tmpStr,sizeof(tmpStr),"C:\\office\\PumpSrv\\FuelPriceChange.xml",TRUE);

		if (CheckExistFile(tmpStr))
		{					
			XMLPriceChange(tmpStr);
		}
	}


	return lRetCode;
}


long CServerMain::CheckExistFile(char *sFile)
{
	long lRetCode;
	WIN32_FIND_DATA FindFileData;		
	HANDLE hFile = FindFirstFile(sFile,&FindFileData);
	if(hFile == INVALID_HANDLE_VALUE)
		lRetCode = 0;
	else
	{
		FindClose(hFile);
		lRetCode = 1;
	}		
	
	return lRetCode;
}
#endif //4.0.0.86

BOOL CServerMain::IsNeedToClearTrsOnIdlePump()
{
	return ((m_dwClearTrsOnIdlePump)?TRUE:FALSE);
}

//4.0.12.515
BOOL CServerMain::IsRollbackOnPriceChangeFailure()
{
	return ((m_dwRollbackOnPriceChangeFailure)?TRUE:FALSE);
}


/******************************************************************************
 Description:	Creates the PricePoles registry table 	
 Returns:      	void
 
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			2/10/2002   12:49		Start  4.0.1.32
******************************************************************************/
void CServerMain::LoadPricePolesTable()
{
	int i;
	DWORD dwTmp = 0;
	char sTmpStr[MAX_FIELD_VAL];

	memset(sTmpStr,0,sizeof(sTmpStr));
	
	for(i = 1; i <= MAX_PRICE_DISPLAYS; i++)
	{
		CString str("PricePoles\\PricePole");
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		m_cParam.LoadParam((char *)((LPCTSTR)str),"Type", sTmpStr, sizeof(sTmpStr) ,"FutureMedia",TRUE);

		m_cParam.LoadParam((char *)((LPCTSTR)str), "CommPort",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "DeviceAddress",&dwTmp,(DWORD)0,TRUE);
		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);

		CString tmpStr;
		for(int p = 1; p<= MAX_PANELS_PER_DEVICE; p++)
		{
			tmpStr = str;
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",p);
			tmpStr += "\\Panel";
			tmpStr += sNumber;

			
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "Grade",&dwTmp,(DWORD)p,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "PriceLevel",&dwTmp,(DWORD)0,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ServiceMode",&dwTmp,(DWORD)0,TRUE);
			m_cParam.LoadParam((char *)((LPCTSTR)tmpStr), "ValidEntry",&dwTmp,(DWORD)0,TRUE);			
		}
	}
}
/******************************************************************************
 Description:	Create taxes table entries 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			7/10/2002   18:28		Start
******************************************************************************/
void CServerMain::LoadTaxesTable()
{
	int i =0;
	DWORD dwTmp = 0;
	char sTmpStr[MAX_FIELD_VAL];
	BOOL bCreateNewTable = FALSE;

	if (m_cParam.LoadParam("Taxes\\Tax01", "TaxID",&dwTmp,(DWORD)0,FALSE))
		bCreateNewTable = TRUE;

	for(i = 1; i <= MAX_TAXES; i++)
	{
		CString str("Taxes\\Tax");
		
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;
		
		m_cParam.LoadParam((char *)((LPCTSTR)str),"TaxName", sTmpStr, sizeof(sTmpStr) ,"",TRUE);

		m_cParam.LoadParam((char *)((LPCTSTR)str), "TaxID",&dwTmp,(DWORD)i,TRUE);
		if (bCreateNewTable)
		{
			CString strGrade("Grades\\Grade");
			DWORD	dwInfo = 0;
			strGrade +=sNumber;
				
			m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "TaxRate",&dwInfo,(DWORD)0,FALSE);
			m_cParam.LoadParam((char *)((LPCTSTR)str), "TaxRate",&dwTmp,(DWORD)dwInfo,TRUE);
		}
		else			
			m_cParam.LoadParam((char *)((LPCTSTR)str), "TaxRate",&dwTmp,(DWORD)0,TRUE);

		m_cParam.LoadParam((char *)((LPCTSTR)str), "ValidEntry",&dwTmp,(DWORD)0,TRUE);
	}

}


//4.0.1.32
DWORD CServerMain::GetWetstockMaintFlag()
{
	return m_dwWetStockMaint;
}

/******************************************************************************
 Description: Handle a failue in the Delivery Single Tank Process.

 Returns:      	None.

 Parameters:    bRes - a boolean value of a failure. Will be always false.
                nErrorRetrieved - the error which describes the failure.
				iErrorCode - value of nErrorRetrieved.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		20/10/2008   13:34		Start 4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::PrepareDeliverySingleTankProcessFailure(BOOL & bRes, int & nErrorRetrieved, const int iErrorCode)
{
	bRes = FALSE;
	nErrorRetrieved = iErrorCode;

}

/******************************************************************************
 Description: This function resets the Delivery Single Tank Process (readings).
              It is called when the reading status is DES_SINGLE_TANK_UNLOCK, and changes it to
              DES_SINGLE_TANK_IDLE (+ reset other flags of the process).

			  In addition: if process type is PD_SINGLE_TANK_START - it is changed to 
			  PD_SINGLE_TANK_END, and if process type is PD_SINGLE_TANK_END - it is
			  changed to PD_SINGLE_TANK_NONE.

 Returns:      	OK / NOT OK.

 Parameters:    lTankNumber - the tank number.
                nErrorRetrieved - the error which describes the failure.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		20/10/2008   13:34		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::ResetDeliverySingleTankProcess(const long lTankNumber, int & nErrorRetrieved) 
{
	BOOL bRes = TRUE; //Default value unless an error occurred
	long lPrevProcessType = m_cServerInfo.GetDeliveryEmulationSingleTankProcessType(lTankNumber);
	long lProcessStopped  = m_cServerInfo.GetDeliveryEmulationSingleTankProcessStopped(lTankNumber);

	m_cCommonFunction.ResetDeliveryEmulationSingleTankReadingInData(lTankNumber);
	m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_UNLOCK to DES_SINGLE_TANK_IDLE");

	if ((lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_TIMEOUT))
	//An idle as a result of a process cancellation:
	{
		m_cLogger.LogMsg("Delivery : Process stopped due to Force Release");
		if(lPrevProcessType == PD_SINGLE_TANK_START)
		{
			m_cServerInfo.SetDeliveryEmulationSingleTankProcessType(lTankNumber, PD_SINGLE_TANK_NONE);
		    m_cLogger.LogMsg("Delivery: Changed the Emulation Process Type flag for single tank from PD_SINGLE_TANK_START to PD_SINGLE_TANK_NONE");
		}
		m_cServerInfo.SetDeliveryEmulationSingleTankProcessStopped(lTankNumber, SINGLE_TANK_PROCESS_NOT_STOPPED);

	}

	else
	{
		//Transferring m_cInfo.byDeliveryEmulationSingleTankProcess to the appropriate state, and firing the appropriate event:
	    if(lPrevProcessType == PD_SINGLE_TANK_START) //End of Start
		{
			m_cServerInfo.SetDeliveryEmulationSingleTankProcessType(lTankNumber, PD_SINGLE_TANK_END);
		    m_cLogger.LogMsg("Delivery: Changed the Emulation Process Type flag for single tank from PD_SINGLE_TANK_START to PD_SINGLE_TANK_END");
		}
	
	    else if(lPrevProcessType == PD_SINGLE_TANK_END) //End of end
		{
			m_cServerInfo.SetDeliveryEmulationSingleTankProcessType(lTankNumber, PD_SINGLE_TANK_NONE);
		    m_cLogger.LogMsg("Delivery: Changed the Emulation Process Type flag for single tank from PD_SINGLE_TANK_END to PD_SINGLE_TANK_NONE");
							
		    if(m_cTankArray[lTankNumber-1].GetVPNotification()) //Event to VP. Use new flag (per tank), but must be reseted here:
			{
				m_cEventManager.AddEvent(CTRL_EVENT_DELIVERY_REPORT,0);
			    m_cTankArray[lTankNumber-1].SetVPNotification(FALSE);
			}
		}
	
	    else //Case of m_cInfo.byDeliveryEmulationSingleTankProcess == PD_SINGLE_TANK_NONE
		{
			m_cLogger.LogMsg("Delivery Emulation Single Tank Process: m_cInfo.byDeliveryEmulationSingleTankProcess has an invalid value when m_cInfo.byDeliveryEmulationSingleTankStatus == DES_SINGLE_TANK_UNLOCK");
		    PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
		}
	}

	return bRes;
}

/******************************************************************************
 Description: This function is called when the reading status of Delivery Single Tank Process is
              DES_SINGLE_TANK_IDLE. It checks if the Delivery Single Tank Process (readings) can 
			  start. If yes: it resets and inits parameters when needed, and changes the reading
			  status to DES_SINGLE_TANK_START_LOCK. Otherwise: return an error message (for 
			  example: START_AFTER_START).

 Returns:      	OK / NOT OK

 Parameters:    Tank Number, Tank Reference, LockConnectedPumps, 
                byDeliveryEmulationProcessFlag - the needed process type. 
                nErrorRetrieved - the error which describes the failure.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		22/10/2008   13:34		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::StartDeliverySingleTankProcess(const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps, const BYTE byDeliveryEmulationProcessFlag, int & nErrorRetrieved)
{
	BOOL bRes = TRUE; //Default value unless an error occurred
	long lPrevProcessType = m_cServerInfo.GetDeliveryEmulationSingleTankProcessType(lTankNumber);

	if ((lPrevProcessType == PD_SINGLE_TANK_NONE) || (lPrevProcessType == PD_SINGLE_TANK_END))
	{
		if (byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_START)
		{
			if (lPrevProcessType == PD_SINGLE_TANK_NONE)
			{
				//Reset Data From Previous Process (ONLY AY START!!):
				//Check whether to reset only here (garbage in the INI), or also at END of END
				//(the part that is possible), and after success of end (the other part)*?*?.
				m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Reset flags before START");
	            m_cCommonFunction.ResetDeliveryEmulationSingleTankProcessData(lTankNumber);
				
	            //Save parsed data both to memory and ini file (for recovery): 
                m_cTankArray[lTankNumber-1].SetDeliveryReference(lTankReference);
                m_cTankArray[lTankNumber-1].SaveDeliveryReference();
	            m_cTankArray[lTankNumber-1].SetLockConnectedPumps(bLockConnectedPumps);
	            m_cTankArray[lTankNumber-1].SaveLockConnectedPumps();
				
				m_cServerInfo.SetDeliveryEmulationSingleTankProcessType(lTankNumber, PD_SINGLE_TANK_START);

			}

			else // lPrevProcessType == PD_SINGLE_TANK_END (=> we already finished start process successfully, and now try to start again)
			{
				if (m_cServerInfo.GetDeliveryEmulationSingleTankSuccess(lTankNumber) == DESF_SINGLE_TANK_DONE)
				{
					m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Trying to initiate a Start Delivery Process although start process has already been successfully finished");
					PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_DELIVERY_START_AFTER_START);
				}
				else //This is never possible, since the change to DESF_SINGLE_TANK_NOT_DONE is done only at END. So is it needed *?*?
				{
					m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Trying to initiate a Start Delivery Process although Fuel expected End Delivery");
					PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_DELIVERY_WAITING_FOR_END);
				}
			}
		}
		else if (byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_END)
		{
			if (lPrevProcessType == PD_SINGLE_TANK_NONE) 
			{
				
				if (m_cServerInfo.GetDeliveryEmulationSingleTankSuccess(lTankNumber) == DESF_SINGLE_TANK_DONE)
				{
					m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Trying to initiate a End Delivery Process although it has already been successfully finished");
					PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_DELIVERY_END_AFTER_END);
				}
				else //DESF_SINGLE_TANK_NOT_DONE (in the other statuses - we are not suppose to get here)
				{
					m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Trying to initiate a End Delivery Process without starting it");
					PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_DELIVERY_END_WITHOUT_START);

				}

			}
			else //Trying to end a delivery when END is expected
			{
				///Reset Data From Previous Process (in a case we already got an END command:-> it means that we can and should reset this info):
				m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Reset flags before END");
				m_cCommonFunction.ResetDeliveryEmulationSingleTankReadingOutData(lTankNumber);
				
				//Save parsed data both to memory and ini file (for recovery):
	            m_cTankArray[lTankNumber-1].SetLockConnectedPumps(bLockConnectedPumps);
	            m_cTankArray[lTankNumber-1].SaveLockConnectedPumps();

			}

		}
		if(bRes)
		{
			m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_START_LOCK);
			m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_IDLE to DES_SINGLE_TANK_START_LOCK");
		}

	}
	else //Shouldn't happen, based on the assumption that this function is called only at DES_SINGLE_TANK_IDLE
		//(=> DES_SINGLE_TANK_IDLE + PD_SINGLE_TANK_START shouldn't happen).
	{
		//Trying to initiate a Start Delivery Process although one has already been initiated:
		m_cLogger.LogMsg("Delivery Emulation Single Tank Process: Trying to initiate a Start Delivery Process although one has already been initiated");
	    PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
	}

	return bRes;
}

/******************************************************************************
 Description: This function ends the Delivery Single Tank Process (readings).
              It is called when the reading status is DES_SINGLE_TANK_WAIT_TANK_READING, 
			  and changes it to DES_SINGLE_TANK_UNLOCK.

 Returns:      	OK / NOT OK.

 Parameters:    lTankNumber - the tank number.
                nErrorRetrieved - the error which describes the failure.
				bReadingEndedSuccessfully - whether the reading ended successfully. 
				(meantime: for future use, no one calls this fanction with FALSE).

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		22/10/2008   13:34		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::EndDeliverySingleTankProcess(const long lTankNumber, int & nErrorRetrieved, BOOL bReadingEndedSuccessfully)
{
	BOOL bRes = TRUE; //Default value unless an error occurred
	long lPrevProcessType = m_cServerInfo.GetDeliveryEmulationSingleTankProcessType(lTankNumber);

	m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_UNLOCK);
	m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_WAIT_TANK_READING to DES_SINGLE_TANK_UNLOCK");

	if(lPrevProcessType == PD_SINGLE_TANK_START)
	{
		if(bReadingEndedSuccessfully != TRUE)
        //The Start Delivery process has failed, we expect another one now:
		{
			//Check how to notify BOS (whether using SetDeliveryEmulationSingleTankProcessStopped, SetDeliveryEmulationSingleTankSuccess, or both)
			//Or: to cacnel all this - and leave it for the TimeOut *?*?
			m_cServerInfo.SetDeliveryEmulationSingleTankSuccess(lTankNumber, DESF_SINGLE_TANK_FAILURE);
			m_cLogger.LogMsg("Delivery Emulation Single Tank Process: The Start Delivery process has failed, you should perform it again. Process type will be returned back to PD_SINGLE_TANK_NONE", LOG_LEVEL_1);
			m_cServerInfo.SetDeliveryEmulationProcessType(PD_SINGLE_TANK_NONE);
		}
	}
	else if (lPrevProcessType == PD_SINGLE_TANK_END)
	{
		if(bReadingEndedSuccessfully != TRUE)
		//The End Delivery process has failed, we expect another one now:
		{
			//Check how to notify BOS (whether using SetDeliveryEmulationSingleTankProcessStopped, SetDeliveryEmulationSingleTankSuccess, or both).
			//Or: to cacnel all this - and leave it for the TimeOut *?*?
			m_cServerInfo.SetDeliveryEmulationSingleTankSuccess(lTankNumber, DESF_SINGLE_TANK_FAILURE);
			m_cServerInfo.SetDeliveryEmulationProcessType(PD_SINGLE_TANK_START);
			m_cLogger.LogMsg("Delivery Emulation Single Tank Process: The End Delivery process has failed, you should perform it again. Process type will be returned back to PD_SINGLE_TANK_START", LOG_LEVEL_1);
		}
	}
	else //Case of m_cInfo.byDeliveryEmulationSingleTankProcess == PD_SINGLE_TANK_NONE
	{
		m_cLogger.LogMsg("Delivery Emulation Single Tank Process: m_cInfo.byDeliveryEmulationSingleTankProcess has an invalid value when m_cInfo.byDeliveryEmulationSingleTankStatus == DES_SINGLE_TANK_UNLOCK");
		PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
	}

	return bRes;
}

/******************************************************************************
 Description: Abort the Delivery Emulation Single Tank process.
              This function only sign the ABORT flag. The logic will be done in
			  "DoAutomaticEmulationDeliverySingleTank__".

			  *?*? If will remain only this: function can be canceled.
			  But made a function, for a future use.

 Returns:      	OK / NOT OK.
 Parameters:    Tank Number.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		04/11/2008   17:54		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::AbortDeliverySingleTankProcess(const long lTankNumber, int & nErrorRetrieved)
{
	BOOL bRes = TRUE; //Default value unless an error occurred

	m_cServerInfo.SetDeliveryEmulationSingleTankProcessStopped(lTankNumber, SINGLE_TANK_PROCESS_STOPPED_BY_ABORT);

	return bRes;

}

/******************************************************************************
 Description: Try to conduct the Delivery Emulation Single Tank two State Machines, by checking
              if they apply to the rules by which the states should switch. 
			  If so change the state machines and return true.
			  Else - do nothing and return false.

 Returns:      	OK / NOT OK.
 Parameters:    Tank Number, Tank Reference, whether to lock connected pumps,
                byDeliveryEmulationStatusFlag, byDeliveryEmulationProcessFlag - new state macines' values
				nErrorRetrieved - Returned Value.
				bReadingEndedSuccessfully - whether the reading ended successfully. 
				(meantime: for future use, no one calls this fanction with FALSE).

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		19/10/2008   17:34		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::HandleDeliverySingleTankProcess(const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps, const BYTE byDeliveryEmulationStatusFlag, const BYTE byDeliveryEmulationProcessFlag, int & nErrorRetrieved, BOOL bReadingEndedSuccessfully)
{
	BOOL bRes = TRUE; //Default value unless an error occurred
	long lPrevProcessStatus = m_cServerInfo.GetDeliveryEmulationSingleTankStatus(lTankNumber);
	long lProcessStopped    = m_cServerInfo.GetDeliveryEmulationSingleTankProcessStopped(lTankNumber);

	switch (byDeliveryEmulationStatusFlag)//checking what is the new value needed
	{
		case DES_SINGLE_TANK_IDLE: //Valid only when previous status is DES_SINGLE_TANK_UNLOCK
			if ((lPrevProcessStatus == DES_SINGLE_TANK_UNLOCK) || (((lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_TIMEOUT)) && (lPrevProcessStatus == DES_SINGLE_TANK_START_LOCK)))
			{
				bRes = ResetDeliverySingleTankProcess(lTankNumber, nErrorRetrieved);
			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;
			
		case DES_SINGLE_TANK_START_LOCK: //Valid only when previous status is DES_SINGLE_TANK_IDLE
			if (lPrevProcessStatus == DES_SINGLE_TANK_IDLE)
			{
				StartDeliverySingleTankProcess(lTankNumber, lTankReference, bLockConnectedPumps, byDeliveryEmulationProcessFlag, nErrorRetrieved);

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;

		case DES_SINGLE_TANK_WAIT_FOR_LOCK:
			if (lPrevProcessStatus == DES_SINGLE_TANK_START_LOCK)
			{
				m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_WAIT_FOR_LOCK);
				m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_START_LOCK to DES_SINGLE_TANK_WAIT_FOR_LOCK");

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;

        case DES_SINGLE_TANK_WAIT_TIMEOUT:
			if (lPrevProcessStatus == DES_SINGLE_TANK_WAIT_FOR_LOCK)
			{
				m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_WAIT_TIMEOUT);
				m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_WAIT_FOR_LOCK to DES_SINGLE_TANK_WAIT_TIMEOUT");

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;

		case DES_SINGLE_TANK_REQUEST_TANK_READING:
			//Two valid previous statuses: DES_SINGLE_TANK_START_LOCK - in case no lock is needed, DES_SINGLE_TANK_WAIT_TIMEOUT - in case a lock is needed:
			if ((lPrevProcessStatus == DES_SINGLE_TANK_START_LOCK) || (lPrevProcessStatus == DES_SINGLE_TANK_WAIT_TIMEOUT))
			{
				m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_REQUEST_TANK_READING);
				m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_WAIT_TIMEOUT to DES_SINGLE_TANK_REQUEST_TANK_READING");

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;

		case DES_SINGLE_TANK_WAIT_TANK_READING:
			if (lPrevProcessStatus == DES_SINGLE_TANK_REQUEST_TANK_READING)
			{
				m_cServerInfo.SetDeliveryEmulationSingleTankStatus(lTankNumber, DES_SINGLE_TANK_WAIT_TANK_READING);
				m_cLogger.LogMsg("Delivery: Changed the Emulation status flag for single tank from DES_SINGLE_TANK_REQUEST_TANK_READING to DES_SINGLE_TANK_WAIT_TANK_READING");

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;

		case DES_SINGLE_TANK_UNLOCK:
			if ((lPrevProcessStatus == DES_SINGLE_TANK_WAIT_TANK_READING) || (lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_ABORT) || (lProcessStopped == SINGLE_TANK_PROCESS_STOPPED_BY_TIMEOUT)) 
			{
				bRes = EndDeliverySingleTankProcess(lTankNumber, nErrorRetrieved, bReadingEndedSuccessfully);

			}
			else //State switching is invalid
			{
				PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
			break;
		default:
			{
				//byDeliveryEmulationStatusFlag has an invalid value:
			     m_cLogger.LogMsg("Delivery Emulation Single Tank Process: byDeliveryEmulationStatusFlag parameter received is invalid");
			     PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
			}
	}

	return bRes;
}

/******************************************************************************
 Description:	Setting the Delivery Emulation Single Tank Flags - conducting its 
                two State Machines (DeliveryEmulationSingleTankProcessType, DeliveryEmulationSingleTankStatus).

 Returns:      	OK / NOT OK.
 Parameters:    Tank Number, Tank Reference, whether to lock connected pumps,
                byDeliveryEmulationStatusFlag, byDeliveryEmulationProcessFlag - new state macines' values
				nErrorRetrieved - Returned Value.
				bReadingEndedSuccessfully - whether the reading ended successfully. 
				(meantime: for future use, no one calls this fanction with FALSE).

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shelly B		19/10/2008   11:34		Start 4.0.21.500 TD 66935
******************************************************************************/
BOOL CServerMain::SetDeliverySingleTankFlags(const long lTankNumber, const long lTankReference, const BOOL bLockConnectedPumps, const BYTE byDeliveryEmulationStatusFlag, const BYTE byDeliveryEmulationProcessFlag, int & nErrorRetrieved, BOOL bReadingEndedSuccessfully)
{

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	BOOL bRes = TRUE; //Default value unless an error occurred
	nErrorRetrieved = 0;

	if (byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_FORCE_RELEASE)//Abort process
	{
		bRes = AbortDeliverySingleTankProcess(lTankNumber, nErrorRetrieved);
	}
	else
	{
		if ((byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_NONE) || (byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_START) || (byDeliveryEmulationProcessFlag == PD_SINGLE_TANK_END))
			bRes = HandleDeliverySingleTankProcess(lTankNumber, lTankReference, bLockConnectedPumps, byDeliveryEmulationStatusFlag, byDeliveryEmulationProcessFlag, nErrorRetrieved, bReadingEndedSuccessfully);
		else
		{
			//byDeliveryEmulationProcessFlag has an invalid value:
			m_cLogger.LogMsg("Delivery Emulation Single Tank Process: byDeliveryEmulationProcessFlag parameter received is invalid ");
			PrepareDeliverySingleTankProcessFailure(bRes, nErrorRetrieved, GPI_NOT_VALID_IN_CURRENT_MODE);
		}
	}
	
	//Saving m_cInfo.byDeliveryEmulationStatus and m_cInfo.byDeliveryEmulationProcess in case they were changed
	if(bRes)
	{
		SQLPumpSrvFile.SaveServerInfo();
	}

	return bRes;
}

//Udi 4.0.5.24 
/******************************************************************************
 Description:	Setting the Delivery Emulation Flags - conducting its State Machine  
 Returns:      	
 Parameters:    BYTE byDeliveryEmulationStatusFlag, BYTE byDeliveryEmulationProcessFlag

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Udi F			08/02/2004   12:11		Start
******************************************************************************/
BOOL CServerMain::SetDeliveryFlags(BYTE byDeliveryEmulationStatusFlag, BYTE byDeliveryEmulationProcessFlag, int & nErrorRetrieved, BOOL bDeliveryEndedSuccessfully)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	BOOL bRes = TRUE; //Default value unless an error occurred

	nErrorRetrieved = 0;

	//This flag indicates if the Start/End event fired will indicate success or failure
	static BOOL bDeliveryEventFlag = TRUE ;

	if(PD_FORCE_RELEASE == byDeliveryEmulationProcessFlag)
	{
		//We requested to release the forecourt immediately 
		switch(m_cServerInfo.GetDeliveryEmulationStatus())
		{
			case DES_IDLE: //Do nothing - supposed to stay in this mode
				break;

			case DES_WAIT_TANK_READING: //Clearing the wet stock process

			_Module,m_cServerInfo.ClearTankReadingFlags();

			case DES_START_LOCK:    //No break
			case DES_WAIT_FOR_LOCK: //No break
			case DES_WAIT_TIMEOUT:  //No break
			case DES_UNLOCK:        //No break
			case DES_REQUEST_TANK_READING:  //4.0.15.501
				//Returning to the basic status so that we can start a process
				//all over again
				m_cServerInfo.SetDeliveryEmulationStatus(DES_IDLE);
				
				m_cLogger.LogMsg("Delivery : Process stopped due to Force Release");

				switch(m_cServerInfo.GetDeliveryEmulationProcessType())
				{
					case PD_NONE: //Do nothing - should stay in this status
						break;
					case PD_START:
						m_cServerInfo.SetDeliveryEmulationProcessType(PD_NONE);
						break;
					case PD_END:  //Do nothing - should stay in this status
						break;
					default:
						m_cLogger.LogMsg("Delivery: byDeliveryEmulationProcess Flag parameter received is invalid ");
						bRes = FALSE;
				}
				break;
			default:
				m_cLogger.LogMsg("Delivery: byDeliveryEmulationStatus Flag parameter received is invalid ",LOG_LEVEL_1);
				bRes = FALSE;
		}
	} 
	else
	{
		if(PD_NONE == byDeliveryEmulationProcessFlag || PD_START == byDeliveryEmulationProcessFlag || PD_END == byDeliveryEmulationProcessFlag)
		{
			//Checking if the Delivery Status state machine applies to the rules
			//by which the states should switch. If it does we'll change the state
			//and return true, else we'll do nothing and return false
			switch(byDeliveryEmulationStatusFlag)
			{
				case DES_IDLE:
					if(DES_UNLOCK == m_cServerInfo.GetDeliveryEmulationStatus())						
					{
						m_cServerInfo.SetDeliveryEmulationStatus(DES_IDLE);
						m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_UNLOCK to DES_IDLE ");
						//Transferring m_cInfo.byDeliveryEmulationProcess to the appropriate state and firing
						//the appropriate event

						if(PD_START == m_cServerInfo.GetDeliveryEmulationProcessType())
						{
							m_cServerInfo.SetDeliveryEmulationProcessType(PD_END);
							
							if(GetSupportDeliveryEmulation() == FALSE)		//4.0.20.52 (63602)
							{
								if(TRUE == bDeliveryEventFlag)
									SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_DELIVERY_START_ENDED);
								else
									SetCommand(CMD_GENERAL_SYSTEM_EVENT, 1, GCI_EVENT_DELIVERY_END_ENDED);
							}
						}
						else if(PD_END == m_cServerInfo.GetDeliveryEmulationProcessType())
						{
							m_cServerInfo.SetDeliveryEmulationProcessType(PD_NONE);
							if(GetSupportDeliveryEmulation() == FALSE)		//4.0.20.52 (63602)
								if(TRUE == bDeliveryEventFlag)
									SetCommand(CMD_GENERAL_SYSTEM_EVENT, 0, GCI_EVENT_DELIVERY_END_ENDED);

														
							if(m_bFoundDelivery)		//4.0.20.52 (62818)
							{		
								m_cEventManager.AddEvent(CTRL_EVENT_DELIVERY_REPORT,0);
								m_bFoundDelivery = FALSE;
							} 
						}
						else if(PD_NONE == m_cServerInfo.GetDeliveryEmulationProcessType())
						{//*?*? what's this case?
							m_cLogger.LogMsg("Delivery: The Start Delivery process has failed, you should perform it again."); 
							if(GetSupportDeliveryEmulation() == FALSE)		//4.0.20.52 (63602)
								if(FALSE == bDeliveryEventFlag)
									SetCommand(CMD_GENERAL_SYSTEM_EVENT, 1, GCI_EVENT_DELIVERY_START_ENDED);
						}
						//4.0.5.28 End
						else
						{
							//*?*? - isn't it the previous case?
							bRes = FALSE;
						}
					}
					else
					{
						bRes = FALSE;
					}
					break;

				case DES_START_LOCK:
					if((PD_NONE == m_cServerInfo.GetDeliveryEmulationProcessType()) || (PD_END == m_cServerInfo.GetDeliveryEmulationProcessType()))
					{
						if(DES_IDLE == m_cServerInfo.GetDeliveryEmulationStatus())
						{						
							//If the forecourt locking has now begun we'll transfer 
							if(PD_START == byDeliveryEmulationProcessFlag)
							{
								if(m_cServerInfo.GetDeliveryEmulationProcessType() != PD_NONE ) //Trying to start another delivery without ending the previous one
									
								{
									bRes = FALSE;
									nErrorRetrieved = DELIVERY_START_AFTER_START; 
								}
								else
								{
									m_cServerInfo.SetDeliveryEmulationProcessType(PD_START);
								}
							}
							else if(PD_END == byDeliveryEmulationProcessFlag)
							{
								if(m_cServerInfo.GetDeliveryEmulationProcessType() != PD_END)//Trying to end a delivery without starting it									
								{
									bRes = FALSE;
									nErrorRetrieved = DELIVERY_END_AFTER_END; 
								}
							}
							if(bRes)
							{
								m_cServerInfo.SetDeliveryEmulationStatus(DES_START_LOCK);
								m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_IDLE to DES_START_LOCK ");
							}
						}
						else
						{
							//State switching is invalid
							bRes = FALSE; 
						}
					}
					else
					{
						//Trying to initiate a Start Delivery Process although one has already
						//been initiated
						bRes = FALSE;
					}
					break;

				case DES_WAIT_FOR_LOCK:  
					if(DES_START_LOCK == m_cServerInfo.GetDeliveryEmulationStatus())
					{
						m_cServerInfo.SetDeliveryEmulationStatus(DES_WAIT_FOR_LOCK);
						m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_START_LOCK to DES_WAIT_FOR_LOCK ");
					}
					else
					{
						bRes = FALSE;
					}
					break;
				case DES_REQUEST_TANK_READING: //4.0.14.240
					{
						if ((DES_START_LOCK == m_cServerInfo.GetDeliveryEmulationStatus()) || (DES_WAIT_TIMEOUT == m_cServerInfo.GetDeliveryEmulationStatus()))
						{
							m_cServerInfo.SetDeliveryEmulationStatus(DES_REQUEST_TANK_READING);
							m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_START_LOCK or DES_WAIT_TIMEOUT to DES_REQUEST_TANK_READING ");
						}
						else
						{
						  bRes = FALSE;
						}
							break;
					}

				case DES_WAIT_TIMEOUT: 
					if(DES_WAIT_FOR_LOCK == m_cServerInfo.GetDeliveryEmulationStatus())  //4.0.14.250
					{
						m_cServerInfo.SetDeliveryEmulationStatus(DES_WAIT_TIMEOUT);
						m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_WAIT_FOR_LOCK to DES_WAIT_TIMEOUT ");
					}
					else
					{
						bRes = FALSE;
					}
					break;

				case DES_WAIT_TANK_READING:
					if(DES_REQUEST_TANK_READING == m_cServerInfo.GetDeliveryEmulationStatus()) //4.0.15.501
					{						
						m_cServerInfo.SetDeliveryEmulationStatus(DES_WAIT_TANK_READING);
						m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_WAIT_TIMEOUT to DES_WAIT_TANK_READING ");
					}
					else
					{
						bRes = FALSE;
					}
					break;

				case DES_UNLOCK:  
					if(DES_WAIT_TANK_READING == m_cServerInfo.GetDeliveryEmulationStatus())
					{
						m_cServerInfo.SetDeliveryEmulationStatus(DES_UNLOCK);

						//Sending an event the Start/End delivery process was finished successfully/unsuccessfully						
						if( PD_START == m_cServerInfo.GetDeliveryEmulationProcessType())
						{
							if(TRUE == bDeliveryEndedSuccessfully)
							{
								bDeliveryEventFlag = TRUE;

							}
							else
							{
								bDeliveryEventFlag = FALSE;
								//The Start Delivery process has failed, we expect another one now								
								m_cServerInfo.SetDeliveryEmulationProcessType(PD_NONE);
							}
						}						
						else if( PD_END ==  m_cServerInfo.GetDeliveryEmulationProcessType())
						{
							if(TRUE == bDeliveryEndedSuccessfully)
							{
								bDeliveryEventFlag = TRUE;
							}
							else
							{
								bDeliveryEventFlag = FALSE;
								//The End Delivery process has failed, we expect another one now
								m_cServerInfo.SetDeliveryEmulationProcessType(PD_START);
								m_cLogger.LogMsg("Delivery: The End Delivery process has failed, you should perform it again.");
							}
						}
						else
						{
							m_cLogger.LogMsg("Delivery: m_cInfo.byDeliveryEmulationProcess has an invalid value when m_cInfo.byDeliveryEmulationStatus == DES_UNLOCK ");
						}

						m_cLogger.LogMsg("Delivery: Changed the Emulation status flag from DES_WAIT_TANK_READING to DES_UNLOCK ");
					}
					else
					{
						bRes = FALSE;
					}
					break;

				default:
					m_cLogger.LogMsg("Delivery: byDeliveryEmulationStatusFlag parameter received is invalid ");
					bRes = FALSE;
			}
		}
		else
		{
			//byDeliveryEmulationProcessFlag has an invalid value
			m_cLogger.LogMsg("Delivery: byDeliveryEmulationProcess Flag parameter received is invalid ");
			bRes = FALSE;
		}
	}
	//Saving m_cInfo.byDeliveryEmulationStatus and m_cInfo.byDeliveryEmulationProcess in case they were changed
	if(bRes)
	{
		SQLPumpSrvFile.SaveServerInfo();
	}
	
	return bRes;
	
}

void CServerMain::UpdateBlenderCount()
{
	DWORD lUpdateMap1 = 0 , lUpdateMap2 = 0 , lMask = 1;

	for(int i = 0;i < m_lMaxValidGradeNumber;i++)//amram 4.0.10.502
	{
		if(m_cDevicesPerGrade[i].GetNumberOfBlenders())
		{
			m_cDevicesPerGrade[i].GetUpdateMaps(&lUpdateMap1 , &lUpdateMap2);

			for(int j = 0;j < MAX_PUMPS;j++)
			{
				if(lUpdateMap1 & lMask)
					m_cTerminalDevices[j].SetNumberOfBlenders(1);

				if(lUpdateMap2 & lMask)
					m_cTerminalDevices[j + MAX_PUMPS].SetNumberOfBlenders(1);

				lMask <<= 1;
			}
		}
	}
}


GCIRetCode CServerMain::UpdateCashAcceptorData(long lPumpNumber, long lDevice, long lSeqNum, long lFlags, BSTR CashSaleData)
{
	GCIRetCode retCode = GCI_OK;
	DWORD dwLastErr=0;
	long lRtc;		

	long p = lPumpNumber -1;		
	CPumpTransact trs;
	char byTmpBuffer[sizeof(TAG_CASH_SALE_DATA) +2];
	TAG_CASH_SALE_DATA cTagCashSaleData;	
	PRE_PAY_REC		PrePayRec;	
	EXTRA_INFO_REC	ExtraInfoRec;
	CString sMsg;
	
	memset(&ExtraInfoRec , 0 , sizeof(EXTRA_INFO_REC));
	memset(&PrePayRec , 0, sizeof(PRE_PAY_INFO));	
	memset(&byTmpBuffer, 0, sizeof(byTmpBuffer)); //4.0.22.507 - TD 75752

	switch(lFlags)
	{
		// Create new PrePay transaction 
		case CASH_ACCEPTORS_TRANSACTION_CREATED:
		{
			//4.0.10.45
			short nPrePayWaiting =0,nFree =0,nUnpaid =0; 
			CPumpStatus		pumpStat = m_cPumpArray[p].GetStat();

			if ((!nPrePayWaiting)||(lFlags & CASH_ACCEPTORS_TRANSACTION_FORCE_CANCELED))//4.0.10.114
			{
	//4.0.10.45
				trs.Clear();
				trs.SetOnOffer(SERVER_OLA_POS_NUMBER);				
				PrePayRec.info.lPOSNumber		= SERVER_OLA_POS_NUMBER;					
				trs.m_lNumber		= NewTransactNumber();
				trs.m_sLoyaltyDiscountApplied = ' ';
				PrePayRec.info.lSyncNumber	= trs.m_lNumber;
				trs.UpdateTime();
				trs.UpdateStartTime();	//TD 40492
				trs.UpdateStartFuelingTime();	//4.0.22.511 72606
				trs.SetLink(TRS_LINK_PREPAY_NUMBER + TRS_LINK_EXTRA_INFO + TRS_LINK_CASH_ACCEPTOR_INFO,PrePayRec.info.lSyncNumber);
				trs.SetStatus(WAIT_PROGRESS);
				trs.m_lActiveShiftNumber = GetActiveShiftNumber();
				trs.m_lPump = lPumpNumber;			
				PrePayRec.info.lPumpNumber	=	lPumpNumber;

				int iRetNum = CentralInsertTrs(lPumpNumber,&trs);				


				if(retCode  == GCI_OK)
				{
					ExtraInfoRec.ClearRecord();
					trs.m_lResExt = RES_EXT_CASH_ACCEPTOR;
					CentralUpdateTrs(lPumpNumber, trs.m_lNumber,&trs ,FALSE);


					ExtraInfoRec.info.lIndexNumber = trs.m_lNumber;
					ExtraInfoRec.info.lPumpNumber = lPumpNumber; //4.0.10.44
					ExtraInfoRec.info.lSeqNumber = lSeqNum;//4.0.10.44
					ExtraInfoRec.info.lDevice = lDevice;//4.0.10.44


					PrePayRec.info.lFlags = LIMIT_BY_VALUE;
				
					if(lRtc = TrsLinkOperation(REC_INSERT,&trs,&PrePayRec,&ExtraInfoRec))
					{
						//4.0.24.60 - TD 111641
						// In case insert to prepay qdex fails, return an error code to CL
						if (lRtc)
							retCode = GCI_FAILED_IO;

						lRtc = 0;
						int iRetNum = WideCancelTrs(SOURCE_GPI, lPumpNumber, trs.m_lNumber, &lRtc);					

						if(iRetNum)
							retCode = GCI_PUMP_TRS_LIST_IS_FULL;
					}
				}
			}
			else if(!(m_cModeArray[pumpStat.GetMode()-1].CashAcceptorValid()))
			{
				sMsg.Format("SetCashAcceptorData Not in valid mode  "); 
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
				retCode = GCI_NOT_VALID_IN_CURRENT_MODE;
			}

			else
				retCode = GCI_PUMP_TRS_LIST_IS_FULL; //4.0.10.45
			
		}
		break;
		case CASH_ACCEPTORS_TRANSACTION_UPDATE_BILLS:
		{
			CPumpTransact trs;
			// Transaction was open Update bills information 
			//4.0.28.500 if (m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_PREPAY_NUMBER,&trs))
			if (m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_CASH_ACCEPTOR_INFO,&trs))
			{
				int iLen = Bstr2Buffer(CashSaleData, (void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));
				
				if(iLen == 0)
				{					
					dwLastErr = GetLastError();
					retCode = GCI_LAST_ERROR;
				}
				else
				{
					CCashAcceptor cCashAcceptor;


					ExtraInfoRec.info.lIndexNumber = trs.m_lNumber;
					lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);

					if (!lRtc)
					{
						memcpy(&cTagCashSaleData,(void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));					
						cCashAcceptor.UpdatebillsInformation(lPumpNumber, lDevice, lSeqNum, ExtraInfoRec ,cTagCashSaleData) ;												
						ExtraInfoRec.info.lDevice = lDevice;

						ExtraInfoRec.info.lPumpNumber = lPumpNumber; //4.0.10.52
						ExtraInfoRec.info.lSeqNumber = lSeqNum;//4.0.10.52
						

						// Update Max Cash acceptor limit
						
						// Update PrePay record. 										
						lRtc = TrsLinkOperation(REC_READ,&trs,&PrePayRec);

						if (!lRtc)
						{							
							PrePayRec.info.lMaxValue =  ExtraInfoRec.info.lCashDepositTotal - ExtraInfoRec.info.lCarWashAmount ;							
							CentralUpdateTrs(lPumpNumber, trs.m_lNumber,&trs ,FALSE);
							lRtc = TrsLinkOperation(REC_UPDATE,&trs,&PrePayRec);

							if (lRtc)
							{
								if(LOG_DETAIL_FLOW_CONTROL)
								{							
									sMsg.Format("UpdateCashAcceptorData Fail to update PrePay Transaction ,  Trs =%ld, Total=%ld",trs.m_lNumber, ExtraInfoRec.info.lCashDepositTotal); 
									m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
								}

							}
							else
							{
								if(LOG_DETAIL_FLOW_CONTROL)
								{							
									sMsg.Format("UpdateCashAcceptorData to update Cash acceptor  Transaction ,  Trs =%ld, CashDepositTotal=%ld - terminal =%ld , car wash %ld",trs.m_lNumber, ExtraInfoRec.info.lCashDepositTotal ,lDevice , ExtraInfoRec.info.lCarWashAmount);  //4.0.10.51
									m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
								}

							}

							lRtc = IndexOperation(EXTRA_INFO_FILE, REC_UPDATE, &ExtraInfoRec);

							if (lRtc)
							{
								if(LOG_DETAIL_FLOW_CONTROL)
								{							
									sMsg.Format("UpdateCashAcceptorData Fail to update Extra Info file ,  Trs =%ld, Total=%ld",trs.m_lNumber, PrePayRec.info.lMaxValue); 
									m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
								}

							}
						}
						else
						{
							retCode = GCI_TRS_NOT_FOUND;
							if(LOG_DETAIL_FLOW_CONTROL)
							{							
								sMsg.Format("UpdateCashAcceptorData Fail to update total Cash acceptor Sale ,  Trs =%ld, Total=%ld",trs.m_lNumber, ExtraInfoRec.info.lTransactionAmount); 
								m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
							}
						}						
					}
					else
					{
						retCode = GCI_TRS_NOT_FOUND;
						if(LOG_DETAIL_FLOW_CONTROL)
						{							
							sMsg.Format("UpdateCashAcceptorData Fail to locate Cash acceptor record in ExtraInfo,  bills Index =%ld, lFlags=%ld",trs.m_lNumber, lFlags); 
							m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
						}
					}					
				}
			}
		}
		break;
		case CASH_ACCEPTORS_TRANSACTION_UPDATE_FINAL:
		{
			//4.0.11.504
			CCashAcceptor cCashAcceptor;
			int iLen= Bstr2Buffer(CashSaleData, (void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));
			memcpy(&cTagCashSaleData,(void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));					
			retCode = cCashAcceptor.CashAcceptorUpdateData(lPumpNumber ,cTagCashSaleData , trs);
			// 4.0.11.504

		}
		break;
		case CASH_ACCEPTORS_TRANSACTION_CANCELED:
		{

			//4.0.11.90
			CCashAcceptor cCashAcceptor;
			int iLen= Bstr2Buffer(CashSaleData, (void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));
			memcpy(&cTagCashSaleData,(void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));					
			retCode = cCashAcceptor.CashAcceptorUpdateData(lPumpNumber ,cTagCashSaleData , trs);
			

			if (!retCode)
			{
				trs.m_lStatus = PAID;//4.0.12.300
				if(LOG_DETAIL_FLOW_CONTROL)
				{							
					sMsg.Format("Pump %02ld Cancel Cash acceptor trs %ld ", trs.m_lPump,trs.m_lNumber); // 4.0.11,230
					m_cLogger.LogMsg(sMsg);
				}
				cCashAcceptor.GenerateCashAcceptorPayIn(p+1,trs, CASH_ACCEPTORS_TRANSACTION_CANCELED); //4.0.21.500 69415
			}
			
		}
		break;
		//4.0.11.503
		case CASH_ACCEPTORS_TRANSACTION_FORCE_CANCELED:
		{
			if (m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS,TRS_LINK_PREPAY_NUMBER,&trs))
				if(lFlags & CASH_ACCEPTORS_TRANSACTION_FORCE_CANCELED)
				{
					trs.SetStatus(PAID);
					int iRetNum = CentralUpdateTrs(lPumpNumber,trs.m_lNumber,&trs,FALSE);				
					sMsg.Format("UpdateCashAcceptorData Set the trs to Paid"); 
					m_cLogger.LogMsg(sMsg);
				}
		}
		break;
		//4.0.17.90 - TD 40564
		case CASH_ACCEPTORS_UNRECOGNIZED_BILL:
		{
			if(LOG_DETAIL_FLOW_CONTROL)
			{							
				sMsg.Format("CServerMain::UpdateCashAcceptorData lDevice=%ld lFlags=%ld", lDevice , lFlags);
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
			}

			// First Step. Accumulate the unrecognized bill to the cash acceptor qdx for the PIC report
			int iLen = Bstr2Buffer(CashSaleData, (void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));
				
			if(iLen == 0)
			{					
				dwLastErr = GetLastError();
				retCode = GCI_LAST_ERROR;
			}
			else
			{
				CCashAcceptor cCashAcceptor;
				CASH_ACCEPTOR_REC cCashAcceptorRec;
				memcpy(&cTagCashSaleData,(void *)byTmpBuffer,sizeof(TAG_CASH_SALE_DATA));					

				if (IsCashAcceptorreportEnable())
				{
					memset(&cCashAcceptorRec , 0 , sizeof(cCashAcceptorRec));
					
					cCashAcceptorRec.lTerminalId = lDevice;
					
					cCashAcceptorRec.lCounter = a2l(cTagCashSaleData.sCashDeposit1,sizeof(cTagCashSaleData.sCashDeposit1)) + 
												a2l(cTagCashSaleData.sCashDeposit2,sizeof(cTagCashSaleData.sCashDeposit2)) + 
												a2l(cTagCashSaleData.sCashDeposit5,sizeof(cTagCashSaleData.sCashDeposit5)) +
												a2l(cTagCashSaleData.sCashDeposit10,sizeof(cTagCashSaleData.sCashDeposit10)) +
												a2l(cTagCashSaleData.sCashDeposit20,sizeof(cTagCashSaleData.sCashDeposit20)) +
												a2l(cTagCashSaleData.sCashDeposit50,sizeof(cTagCashSaleData.sCashDeposit50)) +
												a2l(cTagCashSaleData.sCashDeposit100,sizeof(cTagCashSaleData.sCashDeposit100));

					cCashAcceptorRec.lAmount = a2l(cTagCashSaleData.sCashDepositTotal, sizeof(cTagCashSaleData.sCashDepositTotal));

					lRtc = m_cCashAcceptorFile.UpdateBillsCurrent(lDevice , cCashAcceptorRec);

					if(LOG_DETAIL_FLOW_CONTROL && lRtc)
					{							
						sMsg.Format("CServerMain::UpdateCashAcceptorData Failed to update unrecognized bill lDevice=%ld lFlags=%ld", lDevice, lFlags); 
						m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
					}
					

					//Second step. Update the OLA qdx with the unrecognized bill record
					if (!lRtc)
					{
						EXTRA_INFO_REC ExtraInfoRec;
						memset(&ExtraInfoRec, 0, sizeof(EXTRA_INFO_REC)); //4.0.18.0
						
						CPumpTransact trs;
						trs.Clear();
						
						ExtraInfoRec.info.byCashDeposit1 = (char )a2l(cTagCashSaleData.sCashDeposit1, sizeof(cTagCashSaleData.sCashDeposit1));
						ExtraInfoRec.info.byCashDeposit2 = (char )a2l(cTagCashSaleData.sCashDeposit2, sizeof(cTagCashSaleData.sCashDeposit2));
						ExtraInfoRec.info.byCashDeposit5 = (char )a2l(cTagCashSaleData.sCashDeposit5, sizeof(cTagCashSaleData.sCashDeposit5));
						ExtraInfoRec.info.byCashDeposit10 = (char )a2l(cTagCashSaleData.sCashDeposit10, sizeof(cTagCashSaleData.sCashDeposit10));
						ExtraInfoRec.info.byCashDeposit20 = (char )a2l(cTagCashSaleData.sCashDeposit20, sizeof(cTagCashSaleData.sCashDeposit20));
						ExtraInfoRec.info.byCashDeposit50 = (char )a2l(cTagCashSaleData.sCashDeposit50, sizeof(cTagCashSaleData.sCashDeposit50));
						ExtraInfoRec.info.byCashDeposit100 = (char )a2l(cTagCashSaleData.sCashDeposit100, sizeof(cTagCashSaleData.sCashDeposit100));

						//4.0.17.450 Merge
						ExtraInfoRec.info.lCashDepositTotal = a2l(cTagCashSaleData.sCashDepositTotal, sizeof(cTagCashSaleData.sCashDepositTotal));
						ExtraInfoRec.info.lCashDepositTotal *= 10; //4.0.19.504 TD 59905
						ExtraInfoRec.info.lRefundAmount = a2l(cTagCashSaleData.sRefundAmount, sizeof(cTagCashSaleData.sRefundAmount));

						ExtraInfoRec.info.lPumpNumber = 0;
						ExtraInfoRec.info.lDevice = lDevice;
						ExtraInfoRec.info.lSeqNumber = lSeqNum;

						ExtraInfoRec.info.lTransactionAmount = 0;
						ExtraInfoRec.info.lAuthAmt = 0;		//4.0.17.450

						memcpy(ExtraInfoRec.info.sInvoiceNumber, cTagCashSaleData.sInvoiceNumber, sizeof(ExtraInfoRec.info.sInvoiceNumber));
												
						cCashAcceptor.SendDataToOLA(trs, ExtraInfoRec, TRUE, TRUE); //4.0.18.0
						cCashAcceptor.GenerateReceiptRowDataUnrecognizedBill(trs,ExtraInfoRec);
						
					}
				}
			}

		}
		break;
		default:
		if(LOG_DETAIL_FLOW_CONTROL)
		{							
			sMsg.Format("UpdateCashAcceptorData case not found to Flags=%ld" , lFlags); 
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg);
		}
		retCode = GCI_TRS_NOT_FOUND;
		break;
	}		

	return  retCode;
}

//4.0.1.38 start
void CServerMain::InitVPThreadInfo()
{
	m_hVPThread = NULL;
	m_cVPThreadInfo.m_hVPStartThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cVPThreadInfo.m_hVPStopThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cVPThreadInfo.m_hVPKillThread	= CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cVPThreadInfo.m_hVPThreadKilled = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cVPThreadInfo.m_pServer = this;	
}

//4.0.24.60
void CServerMain::CreateVPThread()
{
	CheckIfAnotherVPIsRunningAndStopIt();
	if (m_cVPThread.Init() == THREAD_OK)
		m_cVPThread.StartVPThread();


}
void CServerMain::DeleteVPThreadInfo()
{
	if(m_dwVpActive)
	{
		//4.0.24.60
		m_cVPThread.CleanUp();
	}
}
// Function name	: CALLBACK CServerMain::VPThread
// Description	    : The VP thread START_ROUTINE
// Return type		: unsigned int 
// Argument         : void *pv - actually the CVPsThreadInfo struct.
unsigned int CALLBACK CServerMain::VPThread(void *pv)
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if (pv == NULL )
		return -1;    // illegal parameter

    long lRetVal = 0;
	CVPThreadInfo* pInfo = (CVPThreadInfo*)pv;
	BOOL	bKillThread = FALSE;

	if(LOG_BASIC_FLOW_CONTROL)
	{	
		char sStr[MAX_FIELD_VAL];
		sprintf_s(sStr, _countof(sStr),"VPThread - start");
		_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
	}

	while (TRUE)
	{
		// Wait until the main application thread asks 
		// this thread to start.
		if (WaitForSingleObject(pInfo->m_hVPStartThread, INFINITE)
			!= WAIT_OBJECT_0)
			break; //  Terminate this thread by existing the proc.

		// Exit the thread if the main application sets the "kill thread"
		// event.
		if (WaitForSingleObject(pInfo->m_hVPKillThread, 0)
			== WAIT_OBJECT_0)
			break; // Terminate this thread by existing the proc.
		
		bKillThread = FALSE;
				
		while (TRUE)	
		{			

			if (WaitForSingleObject(pInfo->m_hVPKillThread, 0)
				== WAIT_OBJECT_0)
			{
				bKillThread = TRUE;
				break; // Terminate this thread by existing the proc.			
			}

			if (WaitForSingleObject(pInfo->m_hVPStopThread, 0)
				== WAIT_OBJECT_0)
			{
				break; // Terminate main loop and wait for start
			}
			//Here to add the working methods
			pInfo->m_pServer->ConnectToVp();
				
			Sleep(VP_THRD_SLEEP_TIME);				

		}
		
		if(bKillThread) // exit loop due to kill command
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				char sStr[MAX_FIELD_VAL];
				sprintf_s(sStr, _countof(sStr),"VPThread - End");
				_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
			}

			break;	
		}
	}
					
	SetEvent(pInfo->m_hVPThreadKilled);	
	CoUninitialize();
	return 0;
}

//4.0.24.60
VpStatus CServerMain::ConnectToVp()
{
	VpStatus enmVpStatusRes = VP_OK;
	if(m_dwVpActive)
	{
		//only if we are in idle state we will connect to VP
		if(m_lServerState == SERVER_IDLE)
		{
			enmVpStatusRes = m_cVpMng.Connect(PUMPSRV_NUMERIC_VERSION);
		}
	}
	return enmVpStatusRes;		
}

void CServerMain::DisconnectFromVp()
{
	if(m_dwVpActive)
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{	
			_LOGMSG.LogMsg("Disconnecting from VP");			
		}
		m_cVpMng.Disconnect();
	}
		
}


void CServerMain::SetVpIsGone(BOOL bVpIsGone)
{
	m_bVpIsGone = bVpIsGone;
}


BOOL CServerMain::GetVpIsGone()const	
{
	return m_bVpIsGone;
}


void CServerMain::ResetVpRecoveryCounter()
{
	if(m_dwVpActive)
	{
		m_cVPThread.ResetVpRecoveryCounter();
	}

}               

  // 4.0.29.500 TD 264908 end
BOOL CServerMain::IsDependByVpRecovery()
{
	BOOL bRetVal = FALSE;
	if(m_dwVpActive)
	{
		bRetVal = (m_lVpRecoveryMaxRetries > 0);
	}

	return bRetVal;
}

eFuelMobileSrvStatus CServerMain::CheckFuelMobileSrv()
{
	eFuelMobileSrvStatus enmFmStatusRes = FuelMobileSrv_OK;
	long lWatchDogParameter = 0;  // not in use

	if (m_dwFuelMobileSrvInUse)
	{
		//only if we are in idle state we will check FuelMobileSrv
		if (m_lServerState == SERVER_IDLE)
		{
			try
			{
				CComBSTR  bstrData(L" ");

				//if (m_pFuelMobileSrvCtrl != NULL)
				//	m_pFuelMobileSrvCtrl->WatchDog(lWatchDogParameter, &bstrData);
				//else
				//	enmFmStatusRes = FuelMobileSrv_OFF;
			}
			catch (_com_error& e)
			{
				m_cLogger.LogClassMsg("ServerMain", "CheckFuelMobileSrv", 0, LOG_NONE, e.ErrorMessage(), LOG_LEVEL_0);
				enmFmStatusRes = FuelMobileSrv_OFF;
				m_pFuelMobileSrvCtrl = NULL;
			}
			catch (...)
			{
				CString sMsg;
				sMsg.Format("CheckFuelMobileSrv");
				m_cLogger.LogMsg(sMsg, LOG_LOGIC_ERROR);
				enmFmStatusRes = FuelMobileSrv_OFF;
			}

		}
	}

	if (enmFmStatusRes == FuelMobileSrv_OFF)
	{
		CloseConnectToFuelMobileSrv();
		ConnectToFuelMobileSrv();
	}

	return enmFmStatusRes;
}


BOOL CServerMain::CheckNozzleLeftOutTimeout()
{
	BOOL bRetVal = FALSE;

	if(m_dwNozzleLeftOut)
	{
		CPumpTransact cTrs;
		CPumpStatus cPumpStatus;
		CTimeSpan cTimeSpan;

		//We can get the time at the beginning of the loop, because we
		//are comparing minutes, and the loop takes less than a second.
		CTime cCurrentTime = CTime::GetCurrentTime();

		CString sLogMsg;

		long lMisc = 0;
		
		for(long lPump = 0;lPump < m_lLastValidPump;lPump++)
		{
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

			cPumpStatus = m_cPumpArray[lPump].GetStat();
			lMisc = cPumpStatus.GetMisc();
			
			if(cPumpStatus.GetStatus() == DISPENSING)
			{
				//A dispensing pump may not have a transaction
				//on it, due to some error (the transaction will
				//be created when we get a call to PAKReadyTransaction.
				if(!m_cPumpArray[lPump].GetCurrentTrs(&cTrs))
				{
					cTimeSpan = cCurrentTime - cTrs.GetTime();

					DWORD dwTotalSeconds = (DWORD)cTimeSpan.GetTotalSeconds();

					if(dwTotalSeconds > m_dwNozzleLeftOut)
					{
						//Update pump misc only if "drive off" not already
						//set at pump (no point in both miscs)
						if(!(lMisc & MISC_DISPENSING_TIMEOUT))
						{
							lMisc |= MISC_NOZZLE_LEFT_OUT_TIMEOUT;

							//4.0.2.161
							bRetVal = TRUE;

							sLogMsg.Format("CheckNozzleLeftOutTimeout, TRS #%ld found with timeout of %d seconds" , cTrs.m_lNumber , dwTotalSeconds);
							m_cLogger.LogMsg(lPump+1,LOG_PUMP,sLogMsg);
						}
					}

					//We may have a left over misc from a previous trs,
					//when more than one trs existed in the trs array
					else
						lMisc &= MISC_NOT_NOZZLE_LEFT_OUT_TIMEOUT;
				}

				//we may have a left over misc from a previous trs
				//but the trs list is now empty, because the current trs
				//doesn't exist for some reason
				else
					lMisc &= MISC_NOT_NOZZLE_LEFT_OUT_TIMEOUT;
			}

			//we may have a left over misc from a previous trs
			//but the pump is now idle
			else
				lMisc &= MISC_NOT_NOZZLE_LEFT_OUT_TIMEOUT;

			cPumpStatus.SetMisc(lMisc);
			m_cPumpArray[lPump].SetStat(cPumpStatus);
		}
	}

	return bRetVal;
}
//4.0.1.38 end

//4.0.1.40
long CServerMain::GetAlarmSrvMode()
{
	return m_dwAlarmSrvActive;
}

unsigned int CALLBACK CServerMain::AlarmSrvThread(void *pv)
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);
	CAlarmSrvQueueData	 cAlarmSrvQueueData;   
    long lRetries = 1; 
	GAIRetCode retcode= GAI_OK;

	if (pv == NULL )
		return -1;    // illegal parameter

    long lRetVal = 0;
	CAlarmSrvThreadInfo* pInfo = (CAlarmSrvThreadInfo*)pv;
	
	BOOL	bKillThread = FALSE;

	if(LOG_BASIC_FLOW_CONTROL)
	{	
		char sStr[MAX_FIELD_VAL];
		sprintf_s(sStr, _countof(sStr),"AlarmSrvThread start ");
		_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
	}

	while (TRUE)
	{
		// Wait until the main application thread asks 
		// this thread to start.
		if (WaitForSingleObject(pInfo->m_hAlarmSrvStartThread, INFINITE)
			!= WAIT_OBJECT_0)
			break; //  Terminate this thread by existing the proc.

		// Exit the thread if the main application sets the "kill thread"
		// event.
		if (WaitForSingleObject(pInfo->m_hAlarmSrvKillThread, 0)
			== WAIT_OBJECT_0)
			break; // Terminate this thread by existing the proc.
		
		bKillThread = FALSE;
				
		while (TRUE)	
		{			

			if (WaitForSingleObject(pInfo->m_hAlarmSrvKillThread, 0)
				== WAIT_OBJECT_0)
			{
				bKillThread = TRUE;
				break; // Terminate this thread by existing the proc.			
			}

			if (WaitForSingleObject(pInfo->m_hAlarmSrvStopThread, 0)
				== WAIT_OBJECT_0)
			{
				break; // Terminate main loop and wait for start
			}						

			//4.0.3.15
			// handle Send to AlarmSrv command
			if(!pInfo->m_pServer->m_cAlarm.m_cAlarmSrvQueue.Empty())
			{
				lRetVal = pInfo->m_pServer->m_cAlarm.m_cAlarmSrvQueue.GetHead(&cAlarmSrvQueueData);

				if (lRetVal  == QUEUE_NO_ERROR)
				{					
					pInfo->m_pServer->ProcessAlarmCommand(cAlarmSrvQueueData);
					lRetVal = pInfo->m_pServer->m_cAlarm.m_cAlarmSrvQueue.Remove(&cAlarmSrvQueueData);
				}
					
			}

			// handle Alarm fire by AlarmSrv
			if(!pInfo->m_pServer->m_cAlarm.m_cAlarmReceivedQueue.Empty())
			{
				lRetVal = pInfo->m_pServer->m_cAlarm.m_cAlarmReceivedQueue.GetHead(&cAlarmSrvQueueData);

				if (lRetVal  == QUEUE_NO_ERROR)
				{
					pInfo->m_pServer->ProcessAlarmCommand(cAlarmSrvQueueData);
					lRetVal = pInfo->m_pServer->m_cAlarm.m_cAlarmReceivedQueue.Remove(&cAlarmSrvQueueData);
				}

			}
			//4.0.3.15	

			Sleep(ALARM_SRV_THRD_SLEEP_TIME);  //4.0.2.27				

		}
		
		if(bKillThread) // exit loop due to kill command
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{	
				char sStr[MAX_FIELD_VAL];
				sprintf_s(sStr, _countof(sStr),"AlarmSrvThread - End ");
				_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
			}

			break;	
		}
	}
					
	SetEvent(pInfo->m_hAlarmSrvThreadKilled);	
	CoUninitialize();
	return 0;
}

void CServerMain::InitAlarmSrvThreadInfo()
{	
	m_hAlarmSrvThread = NULL;

	m_cLogger.LogMsg("InitAlarmSrvThreadInfo - Start");	
	m_cAlarmSrvThreadInfo.m_hAlarmSrvStartThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cAlarmSrvThreadInfo.m_hAlarmSrvStopThread = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cAlarmSrvThreadInfo.m_hAlarmSrvKillThread	= CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset
	m_cAlarmSrvThreadInfo.m_hAlarmSrvThreadKilled = CreateEvent(NULL, FALSE, FALSE, NULL); // auto reset, initially reset	
	m_cAlarmSrvThreadInfo.m_pServer = this;	

}

void CServerMain::CreateAlarmSrvThread()
{
	CString str;
	 str.Format("Create AlarmSrv thread");
	_LOGMSG.LogMsg(str);	

	InitAlarmSrvThreadInfo();

	if (!m_hAlarmSrvThread)
	{
		m_hAlarmSrvThread = (HANDLE) CreateThread(NULL,
								0,
								(LPTHREAD_START_ROUTINE )AlarmSrvThread,
								&m_cAlarmSrvThreadInfo,
								0,
								&m_dwEventThreadId );
		if(m_hAlarmSrvThread)
		{
			StartAlrmSrvThread();
			
			// change to proirity of events Threads to be lowest for normal, 
			//4.0.2.27 
			BOOL bThreadPriprity = SetThreadPriority(m_hAlarmSrvThread,THREAD_PRIORITY_LOWEST);
			DWORD dwLastError =GetLastError();

			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString sMsg;
				sMsg.Format("CreateAlarmSrvThread Event thread set to THREAD_PRIORITY_LOWEST=%d, lastError=%ld ",bThreadPriprity , dwLastError );
				m_cLogger.LogMsg(sMsg);
			}
			//4.0.2.27 

		}
	}
	else
	{
		str.Format("CreateAlarmSrvThread Event thread Exist");
		m_cLogger.LogMsg(str);	
	}
}

void CServerMain::DeleteAlarmSrvThreadInfo()
{
	CString str;
	// Kill the worker thread by setting the "kill thread" event.
	SetEvent(m_cAlarmSrvThreadInfo.m_hAlarmSrvKillThread);
	SetEvent(m_cAlarmSrvThreadInfo.m_hAlarmSrvStartThread); 
	WaitForSingleObject(m_cAlarmSrvThreadInfo.m_hAlarmSrvThreadKilled, INFINITE);
	
	CloseHandle(m_cAlarmSrvThreadInfo.m_hAlarmSrvStartThread);
	CloseHandle(m_cAlarmSrvThreadInfo.m_hAlarmSrvStopThread);
	CloseHandle(m_cAlarmSrvThreadInfo.m_hAlarmSrvKillThread);
	CloseHandle(m_cAlarmSrvThreadInfo.m_hAlarmSrvThreadKilled);

	CloseHandle(m_hAlarmSrvThread);
	m_hAlarmSrvThread = NULL;

	
	 str.Format("DeleteAlarmSrvThreadInfo, thread destroy");
	_LOGMSG.LogMsg(str);	

}

void CServerMain::StartAlrmSrvThread()
{
	SetEvent(m_cAlarmSrvThreadInfo.m_hAlarmSrvStartThread);
}

void CServerMain::StopAlarmSrvThread()
{
	SetEvent(m_cAlarmSrvThreadInfo.m_hAlarmSrvStopThread);
}

/******************************************************************************
 Description:	Is active shift with lock 	
 Returns:      	None
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			17/11/2002   14:46		Start
******************************************************************************/
long CServerMain::IsActiveShiftWithLock()
{
	if ((m_cServerInfo.GetRequiredShiftProcessFlags()) && (m_cServerInfo.GetShiftLockFlags()))
		return TRUE;
	else
		return  FALSE;
}


long CServerMain::SetPumpModeScheme3(long lPumpNumber, long lScheme, long lMode, BSTR sPeriodDateTimeStart, BSTR sPeriodDateTimeEnd, BSTR sDateTimeStart, BSTR sDateTimeEnd, long lServiceFeeNo, long lFlags, long *pVal)
{
	  
	 EnterCriticalSection(&m_csModeSchemeArray);

	 long lIndex = GenerateModeSchemeIndex(lPumpNumber , lScheme); 			

	
	m_cModeSchemeArray[lIndex].SetMode(lMode);
	m_cModeSchemeArray[lIndex].SetFlags(lFlags);

	SZ_TAG_SYSTEMTIME szTagTime;
	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));
	int iLen = WideCharToMultiByte(CP_ACP,0,sDateTimeStart,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);
	if(iLen == 0)
	{			
		SYSTEMTIME curSysTime;
		GetLocalTime(&curSysTime);					
		SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	}

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("SetPumpModeScheme3 start=%s , Mode = %ld, lScheme = %ld, lFlags = %ld" , (char*)&szTagTime,lMode,lScheme,lFlags); //4.0.17.501 add log
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
	
	m_cModeSchemeArray[lIndex].SetStartTime(&szTagTime.sTime);

	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));
	iLen = WideCharToMultiByte(CP_ACP,0,sDateTimeEnd,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);
	if(iLen == 0)
	{			
		SYSTEMTIME curSysTime;
		GetLocalTime(&curSysTime);					
		SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	}	

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("SetPumpModeScheme3  End=%s" , (char*)&szTagTime);
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}		
	m_cModeSchemeArray[lIndex].SetEndTime(&szTagTime.sTime);

	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));
	iLen = WideCharToMultiByte(CP_ACP,0,sPeriodDateTimeStart ,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);
	if(iLen == 0)
	{			
		SYSTEMTIME curSysTime;
		GetLocalTime(&curSysTime);					
		SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	}	
	m_cModeSchemeArray[lIndex].SetPeriodStartTime(&szTagTime.sTime);
	
	//4.0.3.27
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("SetPumpModeScheme3 , PeriodStart=%s", (char*)&szTagTime);
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}

	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));
	iLen = WideCharToMultiByte(CP_ACP,0,sPeriodDateTimeEnd,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);
	if(iLen == 0)
	{			
		SYSTEMTIME curSysTime;
		GetLocalTime(&curSysTime);					
		SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	}	
	m_cModeSchemeArray[lIndex].SetPeriodEndTime(&szTagTime.sTime);

	//4.0.3.27
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("SetPumpModeScheme3, PeriodEnd=%s", (char*)&szTagTime);
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
	
	m_cModeSchemeArray[lIndex].SetServiceFeeSet(lServiceFeeNo);
	m_cModeSchemeArray[lIndex].SetServiceMode(lFlags);

	m_cModeSchemeArray[lIndex].SaveDefinition(1);
	LeaveCriticalSection(&m_csModeSchemeArray);

	return 0;
}

long CServerMain::GetPumpModeScheme3(long lPumpNumber, long lScheme, long *plMode, BSTR *psPeriodDateTimeStart, BSTR *psPeriodDateTimeEnd, BSTR *psDateTimeStart, BSTR *psDateTimeEnd, long *plServiceFeeNo, long *plFlags, long *pVal)
{
	EnterCriticalSection(&m_csModeSchemeArray);
	long lIndex = GenerateModeSchemeIndex(lPumpNumber , lScheme); 			

	*psDateTimeStart = m_cModeSchemeArray[lIndex].GetStringStartTime().AllocSysString();	
	*psDateTimeEnd =  m_cModeSchemeArray[lIndex].GetStringEndTime().AllocSysString();	
	*psPeriodDateTimeStart =  m_cModeSchemeArray[lIndex].GetStringPeriodStartTime().AllocSysString(); 
	*psPeriodDateTimeEnd =  m_cModeSchemeArray[lIndex].GetStringPeriodEndTime().AllocSysString(); 
	*plServiceFeeNo = m_cModeSchemeArray[lIndex].GetServiceFeeSet();

	if(plMode)
		*plMode =  m_cModeSchemeArray[lIndex].GetMode();

	if(plFlags)
		*plFlags =  m_cModeSchemeArray[lIndex].GetFlags();
	LeaveCriticalSection(&m_csModeSchemeArray);

	return 0;
}

//4.0.2.15
long CServerMain::ClearPAPInfo(long lPumpNumber)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	PAY_AT_PUMP_INFO	info;
	BOOL bChange = FALSE;
	long lRetCode= 0;
	
	if(PUMP_NOT_VALID(lPumpNumber))  //4.0.20.56
	{
		lRetCode = 1;
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			str.Format("ClearPAPInfo - PUMP_NOT_VALID %ld", lPumpNumber); 
			m_cLogger.LogMsg(str, LOG_LEVEL_1);
		}
	}
	else
	{
		CString str;
		str.Format("ClearPAPInfo() - Pump %ld", lPumpNumber);
		m_cLogger.LogMsg(str);

		m_cPumpArray[lPumpNumber-1].GetPAPInfo(&info);

		if (info.CardSaleInfo.cardData.sTranStatus == CD_VIT_CONFLICT)
		{
			info.CardSaleInfo.cardData.sTranStatus = ' ';		
			bChange =TRUE;
		}
		else if (m_cPumpArray[lPumpNumber-1].IsLoyaltyClub())  //4.0.5.39
		{
			info.CardSaleInfo.cardData.sTranType = ' ';		
			bChange =TRUE;
		}
		else if (m_cPumpArray[lPumpNumber-1].IsPapToPakTrs())  //4.0.23.240 //4.0.24.60
		{
			memset(info.CardSaleExtraData3.sFlags1 , ' ' ,sizeof(info.CardSaleExtraData3.sFlags1));
			bChange =TRUE;
		}
		else if (info.CardSaleExtraData5.sLoyaltyAutoArm == '1')  // QC 445307
		{
			info.CardSaleExtraData5.sLoyaltyAutoArm = ' ';
			bChange = TRUE;
		}

		if (bChange)
		{		
			m_cPumpArray[lPumpNumber-1].SetPAPInfo(&info);

			SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);

		}
	}

	return (lRetCode);
}

//4.0.20.180 67388 //4.0.21.0
long CServerMain::ClearLoyaltyInfo(long lPumpNumber)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	PAY_AT_PUMP_INFO	info;
	BOOL bChange = FALSE;
	long lRetCode= 0;
	
	if(PUMP_NOT_VALID(lPumpNumber))  //4.0.20.56
	{
		lRetCode = 1;
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			str.Format("ClearLoyaltyInfo - PUMP_NOT_VALID %ld", lPumpNumber); 
			m_cLogger.LogMsg(str, LOG_LEVEL_1);
		}
	}
	else
	{
		m_cPumpArray[lPumpNumber-1].GetPAPInfo(&info);

		if ((m_cFuelLoayaltyPS.GetFuelLoyaltyFlag()) || (m_cPumpArray[lPumpNumber-1].IsPapToPakTrs()))	//4.0.20.51 63930 //4.0.22.506 67786
		{

			memset(info.CardSaleExtraData4.sLoyaltyVolumeLimit,' ', sizeof(info.CardSaleExtraData4.sLoyaltyVolumeLimit));//4.0.20.300 //4.0.21.0
			memset(&info.CardSaleExtraData4.sExistLoyaltyLimit, ' ', sizeof(info.CardSaleExtraData4.sExistLoyaltyLimit));//4.0.20.300 //4.0.21.0
			memset(&info.CardSaleInfo.cardData.sAccountNumber, ' ', sizeof(info.CardSaleInfo.cardData.sAccountNumber)); 
			memset(info.CardSaleInfo.extraData.sLoyalId, ' ', sizeof(info.CardSaleInfo.extraData.sLoyalId));
			memset(info.CardSaleExtraData2.sPromotionNumber, ' ', sizeof(info.CardSaleExtraData2.sPromotionNumber));//4.0.22.504 73878
			info.CardSaleExtraData5.sPumpAutoStart = ' ' ;// 4.0.23.1530
			memset(info.CardSaleInfo.extraData.sCustomerName, ' ', sizeof(info.CardSaleInfo.extraData.sCustomerName));  //4.0.1023.264?
			memset(info.CardSaleExtraData6.sPromotionID, ' ', sizeof(info.CardSaleExtraData6.sPromotionID));  //	RFUEL-155
			info.CardSaleInfo.cardData.sTranType =  ' '; // 4.0.23.372 //4.0.25.0 123916

			if (m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())  //4.0.24.60 109168
				m_cFuelLoayaltyPS.SetCancelTrs(lPumpNumber, NoCancel);//4.0.22.504 73878
			m_cPumpArray[lPumpNumber-1].ClearOlaStat();//4.0.22.504 73878
			for(int i=0 ; i< MAX_GRADES; i++) //4.0.22.504 73878
			{
				l2a(0, info.CardSaleExtraData2.sDiscountPerGrade[i].sDiscount , sizeof(info.CardSaleExtraData2.sDiscountPerGrade[i].sDiscount));  		 
			}

			memset(info.CardSaleExtraData3.GradeLimitsArray, ' ', sizeof(info.CardSaleExtraData3.GradeLimitsArray)); //4.0.22.506 67786
			memset(info.CardSaleInfo.cardData.sClubCardTrack2Data, ' ', sizeof(info.CardSaleInfo.cardData.sClubCardTrack2Data));//4.0.23.1650  TD 321885
			memset(info.CardSaleExtraData3.sFlags1 , ' ' ,sizeof(info.CardSaleExtraData3.sFlags1));    //4.0.28.503 - TD 263766
			memset(info.CardSaleExtraData6.sClubCardHashNumber, ' ', sizeof(info.CardSaleExtraData6.sClubCardHashNumber));  // 4.0.32.??? TD 405435
			bChange =TRUE;
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,"CServerMain::ClearLoyaltyInfo, Loyalty ID was initialized");
		}

		if (bChange)
		{		
			m_cPumpArray[lPumpNumber-1].SetPAPInfo(&info);
			SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);


		}
	}

	return (lRetCode);
}

//4.0.2.15
BOOL CServerMain::UseSingleSession()
{
	return((m_dwDebitSingleSession)? TRUE :FALSE);
}
//4.0.2.15

/******************************************************************************
 Description:	Close fuel shift, 
				The method is generic to GCI and CTRL interface, so any change must be done in both method.

 Returns:      	Ctrl ret code

 Parameters:   	short nDayOfWeek,  - Set shift to  special days (1-7). 
				short nShiftNumber - Update Shift number   
				short nShiftFlags  - Shift operation see table #001
				BSTR  sStartTime,  - Date and time to start Future shift YYYYMMDDHHMMSS.
				long *pVal	 	   - CTRL ret code 

 
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			1/1/2003   15:06		Start
******************************************************************************/
void CServerMain::SetShift(short nDayOfWeek, short nShiftNumber, short nShiftFlags, BSTR &sStartTime, long *pVal, long &lQdx)
{
	long	lRtc = 0;
	long	retCode = CTRL_OK;
	CString str;  //4.0.2.23
	long	lAlarmRetCode = 0;
	
	if (FALSE == _Module.m_server.DBConnectionAvailable())
		retCode = CTRL_FAILED_IO;
	else if (SERVER_NOT_IDLE)			//4.0.17.20 - TD 45270
		retCode = CTRL_SERVER_NOT_READY;

	m_cLogger.LogFlagsMsg(0,LOG_NONE,"CServerMain::SetShift insert method with  ",nShiftFlags);
	 //CR_475695_Start
	if (nShiftFlags & SET_SHIFT_WITH_EOD)  
	{
		m_cLogger.LogFlagsMsg(0,LOG_NONE,"CServerMain::SetShift insert  with EOD flag.",nShiftFlags);
	}
	 //CR_475695_End
		
	SERVER_INFO sInfo;
	m_cServerInfo.GetInfo(sInfo); //4.0.8.500
	
	long lTankNumber;
	if ( sInfo.byRequiredMaintenanceProcess  || sInfo.byDeliveryEmulationStatus != DES_IDLE || sInfo.byMemoInProcess || m_cCommonFunction.IsDeliveryEmulationSingleTankInProcess(lTankNumber)) // TD 257668 4.0.28.502
	{
		if(sInfo.byRequiredMaintenanceProcess != MP_EMERGENCY_LOCK)
		{
			retCode = CTRL_IN_MIDDLE_OF_PROCESS;
			_LOGMSG.LogMiddleOfProcessReason();//4.0.2.31
		}
		else
		{
			retCode = CTRL_FORECOURT_EMERGENCY_LOCKED;
			_LOGMSG.LogMsg("Shift can't start - Forecourt is emergency locked and must be emergency unlocked");  //4.0.5.35
		}
	}
	//4.0.13.501
	//The WetStockFlags are on, return CTRL_OK, and perform the shift process when possible. 
	else if (sInfo.lWetStockFlags)
	{
		retCode = IN_MIDDLE_OF_WET_STOCK; //Temp return code that will be changed to CTRL_OK before the end of the method.   
		_LOGMSG.LogMsg("Shift can't start yet, wet stock is on, waiting to start set shift after the end of the wet stock process.");  //4.0.5.35
	}

	if(	retCode == CTRL_OK || retCode == IN_MIDDLE_OF_WET_STOCK)
	{
 
		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		//M.L 16.7.98 
		// Check first if in a middle of shift change.

		if(LOG_BASIC_FLOW_CONTROL)
		{
			if(nShiftFlags & SET_SHIFT_TO_CURRENT_TIME)
				_LOGMSG.LogMsg("^^^ SHIFT ^^^ SetShift to current time");		
			else
				_LOGMSG.LogMsg("^^^ SHIFT ^^^ SetShift to future time");		
		}


		// Get the Shift Lock Parameter 
		DWORD dwLock;
		m_cParam.LoadParam("GeneralParam", "ShiftLock",&dwLock,(DWORD)1, FALSE);	
		
		
		//  force system to lock site  //4.0.5.39
		if ((FORCE_LOCK_FORECOURT_IGNORE_CURRENT_SETTING & nShiftFlags))
			dwLock = 1; 		
		else
			//4.0.12.510
			if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) 
				nShiftFlags |= FORCE_LOCK_FORECOURT_IGNORE_CURRENT_SETTING;


		if(  (!(nShiftFlags & REMOVE_SHIFT)) &&
			 (IsShiftChangeInProgress()) 
			)
		{
			retCode = CTRL_IN_MIDDLE_OF_SHIFT;
		}
		else if ((dwLock) && (!(nShiftFlags & FORCE_NON_LOCK)) )
		{
			// If required to do a shift change now - 
			// than check if possiable and report back.
			
			if(nShiftFlags & SET_SHIFT_TO_CURRENT_TIME)
			{		
				// 4.0.2.23
				CPumpStatus stat;			
				CPumpTransact		trs	;  
				PAY_AT_PUMP_INFO	info;
				// 4.0.2.23

				for (int p = 0; p < GetLastValidPump(); p++)  //4.0.0.79
				{

					//4.0.3.50
					short nPrePayWaiting, nFree, nUnpaid;
					m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting,&nFree,&nUnpaid);
					nPrePayWaiting = m_cPumpArray[p].GetNumberOfNonClosedPrePay();
					if(nPrePayWaiting!=0)
					{
						//4.0.10.505
						if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) 
							retCode = CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE;
						else
						{
							//4.0.10.505
							retCode = CTRL_OPEN_PRE_PAY_TRS;
							break; 
						}
					}			
					else if(nUnpaid!=0)
					{
						//4.0.10.505
						if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) 
							retCode = CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE;
						else
						{	// 4.0.10.505
							retCode = CTRL_OPEN_PAY_AT_KIOSK_TRS;
							break;
						}
					}
					//+++++++++++4.0.3.350


					//4.0.5.11
					trs.SetLink(TRS_LINK_OLA_NUMBER, 0);
					memset(&info,' ',sizeof(info));  //4.0.15.11
					lRtc = TrsLinkOperation(REC_READ_FIRST,&trs,&info);

					if(lRtc == OK) 
					{
						if( nShiftFlags & FORCE_SHIFT_OLA_NOT_EMPTY )//4.0.3.39
						{
							str.Format("SetShift: Force continue,Pump %02d has open PAP Trs in qdex",p+1);
							m_cLogger.LogMsg(str);
							//here to add log writing and alarm.
							lAlarmRetCode = m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,PAP_TRS_IN_OLA_QDX,p + 1,ALARM_ON,p + 1,0);
							//continue; 
						}
						else
						{
							if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) 
								retCode = CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE;
							else
							{	
								retCode = CTRL_OPEN_PAY_AT_PUMP_TRS;
								break;
							}	
						}
					}
					else if((lRtc != ERR_NOT_FOUND)&&(lRtc != ERR_DELETED))					
					{
		 				retCode = CTRL_FAILED_IO;
						break;
					}				
					else	//4.0.19.505
					{//Empty OLA qdx- delete all loyalty xmls
						if (!(m_cCommonFunction.DeleteAllLoyaltyXmls()))
						{
							str.Format("SetShift: Empty OLA qdx- Failed to delete all loyalty xmls.");
							m_cLogger.LogMsg(str);
						}
						else
						{
							str.Format("SetShift: Empty OLA qdx- all loyalty xmls were deleted.");
							m_cLogger.LogMsg(str);
						}
					}

					stat = m_cPumpArray[p].GetStat();

					if( (stat.GetStatus() == OUT_OF_SERVICE) ||
						(stat.GetStatus() == UNKNOWN_STATUS) ||
						(stat.GetStatus() == COMMS_TERMINATED) )
					{
						continue;
					}
					else if  (  (!m_cPumpArray[p].CanReserve()) &&
								( stat.GetRes() != PUMPSRV)	 )	
					{
						str.Format("SetShift: Pump %02d isn't ready",p+1);
						m_cLogger.LogMsg(str);
						//4.0.10.500 amram check the flag 
						//if on then we will start lock pumps and return the new ret code
						//else we continue the origanl flow and return without lock pumps
						if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) {
							retCode = CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE;
							str.Format("SetShift: Pump %02d isn't ready But Igonre it and Lock Pumps",p+1);
							m_cLogger.LogMsg(str);
						}
						else
						{
							retCode = CTRL_PUMP_NOT_READY; // pump not ready - either authorized or requesting or dispensing 
							break;
						}	 	
					}
				}
			}
			else if((nDayOfWeek > 7) || (nDayOfWeek < 1))
			{
				retCode = CTRL_INVALID_DAYOFWEEK;
			}
		}


		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
	}
	//amram TD 14801 4.0.10.501
	if((retCode == CTRL_OK)||(retCode == CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE)||(retCode == IN_MIDDLE_OF_WET_STOCK))
	{
		CString sTableName;
		sTableName = "Shifts\\";
		if(GetShiftMode() == SHIFT_MODE_SINGLE)
		{
			sTableName += "Day8\\Shift1";
		}
		else
		{
			sTableName += "Day";
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%d",nDayOfWeek);
			sTableName += sNumber;
			sTableName += "\\Shift";
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%d",nShiftNumber);
			sTableName += sNumber;
		}

		if(nShiftFlags & REMOVE_SHIFT)
		{
			m_cParam.SaveParam((char *)((LPCTSTR)sTableName) , "ValidEntry", (DWORD)0L);
		}
		else 
		{
			SZ_TAG_SYSTEMTIME szTagTime;
			szTagTime.sNull = 0;

			if(nShiftFlags & SET_SHIFT_TO_CURRENT_TIME)
			{
				SYSTEMTIME systime;
				GetLocalTime(&systime);
				SystemTime2Tag(&systime,&szTagTime.sTime);
			}
			else
			{
				int iLen = WideCharToMultiByte(CP_ACP,0,sStartTime,-1,(char *)&szTagTime,sizeof(SZ_TAG_SYSTEMTIME),NULL,NULL);			
				if(iLen == 0)
				{					
					lRtc = (long)GetLastError();
					str.Format("SetShift, Error parsing shift time  Error=%ld" , lRtc) ;   //4.0.2.23
					retCode = CTRL_LAST_ERROR;
				}
			}
		 
			if((retCode == CTRL_OK)||(retCode == CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE)||(retCode == IN_MIDDLE_OF_WET_STOCK))
			{
				m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "StartTime",(char *)&szTagTime,TRUE,0,0,0,TRUE); //4.0.8.503
				if(nShiftFlags & DO_PUMP_TOTALS)
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReadPumpTotals",(DWORD)1);
				else
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReadPumpTotals",(DWORD)0);

				if(nShiftFlags & DO_TANK_READING)
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReadTanks",(DWORD)1);
				else	
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReadTanks",(DWORD)0);

				// 2.9.2.1 start
				if(nShiftFlags & DO_FORCE_LOCK_PUMP)
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "LockForeCourt",(DWORD)1);
				else	
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "LockForeCourt",(DWORD)0);
				// 2.9.2.1 end				

				
				if( nShiftFlags & FORCE_SHIFT_OLA_NOT_EMPTY )//4.0.3.39
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ForceShiftOLA",(DWORD)1);
				else	
					 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ForceShiftOLA",(DWORD)0);

				
				//4.0.3.60
				if(nShiftFlags & DO_RECONCILIATION)
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReconcileTankSrv",(DWORD)1);
				else	
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ReconcileTankSrv",(DWORD)0);

				if(nShiftFlags & FORCE_LOCK_FORECOURT_IGNORE_CURRENT_SETTING) //4.0.5.9
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftLock",(DWORD)1);
				else	
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftLock",(DWORD)0);
				// CR_475695_Start
				if(nShiftFlags & SET_SHIFT_WITH_EOD)  
					_Module.m_server.m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftEOD",(DWORD)1);
				else	
					_Module.m_server.m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftEOD",(DWORD)0);
				//CR_475695_End
				//4.0.10.505 amram save the flag if we lock pumps that not idle
				if(nShiftFlags & DO_MAINTENANCE_LOCK_FORECOURT) //4.0.5.9
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftLockDuringProcess",(DWORD)1);
				else	
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ShiftLockDuringProcess",(DWORD)0);

				//4.0.5550.1504
				if(nShiftFlags & DO_DATABASE_MAINTENANCE) 
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "DataBaseMaintenance",(DWORD)1);
				else	
					m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "DataBaseMaintenance",(DWORD)0);

				//4.0.26.508 TD 146575
				DWORD dwTmp = (nShiftFlags & SET_SHIFT_EXPORT_SITE_CONFIG) ? 1 : 0;										
				m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ExportSiteConfig", dwTmp);	


				 m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "ValidEntry",(DWORD)1);
			}
		}

		//amram TD 14801 4.0.10.501
		if((retCode == CTRL_OK)||(retCode == CTRL_SHIFT_START_WITH_PUMP_NOT_IDLE)||(retCode == IN_MIDDLE_OF_WET_STOCK))
		{
			// Immidiate check...
			if(nShiftFlags & SET_SHIFT_TO_CURRENT_TIME)
			{
				m_cServerInfo.GetInfo(sInfo); //4.0.8.500
				
				// in case PumpSrv was lock to maintenance, Set the server to Idle to start shift.
				if ((sInfo.lockStatus == LOCKED) && (sInfo.lockResExt == MAINTENANCE))  //3.0.1.84
				{
					SetServerLockStatus(UNLOCK);

					_LOGMSG.LogMsg("^^^ SHIFT ^^^  Change Server state from Lock for MAINTENANCE to unlock ");
					//m_cParam.SaveParam((char *)((LPCTSTR)sTableName), "LockForeCourt",(DWORD)1); //4.0.31.0
				}
	
				if(!sInfo.bRequiredPriceChange)
				{

					//4.0.13.501
					if (retCode != IN_MIDDLE_OF_WET_STOCK)
					{
						if(nShiftFlags & FORCE_NON_LOCK)				
						{
							_LOGMSG.LogMsg("^^^ SHIFT ^^^ FORCE_NON_LOCK !!!!!");
							CheckShiftChange(TRUE);
						}
						else
							CheckShiftChange(FALSE);
					}
					else
					//will be called later, after the end of the wet stock
					{
						if(nShiftFlags & FORCE_NON_LOCK)				
							SetRcvSetShiftCommand(RCV_WITH_FORCE_NON_LOCK);
						else
							SetRcvSetShiftCommand(RCV_WITH_NO_FORCE_NON_LOCK);
					}
				}
				
				if(LOG_BASIC_FLOW_CONTROL)
				{
					str.Format("^^^ SHIFT ^^^ RequiredShiftProcess = %d",sInfo.bRequiredShiftProcess);
					_LOGMSG.LogMsg(str);
					str.Format("^^^ SHIFT ^^^ ShiftChangeLock = %d",sInfo.bShiftChangeLock);
					_LOGMSG.LogMsg(str);

					switch(sInfo.lShiftChangeState)
					{
						case CHANGE_START:
							_LOGMSG.LogMsg("^^^ SHIFT ^^^ ShiftChangeState = CHANGE_START");
							break;
						case CHANGE_IN_PROGRESS:
							_LOGMSG.LogMsg("^^^ SHIFT ^^^ ShiftChangeState = CHANGE_IN_PROGRESS");
							break;
						case CHANGE_DONE:
							_LOGMSG.LogMsg("^^^ SHIFT ^^^ ShiftChangeState = CHANGE_DONE");
							break;
						case CHANGE_WAIT_NEXT:
							_LOGMSG.LogMsg("^^^ SHIFT ^^^ ShiftChangeState = CHANGE_WAIT_NEXT");
							break;
					}

				}
			}
		}
	}
	
	//4.0.14.501
	if (nShiftFlags & DO_GET_DEVICES_VERSIONS)
	{
		SetCommand(CMD_GENERAL_SYSTEM_EVENT,0,GCI_EVENT_GET_VERSION);
	}
	//4.0.19.502 - CR 58096
	else if(nShiftFlags & DO_OLA_CLOSE_BATCH)
	{
		SetCommand(CMD_GENERAL_SYSTEM_EVENT,0,GCI_EVENT_OLA_CLOSE_BATCH);
	}
	
	//4.0.13.501
	//If we are in the middle of wet stock - return OK, and perform the shift process when possible.
	if (retCode == IN_MIDDLE_OF_WET_STOCK)
	{
		retCode = CTRL_OK;
	}

	//4.0.20.54 - start
	if(nShiftFlags & SET_SHIFT_REPORT_OFFLINE_TRS_IF_EXIST)
	{
		if (retCode == CTRL_OK)
		{
			if(GetOfflineTrsInShift() == TRUE)
			{
				retCode = CTRL_SHIFT_WITH_OFFLINE_TRS; //There are offline transactions waiting in OLA qdx !
				_LOGMSG.LogMsg("^^^ SHIFT ^^^ Found offline trs in shift.");

				SetOfflineTrsInShift(FALSE);
				m_cParam.SaveParam("GeneralParam","OfflineTrsInShift",(DWORD)0,FALSE,0,0,0,TRUE);
				
			}
		}
	} //4.0.20.54 - end

	*pVal = retCode;
	lQdx = lRtc;
}

//4.0.2.23
long CServerMain::GetMinFullingToChargeServiceFee()
{
	return m_lMinFullingToChargeServiceFee;
}

BOOL CServerMain::ISPAKFinalizationAllowedWhenSystemDown(long lPumpNumber)
{
	//P@K finalization is allowed when two conditions are met:
	//1. m_bAllowPAKFinalizationWhenSytemDown is set to TRUE.
	//2. Unpaid P@K transactions exist.
	//If one of these conditions is not satisfied,
	//P@K finalization is not allowed, and the system reverts to the 
	//old flow.

	short nWaiting = 0 , nFree = 0 , nUnpaid = 0 , nTmp = 0;

	int iPumpIndex = 0 , iLastPump = m_lLastValidPump;

	if(lPumpNumber)
	{
		iPumpIndex = lPumpNumber - 1;
		iLastPump = lPumpNumber;
	}

	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	for(int p = iPumpIndex;p < iLastPump;p++)
	{
		m_cPumpArray[p].GetTrsListCount(&nWaiting , &nFree , &nTmp);
		nUnpaid += nTmp;
	}

	
	return (nUnpaid && m_bAllowPAKFinalizationWhenSytemDown);
}

BOOL CServerMain::SetPAKFinalizationAllowedWhenSystemDown(BOOL bAllowed)
{
	short nWaiting = 0 , nFree = 0 , nUnpaid = 0 , nTmp = 0;

	m_bAllowPAKFinalizationWhenSytemDown = bAllowed;

	if(bAllowed)
	{
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		for(int p = 0;p < m_lLastValidPump;p++)
		{
			m_cPumpArray[p].GetTrsListCount(&nWaiting , &nFree , &nTmp);
			nUnpaid += nTmp;
		}

		if(nUnpaid)
			m_bAllowPAKFinalizationWhenSytemDown = TRUE;

		else
			m_bAllowPAKFinalizationWhenSytemDown = FALSE;
	}
	
	return m_bAllowPAKFinalizationWhenSytemDown;
}
//4.0.2.23

// 4.0.5.44
/******************************************************************************
 Description:	Checking if at least one printer is connected to a POS 
 Returns:       BOOL 	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Udi F			13/06/2004   12:39 		Start
 Marik			22/06/2004	 17:09      fixed - add logs
******************************************************************************/
BOOL CServerMain::IsPrinterConnected() 
{
	CString sMsg;
	//The bPrinterConnected variable will be FALSE unless a connected printer is found
	BOOL bPrinterConnected = FALSE;
	
	CPosInfo tmpPos;
	POSITION position = m_cPosMap.GetStartPosition();
	long lTmpPOSNumber = 0;

	while(position)
	{
		//Going over all the POSes connected  
		m_cPosMap.GetNextAssoc(position,lTmpPOSNumber,tmpPos);
		//Checking for each Pos if a printer is connected to it. If one or more is
		//connected then we'll return TRUE. Else we'll return FALSE
		if (tmpPos.GetPrinterStatus() == PRINTER_ONLINE)
		{
			bPrinterConnected = TRUE;
			break;
		}		
	}

	if(bPrinterConnected )  
		sMsg.Format("A printer is connected to Pos number %d", lTmpPOSNumber );
	else
		sMsg.Format("No printer is connected to any Pos");
	
	m_cLogger.LogMsg(sMsg);

	return(bPrinterConnected);
}

//4.0.2.24
void CServerMain::LogServerStatsOnStartup()
{
	SERVER_INFO m_cInfo;  //4.0.8.500
	CString str;
	str = "Server Lock State: ";

	m_cServerInfo.GetInfo(m_cInfo);



	switch(m_cInfo.lockStatus)
	{
		case STARTED: str += "STARTED"; break;
		case WAIT_LOCK: str += "WAIT_LOCK"; break;
		case LOCKED: str += "LOCKED"; break;
		case WAIT_RESPONSE: str += "WAIT_RESPONSE"; break;
		case RESPONSE_RECEIVED: str += "RESPONSE_RECEIVED"; break;
		case UNLOCK: str += "UNLOCK"; break;
	}
		
	if(m_cInfo.lockResExt & PRICE_CHANGE)
		str += " (PRICE_CHANGE) ";
	
	if(m_cInfo.lockResExt & TANK_READING)
		str += " (TANK_READING) ";
	
	if(m_cInfo.lockResExt & PUMP_TOTALS_READING)
		str += " (PUMP_TOTALS_READING) ";
		
	if(m_cInfo.lockResExt & SHIFT_CHANGE)
		str += " (SHIFT_CHANGE) ";
	
	if(m_cInfo.lockResExt & MAINTENANCE)
		str += " (MAINTENANCE) ";

	if(m_cInfo.lockResExt & FORCE_SHIFT_OLA)   //4.0.3.39
		str += " (FORCE SHIFT OLA) ";

			
	m_cLogger.LogMsg( str );


	str.Format ("Server Flags: bRequiredShiftProcess - %d, lShiftChangeState - %d, bRequiredPriceChange - %d, lPriceChangeState - %d", 
				m_cInfo.bRequiredShiftProcess,		
				m_cInfo.lShiftChangeState,
				m_cInfo.bRequiredPriceChange,
				m_cInfo.lPriceChangeState);
	m_cLogger.LogMsg(str);

	str.Format("Server Active shift number %d , Formal shift number %d ",m_cCurrentShift.dwActiveShiftNumber,m_cCurrentShift.dwFormalShiftNumber);
	m_cLogger.LogMsg(str);

	return;
}
//4.0.2.24

/******************************************************************************
 Description:	Maintenance  Server , Lock/unlock 	
 Returns:      	GciRetCode]
 Parameters:   	long lLock, long lParam, long *pVal

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			24/2/2003   12:55		Start
******************************************************************************/
//4.0.2.36
void CServerMain::SetMaintenance(long lLock, long lParam, long *pVal)
{
	CtrlRetCode retCode = CTRL_OK;	
	SERVER_INFO sInfo;
	CString str;

	if (SERVER_STATE_STARTUP)
		retCode = CTRL_CONTROLLER_NOT_AVAILABLE;

	else if (SERVER_NOT_IDLE)
		retCode = CTRL_SERVER_NOT_READY;

	else if ( 
			  !((lLock & MP_LOCK) || 
		       (lLock & MP_UNLOCK) || 
			   (lLock & MP_FORCED_UNLOCK)) //4.0.14.501
			)
		retCode = CTRL_INVALID_LOCK_OPTION;

	//For unlock - check if the lock was made by ups, the unlock will be activate only if it is by ups.   
	else if (lLock == MP_UNLOCK)
	{
		//if the lock were by ups and the unlock is not by ups, return error code.   
		if (m_cServerInfo.GetLockByUpsFlags())	
			retCode = CTRL_INVALID_LOCK_OPTION;

		//4.0.19.504 - TD 60460
		if (m_cServerInfo.GetServerReservation() & EMERGENCY_LOCK)
			retCode = CTRL_INVALID_LOCK_OPTION;
	}
	else if (lLock == (MP_UNLOCK + MP_LOCK_BY_UPS))
	{
		//if the lock were not by the ups and the unlock is by ups, return error code.   
		if (!(m_cServerInfo.GetLockByUpsFlags()))	
			retCode = CTRL_INVALID_LOCK_OPTION;
	}
	else if (lLock == MP_LOCK) //4.0.19.504 - TD 60460
	{
		if (m_cServerInfo.GetServerReservation() & EMERGENCY_LOCK)
			retCode = CTRL_INVALID_LOCK_OPTION;
	}

	if(retCode == CTRL_OK)
	{

		CString str;
		str.Format("SetMaintenance with lock option=%ld",lLock);
		_LOGMSG.LogMsg(str);

		m_cServerInfo.GetInfo(sInfo);
	
		//Should we check here also the single tank process - 66935 *?*? - yes (loop)
		//But what should be the condition exactly *?*?
		if ((sInfo.bRequiredShiftProcess || (sInfo.byDeliveryEmulationStatus != DES_IDLE  &&  (!(lLock & MP_FORCED_UNLOCK)) )  || sInfo.bRequiredPriceChange //4.0.13.230
			|| (sInfo.byRequiredMaintenanceProcess && (!(lLock & MP_FORCED_UNLOCK))))
			&& (!(lLock & MP_LOCK_BY_UPS))) //4.0.13.260
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{
				str.Format("CTRL::SetMaintenance status=%ld bRequiredShiftProcess=%d , bRequiredPriceChange=%d, bRequiredModeProcess=%d , byRequiredMaintenanceProcess=%d",
				lLock, sInfo.bRequiredShiftProcess , sInfo.bRequiredPriceChange , sInfo.bRequiredModeProcess , sInfo.byRequiredMaintenanceProcess);
				_LOGMSG.LogMsg(str);
			}
				
			retCode = CTRL_IN_MIDDLE_OF_PROCESS;
			_LOGMSG.LogMiddleOfProcessReason();//4.0.2.31
		}

		//4.0.14.840 - TD 49399
		if(retCode == CTRL_OK) 
		{
			if (((lLock & MP_LOCK) && (m_cServerInfo.GetRequiredMaintenanceProcessFlags())) ||
				((lLock & MP_UNLOCK) && (m_cServerInfo.GetRequiredMaintenanceProcessFlags()) && (m_cServerInfo.GetServerStatus() == STARTED))) //4.0.21.500 - TD 70312
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					str.Format("CTRL::SetMaintenance Lock status=%ld, byRequiredMaintenanceProcess=%d", lLock, sInfo.byRequiredMaintenanceProcess);
					_LOGMSG.LogMsg(str);
				}

				retCode = CTRL_IN_MIDDLE_OF_PROCESS;
				_LOGMSG.LogMiddleOfProcessReason();
			}
		}

		if(retCode == CTRL_OK)
		{
			if(lLock == MP_FORCED_UNLOCK)			//4.0.1.38 
			{
				if(LOG_DETAIL_FLOW_CONTROL)
					_LOGMSG.LogMsg("SetMaintenance called with lLock = MP_FORCED_UNLOCK");
			}


			m_cServerInfo.SetRequiredMaintenanceProcessFlags(lLock - (lLock & MP_LOCK_BY_UPS));	

			if (lLock == (MP_LOCK + MP_LOCK_BY_UPS))
				m_cServerInfo.SetLockByUpsFlags(((lLock & MP_LOCK_BY_UPS) > 0)?TRUE:FALSE);	
			else
				m_cServerInfo.SetLockByUpsFlags(MP_NONE);	

			CString strLog;
			strLog.Format("SetMaintenance, Set Server Info. Delivery Status: %d, Delivery Process: %d.", 
				m_cServerInfo.GetDeliveryEmulationStatus(), 
				m_cServerInfo.GetRequiredModeProcessFlags());
			_LOGMSG.LogMsg(strLog);

			SetServerLockStatus(IGNORE_LOCK_STATUS);
		}
	}
		

	*pVal= retCode;
}
//4.0.2.36
//4.0.2.36
/******************************************************************************
 Description:	Save receipt data on Debit decline or on zero trs receipt	
 Returns:      	TRUE/FALSE
 Parameters:   	BYTE bySessionType
				long lValue, 
				long lVolume , 
				BYTE byTransType  == Session debit
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			27/2/2003   16:18		Start
 Ella			26/12/2006	18:00		Change
******************************************************************************/
BOOL CServerMain::IsNeedSaveZeroCompleteData(short bySessionType, long lValue, long lVolume , BYTE byTransType)
{
	BOOL bRet = FALSE;

	if (!m_dwSaveDebitZeroCompleteData && !m_dwPrintZeroTrsReceipts) // 4.0.15.504 - TD 38453
		return  FALSE;
  
	if (m_dwSaveDebitZeroCompleteData) // 4.0.15.504 - TD 38453
	{
		if ((SESSION_TYPE(bySessionType) == SESSION_COMPLETE) && 
		   (!lValue) &&
		   (!lVolume) && 
		   (byTransType == CD_TYPE_DEBIT))

			bRet =TRUE;
		else
			bRet = FALSE;
	}

	// 4.0.15.504 - TD 38453
	if (!bRet)
	{
		if (m_dwPrintZeroTrsReceipts && 
			(SESSION_TYPE(bySessionType) == SESSION_COMPLETE) && 
			(!lValue) && 
			(!lVolume) )

			bRet = TRUE;
		else
			bRet = FALSE;

	}

  return bRet;


}
//4.0.2.36

/******************************************************************************
 Description:	Process alarm data 	
 Returns:      	TRUE
 Parameters:   	CAlarmSrvQueueData & cAlarmSrvQueueData
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			30/3/2003   18:59		Start
******************************************************************************/
BOOL CServerMain::ProcessAlarmCommand(CAlarmSrvQueueData & cAlarmSrvQueueData)
{
	switch(cAlarmSrvQueueData.GetCommand())
	{
		case SEND_TO_ALARM_SRV: 
		{
			 m_cAlarm.SendAlarmToAlarmSrv(cAlarmSrvQueueData);
		}						
		break;
		case RECEIVED_TO_ALARM_SRV:
		{							
			// update Alarm map . 
			if (cAlarmSrvQueueData.GetStatus() == ALARM_ENDED)								
				m_cAlarm.DecreaseAlarmNumerator(cAlarmSrvQueueData);
			else  if (cAlarmSrvQueueData.GetStatus() == ALARM_STARTED)	
				m_cAlarm.AddAlarmNumerator(cAlarmSrvQueueData);								
		}
		break;
		default:
			break;
	}
		
	if(LOG_BASIC_FLOW_CONTROL)
	{	
		char sStr[MAX_FIELD_VAL];
		sprintf_s(sStr, _countof(sStr),"Remove Alarm Type=%d",cAlarmSrvQueueData.GetCommand());
		_LOGMSG.LogMsg(sStr,LOG_LEVEL_3);			
	}


	return TRUE;

}

DWORD CServerMain::GetLockOnStopAll()
{
	DWORD dwRetVal = 0;
	m_cParam.LoadParam("GeneralParam",
		               "LockOnStopAll",
					   &dwRetVal,
					   (DWORD)0,
					   TRUE);

	return dwRetVal;
}

void CServerMain::SendCardInfoResult(short byOlaStat,long lPumpNumber, long lAnswer,unsigned char sTranStatus, CARD_SALE_ALL3 *pData, CPumpTransact *pTrs)
{	
	CMD_STRUCT_CARD_INFO_RESULT_XML cmdInfo;

	memset(&cmdInfo , ' ', sizeof(CMD_STRUCT_CARD_INFO_RESULT_XML));
	cmdInfo.lDeviceNumber = 0; // not supprted (OPT)
	cmdInfo.lSeqNumber = a2l(pData->CardSaleAll.data.sTranNbr,sizeof(pData->CardSaleAll.data.sTranNbr));
	cmdInfo.lAnswer = lAnswer;

	if (GetOLAFlags(pData->extData2.sFlags ,FL_PAP_AS_THIRD_REC))
	{
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA3;   //3.0.0.0 STRUCT_IS_CARD_SALE_DATA;
		//cmdInfo.extData3 = pData->extData3;
	}
	else
		cmdInfo.lFlags	= STRUCT_IS_CARD_ALL_DATA2;

	//4.0.18.501
	memset(cmdInfo.data, 0, sizeof(cmdInfo.data));
	m_cXmlConvertorEx.ConvertFromStructToXml((char *)cmdInfo.data, pData);

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("OLA at pump %02d, SendCardInfoResult:%ld ,flags=%ld ",lPumpNumber,lAnswer, cmdInfo.lFlags);
		m_cLogger.LogMsg(str);
	}	

	SetCommand(CMD_CARD_INFO_RESULT, 
		SERVER_POS_NUMBER, 
		lPumpNumber,
		&cmdInfo,
		sizeof(CMD_STRUCT_CARD_INFO_RESULT_XML));
}

long CServerMain::GetOLAFlags(BYTE *sFlags, long lCondition, long lLen)
{
	return (a2l(sFlags  ,lLen) & lCondition); //4.0.7.501
}

void CServerMain::ServerCleanUp(BOOL bRun)   //4.0.5.30
{
	try
	{
		if (bRun)   //4.0.5.30		
			m_cPumpFile.VerifyFileSignatureAndData();
	
		m_cHydra.CloseConnectionToHydra();//4.0.0.56
		
		CloseOLAThread(TRUE); //4.0.5.24	
	
		if(m_cOLASrv)
			 m_cOLASrv->ReleaseService(FALSE , TRUE);
	
		DeleteEventThreadInfo();
		DeleteAlarmSrvThreadInfo();
	
		if(m_cOLASrv)
		{
			m_cOLASrv->Destruct(); //SR 362184: PumpSrv freeze on COLABase destructor
			delete m_cOLASrv;
			m_cOLASrv = NULL;
			m_cLogger.LogMsg("OLASrv released successfully.");
		}
	
		if(m_cBaseReceipt)
		{
			delete m_cBaseReceipt;
			m_cBaseReceipt = NULL;
			m_cLogger.LogMsg("BaseReceipt released successfully.");
		}
	
		SetServerState(SERVER_NO_CONVERT);
		DisconnectFromVp();						//4.0.5.42	//4.0.1.38
		DataExportCleanUp(FALSE);					//4.0.5.42

		DeleteVPThreadInfo();
		CloseConnectToIFSFTerminalSrv(); //4.0.20.500 TD 58220	
		FuelMobileSrvThreadCleanUp();
		CloseConnectToFuelMobileSrv();// CR 474446	
		CloseConnectionToAlarmSrv();
		CloseConnectionToEncryptDll();//4.0.9.508	
		m_cFuelLoayaltyPS.ReleaseFuelLoyalty();//4.0.9.509
	
		QDXMaintenanceThreadCleanUp(); //4.0.18.0
	
		CleanUpConfigurationThread();							//4.0.22.45 TD 72716
		m_cFuelingRestriction.CleanUp();		//4.0.22.501 TD 70956

		if (bRun)
		{
			CPumpSrvDatabase & PumpSrvDatabase = CPumpSrvDatabase::GetInstance();
			PumpSrvDatabase.Close();
		}

		//DeleteCriticalSection(&m_csPumpArray);
		DeleteCriticalSection(&m_csMemPumpArray);
		DeleteCriticalSection(&m_csModeSchemeArray);
		DeleteCriticalSection(&m_csReportArray);
		DeleteCriticalSection(&m_csGetCardInfoEx); //4.0.19.0
		DeleteCriticalSection(&m_csNewOLAServer);
		//DeleteCriticalSection(&m_csQDXMaintenance); //4.0.18.0
	
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END OF CLEAN UP SECTION!!!! DON'T ADD AFTER THIS LINE!!!!!!!!!!!!!!!!!!!!!!
		
		if(LOG_BASIC_FLOW_CONTROL)	//4.0.3.45 - be the last log line
		{		
			m_cLogger.LogMsg("Server Ended !");
		}
	
		if (!bRun)  //4.0.5.38
			m_cLogger.LogMsg("PumpSrv registration complete !!!!");
	
		m_cLogger.SystemDown();
	}
	catch (...)
	{
		//SR 362184: PumpSrv freeze on COLABase destructor
		CString str;
		str.Format("CServerMain::ServerCleanUp: exception in termination!!! exiting");
		m_cLogger.LogMsg(str);	
		exit(1);
	}
}

//4.0.3.32
long CServerMain::GetPrePayLimit()
{
	return m_dwPrePayLimit * 1000;
}

void CServerMain::SetPrePayLimit(long lPrePayLimit)
{
	m_dwPrePayLimit = lPrePayLimit;
}


/******************************************************************************
 Description:	Checks if the prepay is unbalanced 	
 Returns:      	BOOL - TRUE - Unbalanced prepay
 Parameters:   	CPumpTransact *pPumpTrs - TRS data
				PRE_PAY_INFO *pPrepayInfo - prepay data.
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			1/7/2003   9:29		Start 4.0.3.37
******************************************************************************/
BOOL CServerMain::IsUnbalancedPrepay(CPumpTransact *pPumpTrs, PRE_PAY_INFO *pPrepayInfo)
{
	BOOL bUnBalanced = FALSE;
	long lVal = 0;
	long lRetVal = 0;

	GetServiceFeeInfo(pPumpTrs->m_lPump,SERVICE_TYPE_PREPAY,0,NULL,GET_FEE_BY_TRANSACTION_TYPE,&lVal,&lRetVal); //marik12345		

	if(pPumpTrs->m_lStatus == PAID)
	{
		if ( (pPumpTrs->m_lRoundedValue + lVal) < pPrepayInfo->lMaxValue) 
			bUnBalanced = TRUE;	
	}
	
	return bUnBalanced;
}
/******************************************************************************
 Description:	Update loyalty flags 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			9/7/2003   10:31		Start
******************************************************************************/
void CServerMain::SetLoyaltyActivity(long lFlags)
{
	if (lFlags)
		m_bActiveLoyaltyDiscount = TRUE;
	else
		m_bActiveLoyaltyDiscount = FALSE;

}
/******************************************************************************
 Description:	Delete extra info record which connected to OLA transaction  	
 Returns:      	
 Parameters:   	long lSeqNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			20/5/2003   19:21		Start
******************************************************************************/
long CServerMain::DeleteLink2Ola(long lSeqNumber)
{
	PAY_AT_PUMP_INFO	info;
	CPumpTransact cTrsTmp;
	long lRtc = 0;
	
	memset(&info,0,sizeof(PAY_AT_PUMP_INFO));
	cTrsTmp.SetLink(TRS_LINK_OLA_NUMBER, lSeqNumber);				
	lRtc = TrsLinkOperation(REC_READ,&cTrsTmp,&info);
	if(lRtc == OK)
	{
		if (GetOLAFlags(info.CardSaleExtraData2.sFlags , FL_CONNECTED_RECORD_IN_ASH2000_FILE) || GetOLAFlags(info.CardSaleExtraData3.sFlags1, FL_OLA_EXTRA_DATA, sizeof(info.CardSaleExtraData3.sFlags1))) //4.0.24.90 118124
		{		
			ASH2000_REC cAsh2000Rec;
			cAsh2000Rec.lIndexNumber = cTrsTmp.m_lNumber;						
			long lQdxRetVal =0;
			if (lQdxRetVal = IndexOperation(ASH2000_FILE , REC_DELETE,&cAsh2000Rec))
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString tmpStr;
					tmpStr.Format("CGPI::RemovePAPTrs failed=%ld to  delete Record %ld from file ash info" ,   lQdxRetVal  , cTrsTmp.m_lNumber );
					_LOGMSG.LogMsg(tmpStr);
				}
			}
			else
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString tmpStr;
					tmpStr.Format("DeleteLink2Ola, Succeeded delete Ash2000 trs=%ld"  ,lSeqNumber);
					_LOGMSG.LogMsg(tmpStr);
				}

			}
		}
		if(m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())	//4.0.19.505
		{//delete also xml from loyalty on the disk
			m_cCommonFunction.DeleteLoyaltyXmslFile(cTrsTmp.m_lPump, cTrsTmp.m_lNumber);
		}
	}
	return 0;
}

//4.0.24.100 118124
long CServerMain::DeleteFromAsh2000Qdx(long lTrsNumber)
{
	
	ASH2000_REC cAsh2000Rec;
	cAsh2000Rec.lIndexNumber = lTrsNumber;						
	long lQdxRetVal =0;

	lQdxRetVal = IndexOperation(ASH2000_FILE , REC_READ,&cAsh2000Rec);

	if (!lQdxRetVal) //Record exists -> delete it
	{
		 lQdxRetVal = IndexOperation(ASH2000_FILE , REC_DELETE,&cAsh2000Rec);
		
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString tmpStr;
			tmpStr.Format("DeleteFromAsh2000Qdx record = %ld, retCode = %ld" ,  lTrsNumber, lQdxRetVal );
			_LOGMSG.LogMsg(tmpStr);
		}
	}
	else
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString tmpStr;
			tmpStr.Format("Reading from ash2000 qdx record = %ld, retCode = %ld" ,  lTrsNumber, lQdxRetVal );
			_LOGMSG.LogMsg(tmpStr);
		}

	}
			
	return 0;
}

/******************************************************************************
 Description: update PreSet limitation flags
 Returns:     Active/Not active
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			24/7/2003   11:18		Start
******************************************************************************/
BOOL CServerMain::LimitedPreSet()
{
	return (m_dwForcePreSetToSiteLimit)? TRUE:FALSE;
}

/******************************************************************************
 Description:	Returns the HotPumping general parameter 	
 Returns:      	BOOL
 Parameters:   	None.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			5/8/2003   15:40		Start 4.0.3.45
******************************************************************************/
BOOL CServerMain::IsHotPumpingActive()
{
	return m_dwHotPumping;
}

/******************************************************************************
 Description:	Update parameter AutoTimerChecker 	
 Returns:      	None
 Parameters:    lVal - parameter new data
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			25/8/2003   15:03		Start
******************************************************************************/

void CServerMain::SetAutoTimeChecker(long lVal)
{
	//4.0.3.49
	m_bAutoTimeCheck = (lVal)?TRUE:FALSE;
}

/******************************************************************************
 Description:	The main state machine mehtod for the Lock pump process
				by mode scheme process.
 Returns:      	long
 Parameters:   	None.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:50		Start
******************************************************************************/
long CServerMain::DoAutomaticLockPumpByMode()
{
	long lRetVal = 0;
	long lPumpNumber = 0;
	PumpLockType eLockType = LOCK_TYPE_MAINT;
	
	//if reserved by pumpsrv ignore process until will be released
	if( ! ((m_cServerInfo.GetServerReservation() & MAINTENANCE) || (m_cServerInfo.GetServerReservation() & EMERGENCY_LOCK)) )
	{
		for (int p = 0; p < m_lLastValidPump; p++)
		{
			switch(m_cPumpsLockStateArray[p].GetPumpLockStatus())
			{
				case PM_START_LOCK:
				{
					//already reserved by PumpSrv or in maintanace lock process
					if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) )
					{
						SetLockPumpByModeStatus(p+1, PM_LOCKED);
					}
					else //start the single pump lock process
					{
						if(m_cPumpArray[p].CanReserveForPumpLock(eLockType))  // check if can send reserve pump 
						{
							CMD_STRUCT_RESERVE_PUMP cmdInfo;
							cmdInfo.lRes	= PUMPSRV;
							cmdInfo.lResExt = MAINTENANCE; 
													
							SetCommand(CMD_RESERVE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
							SetLockPumpByModeStatus(p+1, PM_WAIT_LOCK);				
						}
						else if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
								(m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
								(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
								(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) )	
						{
							SetLockPumpByModeStatus(p+1, PM_WAIT_LOCK);					
						}
					}
					break;
				}
				case PM_WAIT_LOCK:
				{
					if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
						(m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
						(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
						(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) )	
					{
						SetLockPumpByModeStatus(p+1, PM_LOCKED);					
					}
					else
					{
						IncreaesPumpByModeRetryCounter(p+1);					
					}
					break;
				}
				case PM_START_UNLOCK:
				{
					//We would start unlocking the pump by mode only if it's
					//not exclusively locked
                    if(!m_cSinglePumpLock.IsExclusivelyLocked(p+1))
					{				
						CMD_STRUCT_RELEASE_PUMP cmdInfo;
						cmdInfo.lRes	= PUMPSRV;				
						cmdInfo.lResExt = MAINTENANCE;
										
						SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RELEASE_PUMP));						
						SetLockPumpByModeStatus(p+1, PM_WAIT_UNLOCK);					
					}				
					
					break;
				}
				case PM_WAIT_UNLOCK:
				{
					if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
					{
						SetLockPumpByModeStatus(p+1, PM_UNLOCK);
					}
					else
					{
						IncreaesPumpByModeRetryCounter(p+1);
					}
					break;
				}
				
				case PM_UNLOCK:
					break;

				case PM_LOCKED:
					//If the pump is supposed to be locked by mode according to the state machine
					//and isn't locked it's a mistake caused somehow and we should lock it
					if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
					{
						if(m_cPumpArray[p].CanReserveForPumpLock(eLockType))  // Check if we can send a reserve pump command 
						{
							CMD_STRUCT_RESERVE_PUMP cmdInfo;
							cmdInfo.lRes	= PUMPSRV;
							cmdInfo.lResExt = MAINTENANCE; 
													
							SetCommand(CMD_RESERVE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
					       _LOGMSG.LogMsg(p+1,LOG_PUMP,"DoAutomaticLockPumpByMode, Pump should be locked by mode and isn't locked. Locking it again.");
						}
					}
					break;

				default:
					break;
					//do nothing
			}
		}
	}
	
	return lRetVal;
}

/******************************************************************************
 Description:	Checks is the pump lock by mode process is configure to be active 	
 Returns:      	DWORD
 Parameters:   	None

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:52		Start
******************************************************************************/
DWORD CServerMain::IsLockPumpByModeActive()
{
	return m_dwLockPumpByMode;
}

/******************************************************************************
 Description:	Sets the Lock state machine for a specific pump 	
 Returns:      	void
 Parameters:   	long - lPumpNumber
				enum - LockPumpByModeStatus
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:55		Start
******************************************************************************/
void CServerMain::SetLockPumpByModeStatus(long lPumpNum,LockPumpByModeStatus eLockPumpByModeStatus)
{
	m_cPumpsLockStateArray[lPumpNum-1].SetPumpLockStatus(eLockPumpByModeStatus);
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString tmpStr;
		CString cState;
		switch(eLockPumpByModeStatus)
		{
			case PM_UNLOCK:
			{
				cState = "PM_UNLOCK";
				break;
			}
			case PM_START_LOCK:
			{
				cState = "PM_START_LOCK";
				break;
			}
			case PM_WAIT_LOCK:
			{
				cState = "PM_WAIT_LOCK";
				break;
			}
			case PM_LOCKED:
			{
				cState = "PM_LOCKED";
				break;
			}
			case PM_START_UNLOCK:
			{
				cState = "PM_START_UNLOCK";
				break;
			}
			case PM_WAIT_UNLOCK:
			{
				cState = "PM_WAIT_UNLOCK";
				break;
			}
		}
		tmpStr.Format("SetLockPumpByModeStatus ,New Status:");
		tmpStr += cState;
		_LOGMSG.LogMsg(lPumpNum,LOG_PUMP,tmpStr);
	}
}

/******************************************************************************
 Description:	Checks if the pump was locked by the mode locked process 	
 Returns:      	BOOL - TRUE: pump was locked due to the process
					   FALSE: not locked by the process
 Parameters:   	long - lPumpNumber

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:53		Start
******************************************************************************/
BOOL CServerMain::IsLockedByMode(long lPumpNumber)
{
	BOOL bLockedByMode = FALSE;

	//first check if the process is active
	if(m_dwLockPumpByMode)
	{
		if( m_cPumpsLockStateArray[lPumpNumber-1].IsLockedByMode() )
			bLockedByMode = TRUE;
	}
	return bLockedByMode;
}

/******************************************************************************
 Description:	Starts the pump lock process for specific pump  	
 Returns:      	void
 Parameters:   	long - lPumpNumber
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:55		Start
******************************************************************************/
void CServerMain::StartLockPumpByMode(long lPumpNumber)
{
	//first check if the process is active
	if(m_dwLockPumpByMode)
	{
		SetLockPumpByModeStatus(lPumpNumber,PM_START_LOCK);		
	}
}

/******************************************************************************
 Description:	Starts the pump unlock process for specific pump  	
 Returns:      	void
 Parameters:   	long - lPumpNumber
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:55		Start
******************************************************************************/
void CServerMain::StartUnLockPumpByMode(long lPumpNumber)
{
	//First check if the process is active and that the pump isn't exclusively locked
	if(m_dwLockPumpByMode)
	{
		//check if it is locked or in a middle of lock process
		if(m_cPumpsLockStateArray[lPumpNumber-1].IsLocked())
			SetLockPumpByModeStatus(lPumpNumber,PM_START_UNLOCK);
		else if( m_cPumpsLockStateArray[lPumpNumber-1].IsWaitForLock() )
			SetLockPumpByModeStatus(lPumpNumber,PM_START_UNLOCK);
	}
}

/******************************************************************************
 Description:	Increases the retry counter for specific pump  	
 Returns:      	void
 Parameters:   	long - lPumpNumber
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			27/8/2003   15:55		Start
******************************************************************************/
void CServerMain::IncreaesPumpByModeRetryCounter(long lPumpNumber)
{
	//first check if the process is active
	if(m_dwLockPumpByMode)
	{
		m_cPumpsLockStateArray[lPumpNumber-1].IncreaseRetryCounter();		
	}
}
/******************************************************************************
 Description:	Recover machine state of pump lock by mode 	
 Returns:      	None
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			24/9/2003   15:10		Start
******************************************************************************/

void CServerMain::LoadStatePumpLockByMode()
{
	long lMisc = 0 , lMode = 1 , p = 0 , lTmpMode =0; //4.0.3.55
	long lLastPump = m_lMaxPumps;

	//4.0.3.55

	if(m_dwLockPumpByMode)
	{
		for(p = 0; p < lLastPump;p++)
		{
			lMode = m_lPumpsManualModeArray[p];
			
			if (lMode) 
				lTmpMode = lMode; 
			else
				lTmpMode = m_cPumpArray[p].GetStat().GetMode();

			if ((lTmpMode)  &&  (lTmpMode <=MAX_MODES))
			{
				if( m_cModeArray[lTmpMode-1].IsNeedToLockPump() )
				{
					_LOGMSG.LogMsg("ModeSchemeProcess:New Mode has no valid Trs types");
					StartLockPumpByMode(p +1);
				}
				else
				{
					StartUnLockPumpByMode(p +1);
				}
			}
			else
			{
				if((LOG_BASIC_FLOW_CONTROL) && (lTmpMode))
				{
					CString sMsg;
					sMsg.Format("LoadStatePumpLockByMode pump has corrupted mode %ld " ,lTmpMode);
					m_cLogger.LogMsg(p+1,LOG_PUMP,sMsg ,LOG_LEVEL_0);
				}

			}
		}

	}

}

/******************************************************************************
 Description:	Checks for a specific qdex file if qdex alarm is On 	
 Returns:      	BOOL - TRUE - alarm is On.
 Parameters:   	short nFileNum - qdex file define number		
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			11/2/2004   11:07		Start
******************************************************************************/
BOOL CServerMain::IsQdexFilesAlarmOn(short nFileNum)
{
	BOOL bQdexAlarmOn = FALSE;

	switch (nFileNum)
	{
		case PUMP_STAT_FILE:
		{
			bQdexAlarmOn = m_cPumpFile.IsQdexAlarmOn();
			break;
		}
	}
	
	return bQdexAlarmOn;
}

void CServerMain::CheckIfAnotherPumpSrvIsRunning(BOOL bCreateMutex)
{
	BOOL bIsAlreadyRunning = FALSE;
	bIsAlreadyRunning = ( bCreateMutex == TRUE ) ? m_cCompChecker.IsAlreadyRunning("PumpSrvMutex") : m_cCompChecker.IsAlreadyRunningWithoutCreateMutex("PumpSrvMutex");		//4.0.23.510 TD 100241

	/////////////////////////////
	if(bIsAlreadyRunning)
	{
		Sleep(2000);
		
		//check again before exiting the process
		bIsAlreadyRunning = ( bCreateMutex == TRUE ) ? m_cCompChecker.IsAlreadyRunning("PumpSrvMutex") : m_cCompChecker.IsAlreadyRunningWithoutCreateMutex("PumpSrvMutex");		//4.0.23.510 TD 100241
		
		if(bIsAlreadyRunning)
		{
			CString strLogMsg("!!!Another instance already running, this one is stopping.");

			strLogMsg += ( bCreateMutex == TRUE ) ? " IsAlreadyRunning()" : " IsAlreadyRunningWithoutCreateMutex()";		//4.0.23.510 TD 100241
			m_cLogger.LogMsg(strLogMsg, LOG_LEVEL_0);

			exit(0);
		}
	}
}

//4.0.24.60
void CServerMain::CheckIfAnotherVPIsRunningAndStopIt(BOOL bCreateMutex)
{

	if (m_cCompChecker.KillProcess("VP.exe"))
	{
		CString strLogMsg("VP.exe is running ! - kill it !");
		m_cLogger.LogMsg(strLogMsg, LOG_LEVEL_1);

	}

}
void CServerMain::DataExportCleanUp(BOOL bDisconnFromPS)
{
	m_cDataExportSrv.DataExportCleanUp(bDisconnFromPS);
}

/******************************************************************************
 Description:	Connects to the DataExport 	
 Returns:      	void
 Parameters:   	None

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			15/7/2004   9:00		Start
******************************************************************************/
void CServerMain::ConnectToDataExport()
{
	DWORD dwTmp = 0;
	
	m_cParam.LoadParam("GeneralParam", "DataExportInUse",&dwTmp,(DWORD)0,TRUE);
	
	if(dwTmp)
		m_cDataExportSrv.DataExportSrvInit(dwTmp);		
}

//4.0.12.503
void CServerMain::ConnectToIFSFTerminalSrv()
{
	m_cParam.LoadParam("GeneralParam", "IFSFTerminalSrvInUse",&m_dwIFSFInUse,(DWORD)0,TRUE);

	m_pIFSFTerminalSrvCtrl = NULL;

	//if we use IFSFTerminalSrv
	if(m_dwIFSFInUse)
	{
		CreateConnectToIFSFTerminalSrv();
	}

}

// CR 474446
void CServerMain::ConnectToFuelMobileSrv()
{
	m_cParam.LoadParam("GeneralParam", "FuelMobileSrvInUse", &m_dwFuelMobileSrvInUse, (DWORD)0, TRUE);

	m_pFuelMobileSrvCtrl = NULL;

	//if we use IFSFTerminalSrv
	if (m_dwFuelMobileSrvInUse)
	{
		CreateConnectToFuelMobileSrv();
	}
}


/******************************************************************************
 Description:	Overwrite the system limits by  mode limits 	
 Returns:      	None.
 Parameters:   	long  &lPumpNumber - Pump number 
				short &nPumpLevel - Price Level 
				long  &lValueLimit - transaction limit.
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			8/9/2004   12:30		Start
******************************************************************************/
void CServerMain::OverwriteModeLimit(long &lPumpNumber, short &nPumpLevel, long &lValueLimit)
{
	long lMode = m_cPumpArray[lPumpNumber-1].GetStat().GetMode();	
	
	if(!MODE_NOT_VALID(lMode))
	{
		long lModeLimit =  m_cModeArray[lMode - 1].GetLimit(nPumpLevel);

		if (lModeLimit)
			lValueLimit = lModeLimit;
	}	
}
/******************************************************************************
 Description:	Upload data to OLA 	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			14/9/2004   19:50		Start
******************************************************************************/
long CServerMain::UploadBuffer(long lTerminalId, long lPumpNumber, long lSessionId, long lUploadType, BSTR sInBuffer, BSTR *sOutBuffer, long lExDataSize, BSTR ExData)
{
	long lRtc = 0;

	if(m_cOLASrv->Valid())  // 4.0.6.507
		lRtc = m_cOLASrv->UploadBuffer(lTerminalId, lPumpNumber, lSessionId, lUploadType, sInBuffer, sOutBuffer, lExDataSize, ExData);
	
	return lRtc; 
}
/******************************************************************************
 Description:	Returns the running dollars minimum value 	
 Returns:      	long
 Parameters:   	None		
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Yaron			1/11/2004   12:26		Start	4.0.7.500
******************************************************************************/
long CServerMain::GetRunningValueThreshold()
{
	return m_dwRunningValueThreshold;
}

//TD 37244
/******************************************************************************
 Description:	Returns the enhanced rolling update flag 	
 Returns:      	long
 Parameters:   	None		
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			25/04/2007   14:02		Start	4.0.7.500
******************************************************************************/
long CServerMain::GetEnhancedRollingUpdate()
{
	return m_dwEnhancedRollingUpdate;
}


/******************************************************************************
 Description:	Get memo wet stock flags 	
 Returns:       Wet stock memo flags  	
 Parameters:   	None
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			9/11/2004   12:17		Start
******************************************************************************/

long CServerMain::GetWetStockMemoFlags()
{
	return m_dwWetStockMemoFlags;
}
/******************************************************************************
 Description:	Send wet stock events 	
 Returns:      	
 Parameters:   	byMemeo - Memo process flags
				byWetStockFlags - Wet stock flags
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			23/11/2004	  13:34		Start
******************************************************************************/

//4.0.9.503void CServerMain::SendWetStockEvents(BYTE byMemeo, BYTE byWetStockFlags)
void CServerMain::SendWetStockEvents(BYTE byMemeo, long lWetStockFlags) //4.0.9.503
{
	if (byMemeo)
	{

		if (lWetStockFlags & WET_STOCK_REQUESTED_BY_POS)  //4.0.9.503
		{
		long lRetVal = m_cAlarm.AddSendMessage(CATEGORY_TANK, SUB_TANKS, WET_STOCK_TIMEOUT, 1, 1,0, 0);	
		} 				//4.0.9.555 if ( byWetStockFlags & WET_STOCK_TANKS )
		else if ( lWetStockFlags & WET_STOCK_TANKS ) //4.0.9.555
		{
			m_cEventManager.AddEvent(CTRL_EVENT_MEMO_TANK_READING,0);
			SetCommand(CMD_GENERAL_SYSTEM_EVENT,
							0,GCI_EVENT_MEMO_TANK_READING
							 );		
		}
		
		//if ( byWetStockFlags & WET_STOCK_DELIVERY) //4.0.9.503		
		if ( lWetStockFlags & WET_STOCK_DELIVERY)			//4.0.9.503
		{
			SetCommand(CMD_GENERAL_SYSTEM_EVENT,
			0,
			GCI_EVENT_MEMO_DELIVERY_REPORT );									
		}
	}
}

/******************************************************************************
 Description:Verify if ola record need to add to Qdx
 Returns:      TRUE / FALSE	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			20/12/2004   13:54		Start
******************************************************************************/
BOOL CServerMain::CheckOLAReportRequird(CPumpTransact &trs, PAY_AT_PUMP_INFO *pInfo)
{//4.0.18.501
  BOOL  bRet = TRUE;
  CString sMsg;

  if (TRUE == m_cFuelLoayaltyPS.GetFuelLoyaltyFlag()) // TD 458059. always add Qdx record if Loyalty is ON
  {
	  return TRUE;
  }

  if (((a2l(pInfo->CardSaleExtraData2.sMediaMasterType , sizeof(pInfo->CardSaleExtraData2.sMediaMasterType)) == CARD_TYPE_ATTENDANT) || 
	  (a2l(&pInfo->CardSaleExtraData4.sInPAKLoyaltyWithComplete, sizeof(pInfo->CardSaleExtraData4.sInPAKLoyaltyWithComplete))) || 
	  ((pInfo->CardSaleInfo.cardData.sTranStatus != CD_FORCE_COMPLETION_ZERO) ))&&     //4.0.14.1390 67387 4.0.21.0 //4.0.28.500 234942
	  (!trs.m_lRoundedValue) &&
	  (!trs.m_lRoundedVolume))
  {	
		if(LOG_BASIC_FLOW_CONTROL)	  
		{
			sMsg.Format("Skip update ola qdx, Zero attendant trs pump=%2ld" , trs.m_lPump );
			m_cLogger.LogMsg(trs.m_lPump,LOG_PUMP,sMsg);
		}

		bRet = FALSE;
  }

  return bRet ; 
}

//4.0.8.503
long CServerMain::GetManualServiceFee()
{
	return m_lManualServiceFee; 	
}

void CServerMain::SetManualServiceFee(long lServiceFee)
{
	m_lManualServiceFee = lServiceFee;
}
//4.0.8.503
//4.0.9.501
/******************************************************************************
 Description:	System flag that indicate whether we can create new PrePay/PAK while exist PrePay/PAK.
 Returns:		0 -Allowed  /1 - not allowed    	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			17/5/2005   12:45		Start
******************************************************************************/

long CServerMain::PumpNotAllowedMixPAKAndPrePay(long lPumpNumber ,PumpReservation eRes)
{
	BOOL bRetCode=FALSE;
	CPumpTransact cTrs;

	// check for validation only if  flag set's.
	if (GetNoParallelPakPrePayFlag())
	{
		short nPrePayWaiting, nFree, nUnpaid;
		m_cPumpArray[lPumpNumber - 1].GetTrsListCount(&nPrePayWaiting, &nFree, &nUnpaid);

		if ((eRes == PAY_AT_KIOSK ) )
		{
			if (nUnpaid)
				bRetCode = TRUE;			
			else  if (!m_cPumpArray[lPumpNumber - 1].GetInProgressWaitProgressTrs(&cTrs)) // 4.0.9.505
			{
				if (cTrs.m_lRes ==  PAY_AT_KIOSK)    
					bRetCode = TRUE;
			}						
		}			
		else if ((eRes== PRE_PAY_AT_POS) && nPrePayWaiting)
		{

			if (nPrePayWaiting)
				bRetCode = TRUE;

			else  if (!m_cPumpArray[lPumpNumber - 1].GetInProgressWaitProgressTrs(&cTrs)) // 4.0.9.505
			{
				if (cTrs.m_lRes ==  PRE_PAY_AT_POS)    
					bRetCode = TRUE;
			}						

				
		}		
	}

	return (bRetCode);
}
/******************************************************************************
 Description:	Return system flags for disbale/enable mix PrePay & PAK
 Returns:      	1- Active  0 - Not active
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			17/5/2005   15:51		Start
******************************************************************************/

BOOL CServerMain::GetNoParallelPakPrePayFlag()
{
	return (m_dwNoParallelPAK_PrP);
}
//4.0.9.501

void CServerMain::SetNoParallelPakPrePayFlag(DWORD dwVal)
{
	m_dwNoParallelPAK_PrP = dwVal;
}



//4.0.9.503
void CServerMain::CreateBaseReceipt()
{
	// NO JIRA - use only CProtectedReceipt
	//if (m_cProtectedDataHandler.GetPCIActiveFlag() == PCI_FLAG_ON)		//4.0.20.501 TD-60236
	//{
		m_cBaseReceipt = new CProtectedReceipt();
		_LOGMSG.LogMsg("CServerMain::CreateBaseReceipt, PCI Flag is on Create CProtectedReceipt");
	//}
// 	else if (m_dwReceiptLookupMethod == 1)
// 	{
// 		m_cBaseReceipt = new CAccountReceipt();
// 		_LOGMSG.LogMsg("CServerMain::CreateBaseReceipt, ReceiptLookupMethod Flag is on Create CAccountReceipt");
// 	}
// 	else
// 	{
// 		m_cBaseReceipt = new CTrack2Receipt();
// 		_LOGMSG.LogMsg("CServerMain::CreateBaseReceipt, PCI Flag is off Create CTrackReceipt");
// 	}
}

//4.0.9.503
BOOL CServerMain::GetInformPriceChangeFlags()
{
	return m_dwInformPriceChange;
}

void CServerMain::SetInformPriceChangeFlags(DWORD dwVal)
{
	m_dwInformPriceChange = dwVal;
}

void CServerMain::DoAutomaticCheckPriceChangeAck()
{
	BOOL bFound= FALSE;
	BOOL bTimeOut = FALSE;

	CPumpStatus pumpStat;

	if (m_cServerInfo.GetWaitForPriceChangeAckFlags())
	{
		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString sMsg;
			sMsg.Format("DoAutomaticCheckPriceChangeAck ------ flags=%ld ", GetInformPriceChangeFlags());
			m_cLogger.LogMsg(0, LOG_PUMP, sMsg);
		}

		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		switch (GetInformPriceChangeFlags())
		{
			case 1:
			{
				for(int i = 0; i < m_lLastValidPump; i++) 	
				{
			pumpStat = m_cPumpArray[i].GetStat();  //4.0.10.50

					if (m_cPumpArray[i].GetDieselPumpFlags()) //4.0.10.811
					{
						if (!((pumpStat.GetStatus() == OUT_OF_SERVICE) ||	
							(pumpStat.GetStatus() == UNKNOWN_STATUS) ||	
							(pumpStat.GetStatus() == COMMS_TERMINATED) ||
							(pumpStat.GetResExt() == RES_EXT_MAINTENANCE))) 	//4.0.10.591  //4.0.10.811
						{
							if ((m_cPumpArray[i].GetPriceChangeStatus()) || (m_cPumpArray[i].CheckUnpaidFleetTrs())) 
							{
								bFound = TRUE;
								break;
							}
						}
					}

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str;
						str.Format("DoAutomaticCheckPriceChangeAck %d",i);
						m_cLogger.LogMsg(str);
					}
				}
		
				// check Prepay active in the system
				//4.0.10.492
				if (bFound == FALSE)     //4.0.10.811
				{
					CPumpTransact cTrs;      //4.0.10.83
					long lSyncNumber = 0;
					cTrs.SetLink(TRS_LINK_PREPAY_NUMBER, lSyncNumber);				
					PRE_PAY_INFO		info;		
					long lRtc = TrsLinkOperation(REC_READ_FIRST,&cTrs,&info);

					while(lRtc == OK)    
					{
						// found transaction in old price , 
						if ((cTrs.m_lPump) && (cTrs.GetLinkFlags() & TRS_LINK_FLEET) && (!(cTrs.GetLinkFlags() & TRS_LINK_FLEET_PRICE_CHANGE)) && (m_cPumpArray[cTrs.m_lPump - 1].GetDieselPumpFlags())) 	//4.0.10.811
						{
							if(LOG_BASIC_FLOW_CONTROL)
							{
								CString str;
								str.Format("Pump %02ld  trs=%ld  is Prepay in old price, validation check has failed" , cTrs.m_lPump,cTrs.m_lNumber ) ;
								m_cLogger.LogMsg(str);
							}

							bFound = TRUE;
							break;
						}
				
						lRtc = TrsLinkOperation(REC_READ_NEXT,&cTrs,&info);
					}
				}
		
				//4.0.10.492	
				
				// if all price change acknowledge arrived, release all pending transaction

				bTimeOut = m_cPriceChangeFlags.CheckInformPriceChangeCounter();  //4.0.12.504

				if ( (bFound == FALSE) || bTimeOut)
				{
					PAY_AT_PUMP_INFO savedInfo; //4.0.5.0.
					OLA_STAT ola;

					int i = 0;
					for (i; i < m_lLastValidPump; i++)
					{				
						m_cPumpArray[i].GetOlaStat(&ola);
						if (m_cPumpArray[i].IsPumpIdle() && (OLA_STATE(ola.m_byState) == OLA_NONE))			//4.0.9999.0
						{
							ola.m_lSessionNumber =0;
							ola.m_byState = OLA_REQUEST_TO_SEND | SESSION_REPORT_PRICE_CHANGE;			
					
							m_cPumpArray[i].SetOlaStat(&ola); 	
							m_cPumpArray[i].SetPAPInfo(&savedInfo);			
							SavePumpInfo(i + 1); 

							if(LOG_BASIC_FLOW_CONTROL)
							{
								CString str;
								str.Format("Inform host on price change using pump %ld" , i + 1); //4.0.6190.4700
								m_cLogger.LogMsg(str);
							}

							break;	
						}
					}

					if (i == m_lLastValidPump)
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Inform host on price change has fail !!!!!");
							m_cLogger.LogMsg(str);
						}
					}
			
					m_cServerInfo.SetWaitForPriceChangeAckFlags(FALSE);			

					//4.0.10.811
					// release all Pump transaction
					for(int i = 0; i < m_lLastValidPump ; i++) 	
					{
						m_cPumpArray[i].GetPAPInfo(&savedInfo);

						if (savedInfo.CardSaleExtraData3.sWaitForPriceChange == '1')
						{
							savedInfo.CardSaleExtraData3.sWaitForPriceChange = ' ';
							m_cPumpArray[i].SetPAPInfo(&savedInfo);
						}
				
						// Release all PAK transaction.
						if (m_cPumpArray[i].ReleasePendingPriceChangeTrs())
							SavePumpInfo(i+1);					
					}

					//release the mark form the ola prePay transaction
					CPumpTransact cTrs;      //4.0.10.83
					long lSyncNumber = 0;
					cTrs.SetLink(TRS_LINK_PREPAY_NUMBER, lSyncNumber);				
					PRE_PAY_INFO		info;		
					long lRtc = TrsLinkOperation(REC_READ_FIRST,&cTrs,&info);

					while(lRtc == OK)    
					{
						// found transaction in old price , 
						if (cTrs.GetLinkFlags() & TRS_LINK_FLEET_PRICE_CHANGE)
						{
							if(LOG_BASIC_FLOW_CONTROL)
							{
								CString str;
								str.Format("Pump %02ld - trs = %ld  removed mark new price" , cTrs.m_lPump, cTrs.m_lNumber ) ;
								m_cLogger.LogMsg(str);
							}

					
							cTrs.m_nLinkFlags &= (~TRS_LINK_FLEET_PRICE_CHANGE);
							lRtc = TrsLinkOperation(REC_UPDATE,&cTrs,&info);
						}
				
						lRtc = TrsLinkOperation(REC_READ_NEXT,&cTrs,&info);
					}

					if (bTimeOut)  //4.0.12.504
					{
						m_cAlarm.AddSendMessage(CATEGORY_PUMP,
												SUB_TERMINAL_DISPENSER,
												PRICE_CHANGES_PROCESS_FAILED,
												0,
												ALARM_ON,
												0,  //volume + service fee
												0);
					}
					else
					{
						m_cAlarm.AddSendMessage(CATEGORY_PUMP,
												SUB_TERMINAL_DISPENSER,
												ALL_PRICE_CHANGES_SUCCEEDED,
												0,
												ALARM_ON,
												0,
												0);
					}
				}
			}
			break;
			case 2:
			{
				m_cServerInfo.SetWaitForPriceChangeAckFlags(FALSE);	
				break;
			}
			case 3: 
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Price change Started. LastValidPump = %ld", m_lLastValidPump);
					m_cLogger.LogMsg(str);
				}
				
				for(int i = 0; i < m_lLastValidPump ;i++) 	
				{
					pumpStat = m_cPumpArray[i].GetStat();  //4.0.10.50
					
					if (!((pumpStat.GetStatus() == OUT_OF_SERVICE)  ||	
						(pumpStat.GetStatus() == UNKNOWN_STATUS)	||	
						(pumpStat.GetStatus() == COMMS_TERMINATED)	||
						(pumpStat.GetResExt() == RES_EXT_MAINTENANCE) ))	// RFUEL-620
					{
						if (m_cPumpArray[i].GetPriceChangeStatus())
						{
							bFound = TRUE;
							break;
						}
					}
				}

				long lVal = 0;
				
				bTimeOut = m_cPriceChangeFlags.CheckInformPriceChangeCounter();  //4.0.12.504
				
				if (!bFound || bTimeOut)
				{
					if (!bFound)
						m_cCommonFunction.SetProcess(PROCESS_CHANGE_PRICES, PROCESS_PRICE_CHANGE_SUCCESS,1,0 ,0, &lVal);
					else	
						m_cCommonFunction.SetProcess(PROCESS_CHANGE_PRICES, PROCESS_PRICE_CHANGE_FAILURE,1,0, 0,&lVal);             

					if(LOG_BASIC_FLOW_CONTROL)
					{
						CString str;
						str.Format("Price change process end with status %s, bTimeOut %d", (bFound == 0) ? "SUCCESS":"FAILURE", bTimeOut);
						m_cLogger.LogMsg(str);
					}
					
					m_cServerInfo.SetWaitForPriceChangeAckFlags(FALSE);	
				}
				
				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Price change Ends for Number pump = %ld",m_lLastValidPump);
					m_cLogger.LogMsg(str);
				}
			}
			break;
		}
	}
}


void CServerMain::InitFuelEncryption()
{
	m_cProtectedDataHandler.Init();
}


/******************************************************************************
 Description:	Check according to the flags if we can set new price to the pump
					
 Returns:      	Operation ret code.
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			20/06/2005  14:28		Start
******************************************************************************/

BOOL CServerMain::IsPumpReadyForPriceChange(long lPumpNumber)
{
	BOOL bRetCode = TRUE;

	return bRetCode;
}


/******************************************************************************
 Description:	Check according to the flags if we can set new Mode to the pump


1.	On mode change (Single pump or all pumps) if 'ModeChangeNoOpenPrp' change mode only if relevant pump / pumps has no open PrP.
2.	On mode change (Single pump or all pumps) if 'ModeChangeOnIdle' change mode only if relevant pump / pumps are in IDLE status.
3.	In case set mode is declined (pre pay exist or pump not idle) PumpSrv will return new FTI error code to POSPump
					
 Returns:      	Operation ret code.
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			20/06/2005  14:28		Start
******************************************************************************/

BOOL CServerMain::IsPumpReadyForModeChange(long lPumpNumber)
{
	BOOL bRetCode = FALSE;
	 

	if(m_lModeChangeNoOpenPrp)//without prp
	{
		if(m_lModeChangeOnIdle)
		{
			//the pump must be idle and without prp
			bRetCode = m_cCommonFunction.IsPumpIdleForModeChange(lPumpNumber);
		}
		else
		{
			//the mode will change only if we don't have any prp on the pumps
			//and the pumps all in idle
			short nWaiting = 0 , nFree = 0 , nUnpaid = 0;
			m_cPumpArray[lPumpNumber].GetTrsListCount(&nWaiting,
																 &nFree,
																 &nUnpaid);
			if(nWaiting>0)
				bRetCode = FALSE;
			else
				bRetCode = TRUE;

		}
	}
	else //ignore the prp flag
	{
		if(m_lModeChangeOnIdle)//all trans in pump must be idle
		{
			bRetCode = m_cPumpArray[lPumpNumber].IsPumpIdle();
		}
		else
			bRetCode = TRUE;//the org flow

	}
	CString str;
	str.Format("IsPumpReadyForModeChange, Finish with Result %ld",bRetCode);
	m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	return bRetCode;
}

//4.0.9.507
void CServerMain::SaveAndParsePromptInfo(CString *pInStr, CPumpTransact *pTrs, PAY_AT_PUMP_INFO *pInfo)
{
	long lRtc = 0;
	TRAVEL_CENTER_REC cTravelCenterRec;
	TravelCenterData cTravelCenterData;
	CString sMsg;

	m_cCardSaleDataXML.ParsePilotString(pInStr, cTravelCenterData,pInfo);
	cTravelCenterData.PromptResult[0] = '?';

	memset(&cTravelCenterRec , 0, sizeof(cTravelCenterRec));

	cTravelCenterRec.lIndex = a2l(pInfo->CardSaleInfo.cardData.sTranNbr,sizeof(pInfo->CardSaleInfo.cardData.sTranNbr)); //pInfo->GetXmlLongField(ATT_TRAN_NBR);

	PS::RECEIPT_EXTRA_INFO_REC rec;
	memcpy(&rec, &cTravelCenterRec, min(sizeof(rec), sizeof(cTravelCenterRec)));
	lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_READ, rec);
	//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_READ,&cTravelCenterRec);


	// first time create new record
	if (lRtc)
	{

		long lTmp = a2l(pInfo->CardSaleExtraData2.sFlags ,sizeof(pInfo->CardSaleExtraData2.sFlags));

		if (!(lTmp & FL_EXTRA_RECEIPT_REC))
			lTmp |= FL_EXTRA_RECEIPT_REC ; //+ FL_DIESEL_REC; 4.0.9999.0
		l2a(lTmp ,pInfo->CardSaleExtraData2.sFlags ,sizeof(pInfo->CardSaleExtraData2.sFlags)); 


		cTravelCenterRec.lIndex = a2l(pInfo->CardSaleInfo.cardData.sTranNbr,sizeof(pInfo->CardSaleInfo.cardData.sTranNbr));
		cTravelCenterRec.cArrTravelCenterData[0] = cTravelCenterData;
		PS::RECEIPT_EXTRA_INFO_REC rec;
		memcpy(&rec, &cTravelCenterRec, min(sizeof(rec), sizeof(cTravelCenterRec)));
		lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_INSERT, rec);
		//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_INSERT,&cTravelCenterRec);


		if (lRtc)
		{
			if(LOG_BASIC_FLOW_CONTROL)
			{
				m_cLogger.LogMsg("Error update Prompts");  //4.0.10.330

				sMsg.Format("Fail insert prompts to receipt exta , index = %ld" , cTravelCenterRec.lIndex);  //4.0.10.330
				m_cLogger.LogMsg(sMsg);
			}
		}
		
	}
	else
	{
		cTravelCenterRec.lIndex = a2l(pInfo->CardSaleInfo.cardData.sTranNbr,sizeof(pInfo->CardSaleInfo.cardData.sTranNbr));
		char sPromptName0Empty[MAX_PROM_NAME]; 

		memset(sPromptName0Empty , 0  ,sizeof(sPromptName0Empty));

		for (long i=0 ;i < MAX_PROMPTS ; i++)
		{
			// Overwrite exist prompts
			if (!memcmp(cTravelCenterRec.cArrTravelCenterData[i].PromptName0 ,cTravelCenterData.PromptName0 , sizeof(cTravelCenterData.PromptName0)))
			{
				cTravelCenterRec.cArrTravelCenterData[i] = cTravelCenterData;
				break;
			}

			// update new prompts
			if (!memcmp(cTravelCenterRec.cArrTravelCenterData[i].PromptName0 ,sPromptName0Empty , sizeof(sPromptName0Empty)))
			{
				cTravelCenterRec.cArrTravelCenterData[i] = cTravelCenterData;
				break;
			}
		}

		PS::RECEIPT_EXTRA_INFO_REC rec;
		memcpy(&rec, &cTravelCenterRec, min(sizeof(rec), sizeof(cTravelCenterRec)));
		lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_UPDATE, rec);
		//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_UPDATE,&cTravelCenterRec);


		if (lRtc)
		{

			if(LOG_BASIC_FLOW_CONTROL)
			{
				sMsg.Format("Fail update prompts = %.20s , number = %ld",sizeof(cTravelCenterData.PromptName0) ,cTravelCenterData.PromptName0 ,pTrs->m_lNumber);
				m_cLogger.LogMsg(sMsg);
			}

		}
	}

	pInfo->CardSaleExtraData3.sWaitPromptNeedMoreParam = 'Y'; 
}
//4.0.9.507

//4.0.9.508
/******************************************************************************
 Description:	Check if allready init the pumps
				If so then retrun.
				otherwise we have to call init pump with the pump number
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			17/05/2005   14:37		Start
******************************************************************************/

void CServerMain::DoAutomaticInitLoyaltyFuel()
{
	long lRetCode = FALSE;
	if(m_cFuelLoayaltyPS.GetFuelLoyaltyFlag())//if we have loyalty in system
	{
		if(!m_cFuelLoayaltyPS.GetInitDllFlag())//we have to init
		{	
			m_cFuelLoayaltyPS.CreateLoyaltyInterface();
			
			if (m_cFuelLoayaltyPS.GetLoyaltySrvInUse() != EPSILON)
			{
				lRetCode = m_cFuelLoayaltyPS.InitFuelLoyaltyInterface(m_lLastValidPump);

				if (FALSE == lRetCode)
					m_cLogger.LogMsg("DoAutomaticInitLoyaltyFuel failed");
			}
				
		}
		if (!GetIFSFTerminalSrvInUse() && IsFuelMobileSrvInUse() == FALSE)// CR 444830	//4.0.23.504 66705	
			DoAutomaticInitFlowControl();
	}
	
}

/******************************************************************************
 Description:	Check if the flow control configuration is already loaded
				If so then retrun.
				otherwise we have to call init
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			18/03/2008   13:22		Start
******************************************************************************/

void CServerMain::DoAutomaticInitFlowControl()
{
	BOOL bRetCode = FALSE;
	if(m_cFlowControlManager.GetFuelFlowControlFlag())//if we have flow control in system
	{
		if(!m_cFlowControlManager.GetInitFlag())//we have to init
		{
			bRetCode = m_cFlowControlManager.Init();
			if(bRetCode == FALSE)
				m_cLogger.LogMsg("DoAutomaticInitFlowControl failed");
				
		}
	}
	
}
//4.0.9.508
/******************************************************************************
 Description:	Automatic procedure to init the pumps on fuel loyalty dll 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			17/05/2005   14:37		Start
******************************************************************************/

void CServerMain::DoAutomaticInitLoyaltyFuel__()
{
	__try
	{
		DoAutomaticInitLoyaltyFuel();
	}
	__except(_HANDLE_EXCEPTION("CServerMain::DoAutomaticInitLoyaltyFuel__")) //4.0.15.450
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticInitLoyaltyFuel__()", LOG_LEVEL_0);
		exit(1);
	}
}




/******************************************************************************
 Description:	Check activate PAK auto reconcile, 	
 Returns:      	0 - not found  1-  found
 Parameters:   	lPumpNumber - pump number ,  
				trs			- Transaction details 	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			8/12/2004   19:38		Start
 Amram			13/07/2005				Moved the function from GCI To ServerMain
******************************************************************************/

long CServerMain::CheckActivityPAKAutoReconcile(long lPumpNumber, CPumpTransact &trs)
{
	long lRetVal = 0;

	 if (trs.m_lMode)
	 {
		long lRtc = 0;
		if (m_cModeArray[trs.m_lMode -1 ].PAKAutoReconcile())
		{
			PAY_AT_PUMP_INFO		PayAtPumpInfo;	
			CPumpTransact			cTmpTrs;
			SYSTEMTIME		curSysTime;
			GetLocalTime(&curSysTime);	
			char sTmpDateAndTime[32]={0};

			memset(&PayAtPumpInfo , ' ',sizeof(PAY_AT_PUMP_INFO));
		
			//4.0.7.505 - setting the Trs as PAID
			trs.m_lStatus = PAID;
			cTmpTrs = trs;	

			PayAtPumpInfo.CardSaleInfo.lIndexNumber = NewOLAIndex();						
			i2a(CARD_TYPE_PAK_AUTO_RECONCILE ,PayAtPumpInfo.CardSaleExtraData2.sMediaMasterType , sizeof(PayAtPumpInfo.CardSaleExtraData2.sMediaMasterType));			
				 
			cTmpTrs.SetLink(TRS_LINK_OLA_NUMBER, PayAtPumpInfo.CardSaleInfo.lIndexNumber);		
			 			
			//4.0.7.506
			Convertl2Str2(cTmpTrs.m_lRoundedValue  ,PayAtPumpInfo.CardSaleInfo.extraData.sTotalAmt_Msb,sizeof(PayAtPumpInfo.CardSaleInfo.extraData.sTotalAmt_Msb) , PayAtPumpInfo.CardSaleInfo.extraData.sTotalAmt, sizeof(PayAtPumpInfo.CardSaleInfo.extraData.sTotalAmt));	
			Convertl2Str2((cTmpTrs.m_lRoundedValue /10)  ,PayAtPumpInfo.CardSaleInfo.extraData.sFuelAmt_Msb,sizeof(PayAtPumpInfo.CardSaleInfo.extraData.sFuelAmt_Msb) , PayAtPumpInfo.CardSaleInfo.extraData.sFuelAmt, sizeof(PayAtPumpInfo.CardSaleInfo.extraData.sFuelAmt));	 //4.0.8.500
	
			//4.0.8.503
			sprintf_s(sTmpDateAndTime, _countof(sTmpDateAndTime),"%02d%02d%02d%02d%02d%02d" , ((curSysTime.wYear >= 2000 )? (curSysTime.wYear - 2000) : (curSysTime.wYear - 1900)) ,curSysTime.wMonth,curSysTime.wDay, curSysTime.wHour , curSysTime.wMinute ,curSysTime.wSecond) ;
			memcpy(PayAtPumpInfo.CardSaleInfo.cardData.sDateTime ,sTmpDateAndTime , 10);
			memcpy(PayAtPumpInfo.CardSaleInfo.extraData.sDateTimeExt ,&sTmpDateAndTime[10] , 2);



			PayAtPumpInfo.CardSaleInfo.cardData.sTranStatus =  CD_APPROVE_OK;
				PayAtPumpInfo.CardSaleInfo.cardData.sTranType = CD_TYPE_CASH;
			
			if(LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("Added PAK auto reconcile record to  OLA Index Number  - %ld (Trs %ld, Value %ld, Volume %ld) ",PayAtPumpInfo.CardSaleInfo.lIndexNumber,cTmpTrs.m_lNumber,cTmpTrs.m_lRoundedValue,cTmpTrs.m_lRoundedVolume); 
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
			}						

		 	lRtc = TrsLinkOperation(REC_INSERT,&cTmpTrs, &PayAtPumpInfo);	

			InsertToPaidQDX(trs);//4.0.11.503
			// insert info to receipt file
			if (lRtc)
			{
				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Failed to insert PAK auto reconcile record to OLA Index Number - %ld (Trs %ld, Value %ld, Volume %ld) ",PayAtPumpInfo.CardSaleInfo.lIndexNumber,trs.m_lNumber,trs.m_lRoundedValue,trs.m_lRoundedVolume); 
					_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
				}						

			}
			else
			{
				//4.0.7.505 - send the event to VP
				m_cEventManager.AddEvent(CTRL_EVENT_PAP_TRS,0);
			}

			trs.m_lResExt  = RES_EXT_PAK_AUTO_RECONCILE;	
			lRetVal = 1;
		}
	 }

	 return lRetVal;
}


BOOL CServerMain::UpdatePAKReconcileTrans(long lPumpNumber)
{
	BOOL bRtc=FALSE;
	long p = lPumpNumber-1;
	CPumpTransact tmpTrs;//4.0.9.506 //amram
	//Cr 13161 Agip if we have rich the limit of unpaid trs
	//the we reconcil the first trs that we have 
	//the trs must by unpaid PAK

	// 4.0.14.508
	long lIdx = m_cPumpArray[p].FindOldestUnpaidPakTrs();
	m_cPumpArray[p].GetTrsByIndex (lIdx,&tmpTrs);
	
	if (CheckActivityPAKAutoReconcile(lPumpNumber,tmpTrs))
	{		
		CentralUpdateTrs(lPumpNumber,tmpTrs.m_lNumber,&tmpTrs,FALSE);				
		bRtc = TRUE;
	}

	return bRtc;
}
//4.0.10.503
/******************************************************************************
 Description:	Check if Position/restrection falg is on
				if so than we will return the position
 Returns:      	0 - not found  1-  found
 Parameters:   	lGrade -	grade number ,  
				
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			29/08/2005				Start
******************************************************************************/
long CServerMain::GetGradePositionRestrection(long lGrade,
											  long lPumpNumber)
{
	long lPos=0;

	if(m_bControllerSupportNozzleRestrction)
	{
		//it's means we will return the position of the pump
		lPos = m_cPumpArray[lPumpNumber -1].GetGradePosition((short)lGrade);

	}
	else
		lPos = lGrade;
	CString str;
	str.Format("GetGradePositionRestrection, The Grade position is the array is - %ld ",lPos);
	_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	return lPos;
}

//RFUEL-3309 Get the maximal discount allowed for the grade 
DWORD CServerMain::GetMaximalDiscountForGrade(short lGrade ,long lPriceLevel/* = LOWEST_PRICE*/, long *plGradePrice/* = NULL*/)
{
	if (lGrade == 0)  // illegal grade don't process. lGrade is the grade suffix on the registry keys 
		return 0;    // e.g.: lGrade  = 7   for  HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Pointofsale\PumpSrv\Grades\Grade07
	long lGradePrice = 0;
	
	CString str;
	long lMinLoyaltyUnitPrice = _Module.m_server.m_cFuelLoayaltyPS.GetMinLoyaltyUnitPrice();
	if (lPriceLevel < SELF_CASH || lPriceLevel>	FULL_CREDIT) // for maximal discount always calculate by lowest price to avoid discount higher than current price
		lGradePrice = GetLowestGradePriceFromArray(lGrade);  
	else
		lGradePrice = GetGradePriceFromArray(lPriceLevel,lGrade); 
	if (plGradePrice)
		*plGradePrice = lGradePrice;
	long MaximalDiscountForGrade = lGradePrice; // initial max discount is the grade price...
	if (lGradePrice > lMinLoyaltyUnitPrice)
		MaximalDiscountForGrade = lGradePrice - lMinLoyaltyUnitPrice; 
	str.Format("GetMaximalDiscountForGrade() getting maximal discount per grade according to MinLoyaltyUnitPrice.lGrade[%ld], lMinLoyaltyUnitPrice[%ld], lGradePrice[%ld], MaximalDiscountForGrade[%ld]", lGrade, lMinLoyaltyUnitPrice, lGradePrice, MaximalDiscountForGrade);
	if (LOG_ALL_FLOW_CONTROL)
		_LOGMSG.LogMsg(str);
	return MaximalDiscountForGrade;
};

void CServerMain::UpdateDiscountPerGrade(long lGrade, long lPumpNumber, long lCentsOff, PAY_AT_PUMP_INFO & cTmpInfo)
{
	CString str;
	long p = lPumpNumber - 1, lPos = 0;
//	//RFUEL-3194	
//	long lMinLoyaltyUnitPrice = _Module.m_server.m_cFuelLoayaltyPS.GetMinLoyaltyUnitPrice(); 
//	long lGradePriceLevel = GetPriceLevel(lPumpNumber,cTmpInfo);
//	long lServiceMode = m_cPumpArray[p].GetModeService();
	for (long i = 0; i < MAX_POSITIONS_PER_PUMP; i++)
	{
		//long lGradePrice = GetGradePriceByPumpModeAndLEvel(p,lGrade, lServiceMode, lGradePriceLevel);//RFUEL-3194 limit minimal unit price after loyalty discounts are applied
//		long lGradePrice = GetInitialGradeLowestPrice(lGrade); //RFUEL-3194 (task RFUEL-3257) limit minimal unit price after loyalty discounts are applied to according to lowest price
		long lTempCentsOff = lCentsOff;	//RFUEL-3409 Pump with three nozzles with same diesel grade - Superfluous discount is being applied. For pumps that have the same grade in more than one position(nozzle) we must not accumulate the discount.
		if (m_bControllerSupportNozzleRestrction)
		{
			//it's means we will return the position of the grade on the pump
			lPos = m_cPumpArray[lPumpNumber - 1].GetGradePosition((short)lGrade, &i);
			if (lPos > 0)
			{
				lPos -= 1;
				lTempCentsOff += a2l(cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount, sizeof cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount); // MichaelPo - US 434243 - [FUEL] - Support cents off discounts - PAY AT PUMP - Before Fueling
/*				//RFUEL-3194 task RFUEL-3257  Change premise - Make unit price limit comparing to lowest unit price.
				{
					str.Format("UpdateDiscountPerGrade() Validating final discount to avoid negative unit price.lPos[%ld],  lGrade[%ld], lMinLoyaltyUnitPrice[%ld], lGradePrice[%ld], initial lTempCentsOff[%ld]", lPos, lGrade, lMinLoyaltyUnitPrice, lGradePrice, lTempCentsOff);
					lTempCentsOff = _Module.m_server.ValidateDiscount(lGradePrice, lTempCentsOff, lMinLoyaltyUnitPrice); //RFUEL-3194 limit minimal unit price after loyalty discounts are applied
				}*/
				l2a(lTempCentsOff, cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount,sizeof(cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount));
			}
		}
		else
		{
			lPos = lGrade;
			lPos -= 1;
			lTempCentsOff += a2l(cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount, sizeof cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount); // MichaelPo - US 434243 - [FUEL] - Support cents off discounts - PAY AT PUMP - Before Fueling
		   /*  //RFUEL-3194 task RFUEL-3257  Change premise - Make unit price limit comparing to lowest unit price.
			{
				str.Format("UpdateDiscountPerGrade() Validating final discount to avoid negative unit price.lPos[%ld],  lGrade[%ld], lMinLoyaltyUnitPrice[%ld], lGradePrice[%ld], initial lTempCentsOff[%ld]", lPos, lGrade, lMinLoyaltyUnitPrice, lGradePrice, lTempCentsOff);
				lTempCentsOff = _Module.m_server.ValidateDiscount(lGradePrice, lTempCentsOff, lMinLoyaltyUnitPrice); //RFUEL-3194 limit minimal unit price after loyalty discounts are applied
			}*/
			l2a(lTempCentsOff, cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount,sizeof(cTmpInfo.CardSaleExtraData2.sDiscountPerGrade[lPos].sDiscount));
		}
		CString sFinalDiscount;
		sFinalDiscount.Format(" Final lCentsOff[%ld]", lTempCentsOff);
		str = str + sFinalDiscount;
		if (LOG_BASIC_FLOW_CONTROL)
			_LOGMSG.LogMsg(str);
	}
};

long CServerMain::GetCashAcceptorReport__(long lTerminalId, long lFlags, BSTR *sHeader, BSTR *sRecords, long *lRecordCount)
{
	return(m_cCashAcceptorFile.GetCashAcceptorReport__( lTerminalId,  lFlags, sHeader, sRecords, lRecordCount)); //4.0.11.115
}

//4.0.16.502 - TD 35765
long CServerMain::GetCashAcceptorReportXml__(long lTerminalId, long lFlags, BSTR *sHeader, BSTR *sXmlData, long *lRecordCount, BOOL bCheckRemovalDrawers) //4.0.17.501
{
	return(m_cCashAcceptorFile.GetCashAcceptorReportXml__( lTerminalId,  lFlags, sHeader, sXmlData, lRecordCount, bCheckRemovalDrawers));
}


void CServerMain::MoveCashAcceptorShift()
{
	m_cCashAcceptorFile.MoveShift();
}



/******************************************************************************
 Description:TD 17347 Get the string to show on posPump in case the card was decline
 Returns:      
 Parameters:   	
				
 //4.0.8.240
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			20/09/2005				Start
******************************************************************************/

void CServerMain::GetDeclineErrorFromOla(long lDeclineError,PAY_AT_PUMP_INFO * pInfo)
{
	switch(lDeclineError)
	{
		case OLASRV_GENERAL_ERROR:
			{
				memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_GENERAL_ERROR",strlen("OLASRV_GENERAL_ERROR"));
				break;
			}
		case OLASRV_CONVERT_LAYER_ERROR:
			{
				memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_CONVERT_LAYER_ERROR",strlen("OLASRV_CONVERT_LAYER_ERROR"));
				break;
			}
		case OLASRV_UNKNOWN_SESSION_ID:
			{
				memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_UNKNOWN_SESSION_ID",strlen("OLASRV_UNKNOWN_SESSION_ID"));
				break;
			}
		case OLASRV_NOT_SUPPORTED:
			{
					memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_NOT_SUPPORTED",strlen("OLASRV_NOT_SUPPORTED"));
				break;
			}
		case OLASRV_NO_HOST:
			{
				memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_NO_HOST",strlen("OLASRV_NO_HOST"));
				break;
			}
		default:
			memcpy(pInfo->CardSaleInfo.cardData.sResultMsg,"OLASRV_UNKNOWN_ERROR",strlen("OLASRV_UNKNOWN_ERROR"));
	}
}



/******************************************************************************
 Description:Get Card Info with track3.
			 Parse the data from RFS and call GetCardInfo
 Returns:      
 Parameters:   	
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			12/10/2005				Start
******************************************************************************/
long CServerMain::GetCardInfoEx(long lClientId, BSTR sInBuffer, BSTR sInfoType, long lFlags, BSTR *sRetData, long *pVal)
{
	long lRetCode = GCI_OK;
	long lOlaRecordSize = sizeof(CARD_SALE_ALL3);
	CComBSTR			sCardBuf;
	PAY_AT_PUMP_INFO	cPayAtPumpInfo;
	CARD_SALE_ALL3		cCardSaleALL3;
	char				sOutBuffer[3048]; //4.0.5.0
	long				lPumpNumber=0;
	CComBSTR			cInBuf;
	long				lSessionType;
	CARD_SALE_ALL3		CardData;  //4.0.0.75 //4.0.5.0.
	CARD_SALE_EXTRA_DATA4_  cCardSaleExtraData4;
	try
	{
			
		memset((char*)sOutBuffer , 0 , sizeof(sOutBuffer));
		memset(&cPayAtPumpInfo,' ', sizeof(cPayAtPumpInfo));
		memset(&cCardSaleALL3,' ', sizeof(cCardSaleALL3));
		memset(&CardData,' ', sizeof(CardData));
		memset(&cCardSaleExtraData4,' ', sizeof(cCardSaleExtraData4));

		if (CheckOLA() != OLASRV_COM_ERROR)
			if(m_cOLASrv->Valid())
			{ // in case ola not connected . launched it

				int iLen = 0;
				//4.0.20.503 66960
				CARD_SALE_ALL_CHIP_EXTRA_DATA	cardDataAll3ChipExtra;	
				memset(&cardDataAll3ChipExtra, ' ', sizeof(cardDataAll3ChipExtra));
				lRetCode = m_cXmlConvertorEx.GetStructCardSaleAll3ChipExtra(sInBuffer, lOlaRecordSize, &cardDataAll3ChipExtra, &iLen);	//4.0.20.503 66960
				memcpy(&cCardSaleALL3, &cardDataAll3ChipExtra.cCardSaleAll3, sizeof(cCardSaleALL3));

				{
					CString str;
					str.Format("CServerMain::GetCardInfoEx(1) - Pump %02ld, sTranType = %c ", lPumpNumber, cCardSaleALL3.CardSaleAll.data.sTranType);
					_LOGMSG.LogMsg(str);
				}

				if (lRetCode == GCI_OK)
				{
					lPumpNumber = a2l(cCardSaleALL3.CardSaleAll.data.sPumpNumber,sizeof(cCardSaleALL3.CardSaleAll.data.sPumpNumber));//4.0.20.503 66960

					CString str;
					str.Format("Pump %ld detect in GetCardInfoEx call ",lPumpNumber);
					_LOGMSG.LogMsg(str);

					if(PUMP_NOT_VALID(lPumpNumber))
						lRetCode = GCI_INVALID_PUMP_NUMBER;
					else 
					{
						m_cCommonFunction.ConvertCardSaleAll3ToPayAtPumpInfo(cPayAtPumpInfo, cCardSaleALL3);	//4.0.20.507
						
						//4.0.13.501
						if (lFlags & GET_CARD_INFO_SESSION)
						{
							lRetCode = m_cOLASrv->GetCardInfoSessionEx(lClientId,sInBuffer,&sCardBuf,lFlags);  //4.0.13.508
						}

						//If we use the original get card info.
						else if (lFlags & GET_CARD_INFO_ORIGINAL  && (GetOLAInUse() != OLASRV_PROGRESS_EX) && (GetOLAInUse() != OLASRV_STORE_LINE) && (GetOLAInUse() != OLASRV_EPS)) //R10 User Story - 71146
						{
							//Call the old method with a specific values (instead of the struct)
							//Get the relevant values from the buffer

							BYTE sTmp1[sizeof(cCardSaleALL3.CardSaleAll.data.sAccountNumber)+2];
							Str2StrNull((BYTE *)cCardSaleALL3.CardSaleAll.data.sAccountNumber,sizeof(cCardSaleALL3.CardSaleAll.data.sAccountNumber),sTmp1);
							CComBSTR cAccountNum(sizeof(sTmp1),(LPCSTR)sTmp1);

							BYTE sTmp2[sizeof(cCardSaleALL3.CardSaleAll.data.sTrack1Data)+2];
							Str2StrNull((BYTE *)cCardSaleALL3.CardSaleAll.data.sTrack1Data,sizeof(cCardSaleALL3.CardSaleAll.data.sTrack1Data),sTmp2);
							CComBSTR cTrack1(sizeof(sTmp2),(LPCSTR)sTmp2);

							BYTE sTmp3[sizeof(cCardSaleALL3.CardSaleAll.data.sTrack2Data)+2];
							Str2StrNull((BYTE *)cCardSaleALL3.CardSaleAll.data.sTrack2Data,sizeof(cCardSaleALL3.CardSaleAll.data.sTrack2Data),sTmp3);
							CComBSTR cTrack2(sizeof(sTmp3),(LPCSTR)sTmp3);

							BYTE sTmp4[sizeof(cCardSaleALL3.CardSaleAll.data.sCardName)+2];
							Str2StrNull((BYTE *)cCardSaleALL3.CardSaleAll.data.sCardName,sizeof(cCardSaleALL3.CardSaleAll.data.sCardName),sTmp4);

							CComBSTR cShortCardName(sizeof(sTmp4),(LPCSTR)sTmp4);

							if(lFlags & GET_ALL_CARDS_DATA)
							{
								CComBSTR sTmp = "AllCardsData";
								SysFreeString(cShortCardName);
								cShortCardName = sTmp;
							}

							lRetCode = m_cOLASrv->GetCardInfo(cAccountNum.m_str,cTrack1.m_str,cTrack2.m_str,cShortCardName.m_str,&sCardBuf,lFlags,&lSessionType,lPumpNumber, &cPayAtPumpInfo); //4.0.20.52 63936

							if ((ST_SESSION == lSessionType) && (!lRetCode))  //4.0.14.502
							{
								if(LOG_BASIC_FLOW_CONTROL)
								{
									CString sLogMess;
									sLogMess.Format("Request GetCardInfo direct was convert to query session %d", lSessionType );
									_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,sLogMess); 				
								}

								lRetCode = GCI_CREATE_OLA_SESSION;
							}

						}						
						else
						{
							CString str;
							str.Format("Pump %ld CServerMain::GetCardInfoEx call BuildRequest",lPumpNumber);
							_LOGMSG.LogMsg(str);

							m_cOLASrv->BuildRequest(SESSION_AUTHORIZE,
														 lPumpNumber,
														 (char*)&cPayAtPumpInfo,
														 (char*)sOutBuffer,
														 NULL, TRUE); // 4.0.6.501
							cInBuf = sOutBuffer;
							lRetCode = m_cOLASrv->GetCardInfoEx(lClientId,cInBuf, &sCardBuf); //4.0.13.508
							m_cOLASrv->BuildGetCustomerInfoRequest(lPumpNumber,
																	(char*)&cPayAtPumpInfo,
																	(char*)sOutBuffer);
						}
					}
				}
			}

			if (m_cOLASrv->Valid() && lRetCode == 0)
			{
				long lSize;

				if (m_bUseXmlBuffer)
				{
					lSize = MAX_XML_BUF_LEN + 2;
				}
				else
				{
					lSize = sizeof(CARD_SALE_ALL3) + 2;
				}

				BYTE* pTmp = new BYTE[lSize];  //4.0.0.75

				//4.0.9.506 amram
				//if flag is ALL_CARDS_DATA then we have to call 
				//ParseData and rfs will get ?
				if(lFlags & GET_ALL_CARDS_DATA)
				{
					CString sCardOlaInfo = sCardBuf.m_str;
					PAY_AT_PUMP_INFO cPayAtPumpInfo;
					
					memset(&cPayAtPumpInfo,' ',sizeof(cPayAtPumpInfo));
					
					m_cOLASrv->ParseData(OLASRV_NEED_MORE_PARAMS,&sCardOlaInfo,&cPayAtPumpInfo,NULL,0,lPumpNumber); //4.0.16.503
					
					m_cCommonFunction.ConvertPayAtPumpInfoToCardSaleAll3(CardData, cPayAtPumpInfo);					
				}
				else
					//parse sCardBuf to cardData
					m_cOLASrv->ParseCardData(sCardBuf, &CardData,lPumpNumber);

				

				if (lFlags & SWIPE_THREE_OLA_REC)
				{
					lOlaRecordSize = sizeof(CARD_SALE_ALL3);

					if (!GetOLAFlags(CardData.extData2.sFlags ,FL_PAP_AS_THIRD_REC))
					{
						long lTmp = a2l(CardData.extData2.sFlags ,sizeof(CardData.extData2.sFlags))  + FL_PAP_AS_THIRD_REC;
						l2a(lTmp ,CardData.extData2.sFlags ,sizeof(CardData.extData2.sFlags)); 
					}			
				}

				if (m_bUseXmlBuffer)
				{
					memset(pTmp,0,lSize);
					m_cXmlConvertorEx.ConvertFromStructToXml((char*)pTmp,&CardData);
				}
				else
				{
					Str2StrNull((BYTE *)&CardData, lOlaRecordSize ,pTmp);  //4.0.0.75
				}

				if(LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("GetCardInfoEx Attendant name=%.15s, ID=%.10s,buffer size=%ld bslt len=%d", CardData.extData2.sAttendantName, CardData.extData2.sAttendantID , lOlaRecordSize, strlen((char *)pTmp));
					m_cLogger.LogMsg(str);
				}

				CComBSTR CParam(lSize,(LPCSTR)pTmp);
				CParam.CopyTo(sRetData);

				if (pTmp)  //4.0.18.501
				{
					delete [] pTmp;
					pTmp = NULL;
				}					
			}
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::GetCardInfoEx Error", LOG_LEVEL_0);
	
	}

	return lRetCode; 
}



void CServerMain::MatchSentLoyaltyCardInfoToOLA(PAY_AT_PUMP_INFO &pInOutPAPBuffer)  //4.0.23.507 89548
{
	m_cOLASrv->MatchSentLoyaltyCardInfoToOLA(pInOutPAPBuffer);
}
void CServerMain::MatchReceivedLoyaltyCardInfoToOLA(CARD_SALE_ALL3 &pInOutPAPBuffer)  //4.0.23.507 89548
{
	m_cOLASrv->MatchReceivedLoyaltyCardInfoToOLA(pInOutPAPBuffer);
}

/******************************************************************************
 Description:Delete trs from PAID TRS QDX
 Returns:      
 Parameters:   	
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			13/11/2005				Start
******************************************************************************/
long CServerMain::DeleteFromPaidTrsQDX(CPumpTransact & cTrs)
{
	long lRtc=0;
	PAID_TRS_EX cPaidTrs;
	char		sKey[32];
	memset(&cPaidTrs,' ',sizeof(PAID_TRS_EX));
	cTrs.GetTag(&cPaidTrs.cTagPump,2);
	TAG_SYSTEMTIME  sTagTime =  cPaidTrs.cTagPump.sDateTime;
	
	sprintf_s(sKey
		, _countof(sKey)
		, "%.3d%.sd%.sd%.sd%.sd%.sd%.2s"
		, a2l(cPaidTrs.cTagPump.sPump , sizeof(cPaidTrs.cTagPump.sPump))
		, sTagTime.sYear
		, sTagTime.sMonth
		, sTagTime.sDay
		, sTagTime.sHour
		, sTagTime.sMinute
		, sTagTime.sSecond
	);

	memset(&cPaidTrs.sIndex,' ',sizeof(cPaidTrs.sIndex));
	memcpy(cPaidTrs.sIndex,(BYTE*)sKey,sizeof(cPaidTrs.sIndex));

	lRtc = IndexOperation(PAID_TRS_FILE,REC_DELETE,&cPaidTrs);
	return lRtc;


}

//Ravit 17.11.05 
BOOL CServerMain::IsServerInRecoveryProcess()
{
	//if the flag is on
	return (m_bServerInRecoveryProcess);
}

void CServerMain::SetServerRecoveryProcess(BOOL bServerInRecoveryProcess)
{
	CString sLogMsg;
	if(bServerInRecoveryProcess)
		sLogMsg = "RecoveryProcess On";
	else
		sLogMsg = "RecoveryProcess Off";
	m_cLogger.LogMsg(sLogMsg);

	m_bServerInRecoveryProcess = bServerInRecoveryProcess;
}

long CServerMain::GetExtGradeIDByGradeID(long lGradeID, long lPumpNumber) //4.0.19.1100 128024 //4.0.25.30
{
	long lExtGradeID = lGradeID;
	if (GetMaxGrade999())
	{
		m_cExtendedGradeMap.GetExtGradeByGrade(lGradeID, lExtGradeID, lPumpNumber);  
	}

	return lExtGradeID;
}

/******************************************************************************
 Description:Delete trs from PAID TRS QDX
 Returns:      
 Parameters:   	
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			13/11/2005				Start
******************************************************************************/
long CServerMain::UpdatePaidTrsQDX(CPumpTransact & cTrs,long lUpdateFlag)
{
	long lRtc=0;
	PAID_TRS_EX cPaidTrs;
	char		sKey[32];
	CString		str;
   
	memset(&cPaidTrs,' ',sizeof(PAID_TRS_EX));
	cTrs.GetTag(&cPaidTrs.cTagPump,2);
	if(lUpdateFlag)
		cPaidTrs.bOnOffer = '1';
	memset(&sKey,' ',sizeof(sKey));

	TAG_SYSTEMTIME  sTagTime =  cPaidTrs.cTagPump.sDateTime;
	
	sprintf_s(sKey, _countof(sKey), "%.3d%.2s%.2s%.2s%.2s%.2s%.2s"
		, a2l(cPaidTrs.cTagPump.sPump, sizeof(cPaidTrs.cTagPump.sPump))
		, sTagTime.sYear
		, sTagTime.sMonth
		, sTagTime.sDay
		, sTagTime.sHour
		, sTagTime.sMinute
		, sTagTime.sSecond
	);

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString sLogMess;
		sLogMess.Format("UpdatePaidTrsQDX Key=%.15s", sKey );
		_LOGMSG.LogMsg(a2l(cPaidTrs.cTagPump.sPump,sizeof(cPaidTrs.cTagPump.sPump)),LOG_PUMP,sLogMess); 				
	}


	memset(&cPaidTrs.sIndex,' ',sizeof(cPaidTrs.sIndex));
	memcpy(cPaidTrs.sIndex,(BYTE*)sKey,sizeof(cPaidTrs.sIndex));
	lRtc = IndexOperation(PAID_TRS_FILE,REC_UPDATE,&cPaidTrs);
	if(!(lRtc))
	{
		str.Format("CServerMain::UpdatePaidTrsQDX Update Paid QDX success trs number %ld,update = %ld ",
			cTrs.m_lNumber,lUpdateFlag);
		m_cLogger.LogMsg(str);
	}
	else
	{
		str.Format("CServerMain::UpdatePaidTrsQDX Update Paid QDX NOT success trs number %ld,update = %ld ",
			cTrs.m_lNumber,lUpdateFlag);
		m_cLogger.LogMsg(str);
	}

	return lRtc;


}



/******************************************************************************
 Description:Find trs in paid QDX and return to setTrsState
 Returns:      
 Parameters:   	
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			27/11/2005				Start
******************************************************************************/
BOOL CServerMain::GetTrsFromPaidQdx(long lPumpNumber,long lTrsNumber,CPumpTransact&  cTrs)
{
	BOOL bRetCode = FALSE;
	
	memset(&cTrs, ' ',sizeof(CPumpTransact));
	long lRtc =0;
	PAID_TRS_EX cPaidTrs;
	long lTmpPump=0,lTmpTrsNumber=0;
	
	memset(&cPaidTrs,' ',sizeof(cPaidTrs));
	char sKey[20];
	memset(&sKey,' ',sizeof(sKey));
	SetPumpNumberToQDX(lPumpNumber,sKey);//4.0.11.510
				

	memcpy(cPaidTrs.sIndex,sKey,3);
	lRtc = IndexOperation(PAID_TRS_FILE,REC_READ_FIRST,&cPaidTrs);
	lTmpPump = a2l(cPaidTrs.sIndex,3);
	if(lTmpPump == lPumpNumber)//if we have at list one row
	{
		while(!(lRtc))
		{
			lTmpTrsNumber = a2l(cPaidTrs.cTagPump.sNumber,sizeof(cPaidTrs.cTagPump.sNumber));
			if(lTmpTrsNumber == lTrsNumber)
			{
				CString str;
				str.Format("CServerMain::GetTrsFromPaidQdx found trs in paid qdx.trs number %ld",lTrsNumber);
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
				bRetCode = TRUE;
				break;
			}
			lRtc = IndexOperation(PAID_TRS_FILE,REC_READ_NEXT,&cPaidTrs);
			lTmpPump = a2l(cPaidTrs.sIndex,3);
			if(lTmpPump != lPumpNumber)//if we have at list one row
				break;
		}
	}
	//4.0.11.504
	if(bRetCode)
	{
		//TD 38654- all ".cTagPump2" became "cTagPump"
		cTrs.m_lNumber = a2l(cPaidTrs.cTagPump.sNumber,sizeof(cPaidTrs.cTagPump.sNumber		));//= m_lNumber;
		cTrs.m_lStatus= (TrsStatus)a2l(cPaidTrs.cTagPump.sStatus		,sizeof(cPaidTrs.cTagPump.sStatus		));//= m_lStatus;
		cTrs.m_lOnOffer= a2l(cPaidTrs.cTagPump.sOnOffer		,sizeof(cPaidTrs.cTagPump.sOnOffer		));//= m_lOnOffer;
		cTrs.m_lRawVolume= a2l(cPaidTrs.cTagPump.sRawVolume		,sizeof(cPaidTrs.cTagPump.sRawVolume		));//= m_lRawVolume;
		cTrs.m_lRoundedVolume= a2l(cPaidTrs.cTagPump.sRoundedVolume ,sizeof(cPaidTrs.cTagPump.sRoundedVolume ));//= m_lRoundedVolume;
		cTrs.m_lRoundedValue= a2l(cPaidTrs.cTagPump.sRoundedValue	,sizeof(cPaidTrs.cTagPump.sRoundedValue	));//= m_lRoundedValue;
		cTrs.m_lGradePrice= a2l(cPaidTrs.cTagPump.sGradePrice	,sizeof(cPaidTrs.cTagPump.sGradePrice	));//= m_lGradePrice;

		cTrs.m_nNozzle =  a2i(cPaidTrs.cTagPump.sNozzle		,sizeof(cPaidTrs.cTagPump.sNozzle		));//= m_nNozzle;
		cTrs.m_nGrade = a2i(cPaidTrs.cTagPump.sGrade			,sizeof(cPaidTrs.cTagPump.sGrade			));//= m_nGrade;
		cTrs.m_nLevel =a2i(cPaidTrs.cTagPump.sLevel	,sizeof(cPaidTrs.cTagPump.sLevel	));//= m_nLevel;
		cTrs.m_lPump= a2l(cPaidTrs.cTagPump.sPump			,sizeof(cPaidTrs.cTagPump.sPump			));//= m_lPump;
		cTrs.m_lMode= a2l(cPaidTrs.cTagPump.sMode			,sizeof(cPaidTrs.cTagPump.sMode			));//= m_lMode;
		cTrs.m_lRes= (PumpReservation)a2l(cPaidTrs.cTagPump.sRes			,sizeof(cPaidTrs.cTagPump.sRes			));//= m_lRes;
		cTrs.m_lResExt= (PumpResExt)a2l(cPaidTrs.cTagPump.sResExt		,sizeof(cPaidTrs.cTagPump.sResExt		));//= m_lResExt;

		cTrs.m_lLinkNumber= a2l(cPaidTrs.cTagPump.sLinkNumber		,sizeof(cPaidTrs.cTagPump.sLinkNumber));//= m_lLinkNumber;
		cTrs.m_nLinkFlags = a2i(cPaidTrs.cTagPump.sLinkFlags		,sizeof(cPaidTrs.cTagPump.sLinkFlags		));//= m_nLinkFlags;

		cTrs.m_lActiveReadNumber= a2l(cPaidTrs.cTagPump.sActiveReadNumber,sizeof(cPaidTrs.cTagPump.sActiveReadNumber ));
		cTrs.m_lActiveShiftNumber= a2l(cPaidTrs.cTagPump.sActiveShiftNumber,sizeof(cPaidTrs.cTagPump.sActiveShiftNumber ));
		cTrs.m_lMisc= a2l(cPaidTrs.cTagPump.sMisc		,sizeof(cPaidTrs.cTagPump.sMisc));//= m_lMisc
		SYSTEMTIME sysTime;
		sysTime.wYear  = a2i(cPaidTrs.cTagPump.sDateTime.sYear,sizeof(cPaidTrs.cTagPump.sDateTime.sYear) );
		sysTime.wMonth = a2i(cPaidTrs.cTagPump.sDateTime.sMonth,sizeof(cPaidTrs.cTagPump.sDateTime.sMonth) );
		sysTime.wDay   = a2i(cPaidTrs.cTagPump.sDateTime.sDay,sizeof(cPaidTrs.cTagPump.sDateTime.sDay) );
		sysTime.wHour  = a2i(cPaidTrs.cTagPump.sDateTime.sHour,sizeof(cPaidTrs.cTagPump.sDateTime.sHour) );
		sysTime.wMinute= a2i(cPaidTrs.cTagPump.sDateTime.sMinute,sizeof(cPaidTrs.cTagPump.sDateTime.sMinute) );
		sysTime.wSecond= a2i(cPaidTrs.cTagPump.sDateTime.sSecond,sizeof(cPaidTrs.cTagPump.sDateTime.sSecond) );
		cTrs.SetTime(sysTime);

		//TD 40492, 38654
		SYSTEMTIME sysStartTime;
		sysStartTime.wYear  = a2i(cPaidTrs.cTagPump.sStartDateTime.sYear,sizeof(cPaidTrs.cTagPump.sStartDateTime.sYear) );
		sysStartTime.wMonth = a2i(cPaidTrs.cTagPump.sStartDateTime.sMonth,sizeof(cPaidTrs.cTagPump.sStartDateTime.sMonth) );
		sysStartTime.wDay   = a2i(cPaidTrs.cTagPump.sStartDateTime.sDay,sizeof(cPaidTrs.cTagPump.sStartDateTime.sDay) );
		sysStartTime.wHour  = a2i(cPaidTrs.cTagPump.sStartDateTime.sHour,sizeof(cPaidTrs.cTagPump.sStartDateTime.sHour) );
		sysStartTime.wMinute= a2i(cPaidTrs.cTagPump.sStartDateTime.sMinute,sizeof(cPaidTrs.cTagPump.sStartDateTime.sMinute) );
		sysStartTime.wSecond= a2i(cPaidTrs.cTagPump.sStartDateTime.sSecond,sizeof(cPaidTrs.cTagPump.sStartDateTime.sSecond) );
		cTrs.SetStartTime(sysStartTime);

		//4.0.22.511 72606
		SYSTEMTIME sysStartFuelingTime;
		//cTrs.m_cTime(cPaidTrs.cTagPump2.sDateTime);
		sysStartFuelingTime.wYear  = a2i(cPaidTrs.cTagPump.sStartDateTime.sYear,sizeof(cPaidTrs.cTagPump.sStartDateTime.sYear) );
		sysStartFuelingTime.wMonth = a2i(cPaidTrs.cTagPump.sStartDateTime.sMonth,sizeof(cPaidTrs.cTagPump.sStartDateTime.sMonth) );
		sysStartFuelingTime.wDay   = a2i(cPaidTrs.cTagPump.sStartDateTime.sDay,sizeof(cPaidTrs.cTagPump.sStartDateTime.sDay) );
		sysStartFuelingTime.wHour  = a2i(cPaidTrs.cTagPump.sStartDateTime.sHour,sizeof(cPaidTrs.cTagPump.sStartDateTime.sHour) );
		sysStartFuelingTime.wMinute= a2i(cPaidTrs.cTagPump.sStartDateTime.sMinute,sizeof(cPaidTrs.cTagPump.sStartDateTime.sMinute) );
		sysStartFuelingTime.wSecond= a2i(cPaidTrs.cTagPump.sStartDateTime.sSecond,sizeof(cPaidTrs.cTagPump.sStartDateTime.sSecond) );
		cTrs.SetStartFuelingTime(sysStartFuelingTime);
	}
	else
	{
		CString str;
		str.Format("CServerMain::GetTrsFromPaidQdx Did not  found trs in paid qdx.trs number %ld",lTrsNumber);
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
	return bRetCode;




}


//4.0.11.503
/******************************************************************************
 Description:Find trs in paid QDX and return to setTrsState
 Returns:      
 Parameters:  lAddToPumpNumber - in case the pos save to qdx we have to add 100 to
				PumpNumber
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			27/11/2005				Start
******************************************************************************/
BOOL CServerMain::InsertToPaidQDX(CPumpTransact & trs,long lAddToPumpNumber)
{
	BOOL bRetCode = FALSE;
	long lRtc =0,lFoundInLoyalty=  0;
	PAID_TRS_EX cPaidTrs;
	EXTRA_INFO_REC sExtraInfoRec;
	CString str;
	try
	{
		if (m_cSQLPaidTrsFile.GetPaidTrsActive())   //4.0.13.740
		{
			memset(&cPaidTrs,' ',sizeof(PAID_TRS_EX));
			sExtraInfoRec.ClearRecord(); // RFUEL-3708
			sExtraInfoRec.info.lIndexNumber = trs.m_lNumber; 

			


			lRtc = IndexOperation(EXTRA_INFO_FILE,REC_READ, &sExtraInfoRec);
			//Verify if we have loyalty id  
			if(lRtc == OK)
			{
				if(!(ChrAll((char*)sExtraInfoRec.info.sLoyalId,sizeof(sExtraInfoRec.info.sLoyalId),' ')))
				{
					lFoundInLoyalty = 1;
					cPaidTrs.bOnOffer = '1';//the trs was paid with loyalty
					m_cLogger.LogMsg("CServerMain::InsertToPaidQDX Found loyalty card Trs will not insert to Paid QDX ");
				}
				else
				{
					long lLyoltyID = a2l(sExtraInfoRec.info.sLoyalId,sizeof(sExtraInfoRec.info.sLoyalId));
					
					str.Format("CServerMain::InsertToPaidQDX loyalty =  %ld ",lLyoltyID);
					m_cLogger.LogMsg(str);
				}
			}
			else
				{
				str.Format("CServerMain::InsertToPaidQDX no loyalty id trsNumber = %ld ",trs.m_lNumber);
				m_cLogger.LogMsg(str);
							}
		
			if(!lFoundInLoyalty)
			{
				long lServiceMode=0;
				trs.UpdateTime();
				trs.GetTag(&cPaidTrs.cTagPump,2);
				long lTmpPumpNumber = a2l(cPaidTrs.cTagPump.sPump,sizeof(cPaidTrs.cTagPump.sPump));
				if(lAddToPumpNumber!=0)//the pos ask the trs
				{
					lServiceMode = m_cPumpArray[lTmpPumpNumber-1].GetStat().GetServiceMode();	 //4.0.14.504	
					cPaidTrs.lServiceMode = lServiceMode;	
					lTmpPumpNumber = lAddToPumpNumber;
				}
				str.Format("CServerMain::InsertToPaidQDX Insert to Paid QDX with pump number %ld",lTmpPumpNumber);
				m_cLogger.LogMsg(lTmpPumpNumber,LOG_PUMP,str);

				
				l2a(lTmpPumpNumber,cPaidTrs.cTagPump.sPump,sizeof(cPaidTrs.cTagPump.sPump));
				lRtc = IndexOperation(PAID_TRS_FILE,REC_INSERT,&cPaidTrs);
			}

		}
	}
	catch(...)
	{
		m_cLogger.LogMsg("CServerMain::InsertToPaidQDX Exception!!!!!",LOG_LEVEL_1);
	}
	if(!(lRtc))
		bRetCode = TRUE;
	return bRetCode;
}

GCIRetCode CServerMain::ChangeTrsToNotOnOffer(CPumpTransact & cTrs,long lTerminalNumber,long lPumpNumber)
{
	GCIRetCode retCode;
	CString sMsg;
	if((cTrs.GetStatus() == UNPAID)||(cTrs.GetStatus() == ACCEPTED))
	{										
		if(cTrs.GetOnOffer() == lTerminalNumber)						
		{	
			OLA_STAT  ola;
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

			cTrs.SetOnOffer(0);
			cTrs.SetStatus(UNPAID);																	
			CentralUpdateTrs(lPumpNumber,cTrs.m_lNumber,&cTrs,FALSE);
			
			m_cPumpArray[lPumpNumber - 1].GetOlaStat(&ola);
			
			
			if (( SESSION_TYPE(ola.m_byState) == SESSION_CAPTURE ) || 
				( SESSION_TYPE(ola.m_byState) == SESSION_SALE))
			{
				ola.m_byState = OLA_NEW_STATE(ola.m_byState,OLA_SEND_END);
				ola.m_byState = SESSION_NEW_TYPE(ola.m_byState,SESSION_CANCEL_AUTH);
				
				if(LOG_BASIC_FLOW_CONTROL)
				{
					sMsg.Format("Attendant Cancel Sale swipe !!!!!");
					_LOGMSG.LogMsg(sMsg);
				}
				
				m_cPumpArray[lPumpNumber-1].SetOlaStat(&ola); 
				SavePumpInfo(lPumpNumber);
			}
			
			retCode = GCI_OK;											
		}
		else if(cTrs.GetOnOffer() == 0)
		{
			retCode = GCI_OK;											
		}
		else
		{
			retCode = GCI_TRS_LOCKED;							
		}
	}									
	else 
	{
		retCode = GCI_TRS_NOT_FOR_SALE; // NULL_TRS, IN_PROGRESS, PAID, INCOMPLETE
	}

	return retCode;
}	

void CServerMain::SetPumpNumberToQDX(long lPumpNumber,char * sPumpNumber)
{
	constexpr int PumNumberMaxSize = 20;

	if(lPumpNumber<10)
		sprintf_s(sPumpNumber, PumNumberMaxSize, "00%ld",lPumpNumber);
	else if(lPumpNumber<100)
		sprintf_s(sPumpNumber, PumNumberMaxSize, "0%ld",lPumpNumber);
	else
		sprintf_s(sPumpNumber, PumNumberMaxSize, "%ld",lPumpNumber);
}
	

//4.0.12.501
//4.0.18.501
BOOL CServerMain::UpdateDataInCarWashTrs(CPumpTransact & cTrs,long lPumpNumber,long lSeqNumber)
{
	/*	Add new Flags in STRUCT_IS_UPDATE_OLA in method PAPReadyTransaction  , This flags will be the trigger to following functionality , 
			a.	Save Card sale data to OLA qdx
			b.	Save Card sale data to Receipt qdx
			c.	Send PAPSwipeResult to Cl2PumpSrv 
			No need to open session complete.
	*/

	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	long lRtc=0,lRtc2=0;
	CString strTmp;
	OLA_STAT ola;
	PAY_AT_PUMP_INFO info;
	RECEIPT_INFO	 cReceiptInfo;

	try
	{
			
		memset(&ola,0,sizeof(OLA_STAT));
		memset(&info,' ',sizeof(PAY_AT_PUMP_INFO) );
		memset(&cReceiptInfo, ' ' , sizeof(RECEIPT_INFO));

		long p = lPumpNumber-1;
		m_cPumpArray[p].GetPAPInfo(&info);

		long lTmp=0;
		lTmp = a2l(info.CardSaleExtraData3.sFlags1,sizeof(info.CardSaleExtraData3.sFlags1));
		lTmp ^= FL_SALE_REC; //Add flag to sale trs
		l2a(lTmp,info.CardSaleExtraData3.sFlags1,sizeof(info.CardSaleExtraData3.sFlags1));
		
		info.CardSaleInfo.cardData.sTranStatus =  CD_APPROVE_OK;
		info.CardSaleInfo.lIndexNumber = NewOLAIndex();
		cTrs.SetLink(TRS_LINK_OLA_NUMBER, info.CardSaleInfo.lIndexNumber);
		
		m_cProtectedDataHandler.GenerateIndex(&info, lPumpNumber, TRUE);	 

		lRtc = TrsLinkOperation(REC_INSERT,&cTrs, &info);	
		m_cBaseReceipt->ConvertOlaToReceipt(&cTrs, &info, &cReceiptInfo,0); //4.0.20.501 TD 60236

		CReceiptInfo ReceiptInfo;
		_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(&cTrs, &info, ReceiptInfo);//4.0.9.503
		long lRtc2 = CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

		if (lRtc)
		{
			strTmp.Format("Fail !!!! Update  Receipt Record " );
			_LOGMSG.LogMsg("CServerMain","UpdateDataInCarWashTrs",p + 1,LOG_PUMP,strTmp);
						
		}
		else
		{
			m_cMemPumpArray[p].SetMemPumpInfo(&info ,&cTrs,&cReceiptInfo); //4.0.30.0 270322
		}
	}
	catch(...)
	{
		strTmp.Format("Had UnExcpcted Error - UpdateDataInCarWashTrs" );
		_LOGMSG.LogMsg("CServerMain","UpdateDataInCarWashTrs",lPumpNumber,LOG_PUMP,strTmp,LOG_LEVEL_1);

	}

	if(LOG_BASIC_FLOW_CONTROL)
	{
		strTmp.Format("Insert Index=%ld to Ola QDX - %ld  and to Recepit QDX - %ld",info.CardSaleInfo.lIndexNumber ,lRtc,lRtc2 );
		_LOGMSG.LogMsg("CServerMain","UpdateDataInCarWashTrs",lPumpNumber,LOG_PUMP,strTmp);
	}

	//4.0.14.850
	if (lPumpNumber)
	{
		 m_cPumpArray[lPumpNumber-1].SetPAPInfo(&info);    //4.0.14.850

		 SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);

		SavePumpInfo(lPumpNumber);
	}
	//4.0.14.850

	return lRtc;

}

//4.0.12.501
void CServerMain::UpdatePAPDeclineTimers(long lThrdSleepTime)
{
	long lPumpNum;

	//4.0.13.73
	if (GetPAPDeclineTimeValue())
	{

		for (lPumpNum=0;lPumpNum<m_lLastValidPump;lPumpNum++)
		{
			CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);
			
			CPumpStatus pumpStat = m_cPumpArray[lPumpNum].GetStat();
			long lMisc = pumpStat.GetMisc();

			if(lMisc & MISC_CREDIT_CARD_DECLINE)
			{
				m_lPAPDeclineTimer[lPumpNum] += lThrdSleepTime;
				if (m_lPAPDeclineTimer[lPumpNum] >= GetPAPDeclineTimeValue() * 1000)
				{
					m_lPAPDeclineTimer[lPumpNum] = 0;

					lMisc &= MISC_NOT_CREDIT_CARD_DECLINE;

					if(lMisc & MISC_CREDIT_CARD_NOT_AUTHORIZED)
						lMisc &= MISC_NOT_CREDIT_CARD_NOT_AUTHORIZED;

					_LOGMSG.LogMsg(lPumpNum+1,LOG_PUMP,"Reset misc of MISC_CREDIT_CARD_DECLINE after timeout");

					pumpStat.SetMisc(lMisc);
					m_cPumpArray[lPumpNum].SetStat(pumpStat);
				}
			}
			else if(lMisc & MISC_AVI_NOT_AUTHORIZED) //4.0.25.501 TD 132711
			{
				m_lPAPDeclineTimer[lPumpNum] += lThrdSleepTime;
				if (m_lPAPDeclineTimer[lPumpNum] >= GetPAPDeclineTimeValue() * 1000)
				{	
					m_lPAPDeclineTimer[lPumpNum] = 0;
					lMisc &= MISC_NOT_AVI_NOT_AUTHORIZED;
					_LOGMSG.LogMsg(lPumpNum+1,LOG_PUMP,"Reset misc of MISC_AVI_NOT_AUTHORIZED after timeout");
					pumpStat.SetMisc(lMisc);
					m_cPumpArray[lPumpNum].SetStat(pumpStat);			
				}
			}
		}
	}
}


// Argument         : ICtrlEvents *pCtrlObj
//Amram1111
long CServerMain::RemoveGpiEventPtr(long lClientId)
{
	BOOL bRes = FALSE;
	long lRetVal = 0;

	bRes = m_GpiEventsObjMap.RemoveKey(lClientId);

	//checking if last client to reset client id
	if( m_CtrlEventsObjMap.IsEmpty() )
	{
		ResetCtrlEventNumerator();
	}
		
	return lRetVal;
}

// Function name	: CServerMain::AddCtrlEventClient
// Description	    : Add new CtrlEvent client to ptr map due to client id.
// Return type		: long 
// Argument         : long lClientId
// Argument         : ICtrlEvents *pCtrlObj
//Amram1111
long CServerMain::AddGpiEventClient(long lClientId, IGPIEvents *pGpiObj)
{
	long lRetVal = 0;

	m_GpiEventsObjMap.SetAt(lClientId,pGpiObj);
	
	return lRetVal;
}

long CServerMain::GetGpiEventClientId()
{
	m_lGpilEventNumerator ++;

	return m_lGpilEventNumerator;
}

//4.0.12.502
BOOL CServerMain::UpdateDeclinePAP(long lPumpNumber,long lTrsNumber)
{
		
	PRE_PAY_INFO	cTmpPrePayinfo;
	long lVal = 0;
	long lRetVal=0;
	long lRtc = 0;
	CPumpTransact trs;
	CString str;

	if(LOG_BASIC_FLOW_CONTROL)
	{
		str.Format("UpdateDeclinePAP - Update decline PRP for trs %ld",lTrsNumber);
		m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
	memset(&trs,' ',sizeof(trs));

	trs.m_lNumber = trs.m_lLinkNumber = lTrsNumber;
	trs.SetLink(TRS_LINK_PREPAY_NUMBER, lTrsNumber);	

	lRtc = TrsLinkOperation(REC_READ,&trs,&cTmpPrePayinfo);


	m_cPumpArray[lPumpNumber - 1].IncreaseDeclinePrePayCounter();

	if (!lRtc) // 
	{
		trs.m_lMisc += MISC_DECLINE_PRP;
		lRtc = TrsLinkOperation(REC_UPDATE,&trs,&cTmpPrePayinfo);
		//Save latest PrePay info
		
	}
	else
	{
		if(LOG_BASIC_FLOW_CONTROL)
		{
			str.Format("UpdateDeclinePAP - Update decline PRP for trs %ld",lTrsNumber);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
		}

	}

	return lRtc;
}

long CServerMain::CreateConnectToIFSFTerminalSrv()
{
	long lRetCode = S_OK;
	HRESULT hRes = 0;

	m_pIFSFTerminalSrvCtrl = NULL;

	try
	{			
		hRes = m_pIFSFTerminalSrvCtrl.CreateInstance(CLSID_IFSFTerminalCtrl);

		if(SUCCEEDED(hRes))		
		{
			m_pIFSFTerminalSrvCtrl->Start();
			lRetCode = S_OK;		
		}
		else
		{
			m_pIFSFTerminalSrvCtrl = NULL; // also release the object
			lRetCode = 1; //change!
		}
	}
	catch (_com_error& e)
	{
		m_cLogger.LogClassMsg("ServerMain","CreateConnectToIFSFTerminalSrv",0,LOG_NONE,e.ErrorMessage(),LOG_LEVEL_0);

		m_pIFSFTerminalSrvCtrl = NULL; // also release the object
		lRetCode = 1; //change!		
	}
	catch(...)
	{
		if (LOG_LOGIC_ERROR )
		{
			CString sMsg;
			sMsg.Format("CreateConnectToIFSFTerminalSrv");
			_LOGMSG.LogMsg(sMsg,LOG_LOGIC_ERROR);			
		}
	}
	
	return lRetCode;
}

long CServerMain::CloseConnectToIFSFTerminalSrv()
{
	long lRetCode = S_OK;
	HRESULT  hr = 0;
	
	if(m_pIFSFTerminalSrvCtrl != NULL)
	{
		try
		{

			m_pIFSFTerminalSrvCtrl->Stop();

			m_pIFSFTerminalSrvCtrl.Release();
			m_pIFSFTerminalSrvCtrl.Detach();
			m_pIFSFTerminalSrvCtrl = NULL;
			m_cLogger.LogMsg("IFSFTerminalSrvCtrl released successfully.");
		}
		catch (_com_error& e)  //4.0.2.26
		{
			m_cLogger.LogClassMsg("ServerMain","CloseConnectToIFSFTerminalSrv",0,LOG_NONE,e.ErrorMessage(),LOG_LEVEL_0);

			m_pIFSFTerminalSrvCtrl = NULL; // also release the object
			lRetCode = 1;		
		}
		catch(...)
		{
			m_cLogger.LogMsg("CServerMain::CloseConnectToIFSFTerminalSrv",LOG_LEVEL_1);
			m_pIFSFTerminalSrvCtrl = NULL;
			lRetCode = 1;
		}
	}
	
	return lRetCode;
}


//4.0.10.1000
void CServerMain::InsertTrsToShortCardArr(CPumpTransact * pTrs,BYTE * sShortCardName)
{
	long lPumpNumber = pTrs->m_lPump;
	long lTrsIdx = m_cPumpArray[lPumpNumber-1].GetIndexNumber(pTrs->m_lNumber); //
	
	m_cShortCardTrsArr[lPumpNumber-1].cShortCardNameTrs[lTrsIdx].lTrsNumber = pTrs->m_lNumber;
	memset(m_cShortCardTrsArr[lPumpNumber-1].cShortCardNameTrs[lTrsIdx].sShortCardName, ' ',
		sizeof(m_cShortCardTrsArr[lPumpNumber-1].cShortCardNameTrs[lTrsIdx].sShortCardName));
	
	memcpy(m_cShortCardTrsArr[lPumpNumber-1].cShortCardNameTrs[lTrsIdx].sShortCardName, sShortCardName,
		SHORT_CARD_NAME_LEN);
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("InsertTrsToShortCardArr save to Trs %ld the short card name on index %ld",pTrs->m_lNumber,lTrsIdx);
		m_cLogger.LogMsg(str);
	}

}

//4.0.10.1000
BOOL CServerMain::LoadShortCardNameFromQDX()
{
	BOOL			 bRetCode = TRUE;
	long			 lRtc=0;
	PAY_AT_PUMP_INFO cPatAtPumpInfo;
	CPumpTransact	 cTmpTrs;
	long			 lPumpNumber=0,lTrsIdx=0;	
	CString			 str;
				
	lRtc = IndexOperation(PUMP_OLA_TEMP_FILE , REC_READ_FIRST, &cTmpTrs ,&cPatAtPumpInfo); //4.0.10.49
	while(!lRtc)
	{
		str.Format("LoadShortCardNameFromQDX Found trs %ld with short card",cTmpTrs.m_lNumber);
		lTrsIdx = m_cPumpArray[cTmpTrs.m_lPump-1].GetIndexNumber(cTmpTrs.m_lNumber); 
		m_cShortCardTrsArr[cTmpTrs.m_lPump-1].cShortCardNameTrs[lTrsIdx].lTrsNumber = cTmpTrs.m_lNumber;
		
		memset(m_cShortCardTrsArr[cTmpTrs.m_lPump-1].cShortCardNameTrs[lTrsIdx].sShortCardName, ' ',
		sizeof(m_cShortCardTrsArr[cTmpTrs.m_lPump-1].cShortCardNameTrs[lTrsIdx].sShortCardName));
	
		memcpy(m_cShortCardTrsArr[cTmpTrs.m_lPump-1].cShortCardNameTrs[lTrsIdx].sShortCardName,
			cPatAtPumpInfo.CardSaleInfo.cardData.sCardName,
			sizeof(cPatAtPumpInfo.CardSaleInfo.cardData.sCardName));

		lRtc = IndexOperation(PUMP_OLA_TEMP_FILE , REC_READ_NEXT, &cTmpTrs ,&cPatAtPumpInfo); //4.0.10.49
	}
		
		
		return lRtc;

}

//4.0.12.515
/******************************************************************************
 Description: Perform rollback of price change. 
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ravit			06/03/2006				Start
******************************************************************************/

void CServerMain::RollbackPriceChange()
{

	DWORD dwTmp = 0;
	SYSTEMTIME curSysTime;
	SZ_TAG_SYSTEMTIME szTagTime;
	GetLocalTime(&curSysTime);	
	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));

	int i;

	if (LOG_DETAIL_FLOW_CONTROL)		
	{
		CString sMsg;
		sMsg.Format("Perform rollback of price change");
		_LOGMSG.LogMsg(sMsg);
	}

	for(i=1; i<=MAX_GRADES_99; i++)
	{

		CString str("Grades\\Grade");
		char sNumber[8];
		memset(sNumber,0,sizeof(sNumber));

		sprintf_s(sNumber, _countof(sNumber),"%02d",i);
		str += sNumber;

		m_cParam.LoadParam((LPCSTR)str, "Previous_PriceCash_SelfService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
		if(dwTmp > 0)
		{
			//Save the price from the previos. 
			m_cParam.SaveParam((char *)(LPCSTR)str, "New_PriceCash_SelfService",dwTmp,TRUE,0,0,0,TRUE);
			//Reset the previous price 
			m_cParam.SaveParam((char *)(LPCSTR)str, "Previous_PriceCash_SelfService",(DWORD)0,TRUE,0,0,0,TRUE);
		}

		m_cParam.LoadParam((LPCSTR)str, "Previous_PriceCash_FullService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
		if(dwTmp > 0)
		{
			m_cParam.SaveParam((char *)(LPCSTR)str, "New_PriceCash_FullService",dwTmp,TRUE,0,0,0,TRUE);
			m_cParam.SaveParam((char *)(LPCSTR)str, "Previous_PriceCash_FullService",(DWORD)0,TRUE,0,0,0,TRUE);
		}

		m_cParam.LoadParam((LPCSTR)str, "Previous_PriceCredit_SelfService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
		if(dwTmp > 0)
		{
			m_cParam.SaveParam((char *)(LPCSTR)str, "New_PriceCredit_SelfService",dwTmp,TRUE,0,0,0,TRUE);
			m_cParam.SaveParam((char *)(LPCSTR)str, "Previous_PriceCredit_SelfService",(DWORD)0,TRUE,0,0,0,TRUE);
		}

		m_cParam.LoadParam((LPCSTR)str, "Previous_PriceCredit_FullService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
		if(dwTmp > 0)
		{
			m_cParam.SaveParam((char *)(LPCSTR)str, "New_PriceCredit_FullService",dwTmp,TRUE,0,0,0,TRUE);
			m_cParam.SaveParam((char *)(LPCSTR)str, "Previous_PriceCredit_FullService",(DWORD)0,TRUE,0,0,0,TRUE);
		}

	}

	SystemTime2Tag(&curSysTime,&szTagTime.sTime);	

	//Save the flags in order to operate the price change process.
	m_cPriceChangeFlags.SavedFlags(szTagTime,0);

}

/******************************************************************************
 Description: Treat pending commit after failure
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shuki			20/02/2011				Start
******************************************************************************/
void CServerMain::PriceChangePendingCommitAfterFailure()
{
	SZ_TAG_SYSTEMTIME szTagTime;
	memset(&szTagTime,0,sizeof(SZ_TAG_SYSTEMTIME));						
	SYSTEMTIME curSysTime;
	GetLocalTime(&curSysTime);					
	SystemTime2Tag(&curSysTime,&szTagTime.sTime);

	m_cPriceChangeFlags.SavedFlags(szTagTime , 0);
}

//4.0.12.517
/******************************************************************************
 Description: Perform price change failure operations. 
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ravit			06/03/2006				Start
******************************************************************************/

void CServerMain::PriceChangeFailure()
{

	DWORD dwTmp = 0;
	long lGrade = 1;
	BOOL bPreviousExist = FALSE;
	CString strGrade;
	char sNumber[8];

	if (LOG_DETAIL_FLOW_CONTROL)		
	{
		CString sMsg;
		sMsg.Format("Price change process failed");
		m_cLogger.LogMsg(sMsg,LOG_LEVEL_1);
	}

	//Perform the rollback only if the flag is on and there is information in the previous grades. 
	if (IsRollbackOnPriceChangeFailure())
	{

		//Check for every grade if the previous grade is exist, if one previous is exist, we will perform the rollback.
		for(lGrade = 1; lGrade <= MAX_GRADES; lGrade++)
		{
			strGrade = "Grades\\Grade";
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",lGrade);
			strGrade += sNumber;

			m_cParam.LoadParam((LPCSTR)strGrade, "Previous_PriceCash_SelfService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
			if ((long)dwTmp>0)
			{
				bPreviousExist = TRUE;
				break;
			}

			m_cParam.LoadParam((LPCSTR)strGrade, "Previous_PriceCredit_SelfService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
			if ((long)dwTmp>0)
			{
				bPreviousExist = TRUE;
				break;
			}

			m_cParam.LoadParam((LPCSTR)strGrade, "Previous_PriceCash_FullService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
			if ((long)dwTmp>0)
			{
				bPreviousExist = TRUE;
				break;
			}

			m_cParam.LoadParam((LPCSTR)strGrade, "Previous_PriceCredit_FullService",&dwTmp,(DWORD)0,FALSE,FALSE,0,HOP_DIRECT_LOCAL,TRUE);
			if ((long)dwTmp>0)
			{
				bPreviousExist = TRUE;
				break;
			}

		}

		//Perform the rollback only if the flag is on and there is information in the previous grades. 
		if (bPreviousExist)
		{
			//The original price change process is over, now only the rollback process will be operated.
			SetInOriginalPriceChangeProcess(FALSE); //TD 44435 //4.0.17.11
			CString sMsg;
			sMsg.Format("Reset the Original Price Change Process flag");
			m_cLogger.LogMsg(sMsg);

			RollbackPriceChange();
		}
	}

	//End of price change process
	SetInPriceChangeProcess(FALSE); //4.0.12.518
	m_cServerInfo.SetInPriceChangeWithIntegrityProcessFlags(PRICE_CHANGE_WITH_INTEGRITY_NONE); //4.0.26.508 147183 
	
 	SetPriceChangeResponse(GOT_PRICE_CHANGE_FAILURE);
	
	m_cParam.LoadParam("GeneralParam","PriceChangeBatchNumber",&dwTmp, (DWORD)0, FALSE, 0, HOP_DIRECT_LOCAL,TRUE); //4.0.27.43

	m_cAlarm.AddSendMessage(CATEGORY_DEVICES, SUB_PRICE_POLE, GRADE_PRICE_UPDATE_FAILURE, 1, ALARM_STARTED, (long)dwTmp, 0);
	m_cAlarm.AddSendMessage(CATEGORY_PUMP, SUB_PRICE_CHANGE, PRICE_CHANGES_PROCESS_FAILED, GetPriceChangeResponseDeviceNum(), ALARM_STARTED, (long)dwTmp, 0); //4.0.27.30 TD 223183

	SetPriceChangeBatchNumber(0);
	SetPriceChangeResponseDeviceNum(0);
}

//4.0.12.517
/******************************************************************************
 Description: Perform price change success operations. 
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ravit			06/03/2006				Start
 ShukiY         20/02/2011              Support price integrity
******************************************************************************/

void CServerMain::PriceChangeSuccess()
{
	
	if (LOG_DETAIL_FLOW_CONTROL)		
	{
		CString sMsg;
		sMsg.Format("Price change process succeeded");
		m_cLogger.LogMsg(sMsg);
	}

	SetInPriceChangeProcess(FALSE); 
	
	long lBatch = GetPriceChangeBatchNumber(); 

	SetPriceChangeBatchNumber(0);

	//**********************************************************************************/
	//Inform POS only in case of success of automatic - NOT in manual or pending commit (after failure):
	//**********************************************************************************/
	if (IsActivePricePole() && !m_cServerInfo.IsInCommitPriceChangeWithIntegrityProcess())
		SetPriceChangeResponse(GOT_PRICE_CHANGE_SUCCESS);  //- will cause pop up in POS.
	else
		SetPriceChangeResponse(PRICE_CHANGE_NO_RESPONSE);

	//4.0.26.508 147183
	m_cServerInfo.SetInPriceChangeWithIntegrityProcessFlags(PRICE_CHANGE_WITH_INTEGRITY_NONE); 

	m_cParam.SaveParam("GeneralParam","PriceChangeBatchNumber",(DWORD)0,TRUE,_HOST.m_lGroupNum,0,0,TRUE); //4.0.27.43			

	long lRetVal = m_cAlarm.AddSendMessage(CATEGORY_PUMP, SUB_PRICE_CHANGE, PRICE_CHANGE_SUCCESS, 1, ALARM_STARTED, lBatch, 0);
         lRetVal = m_cAlarm.AddSendMessage(CATEGORY_PUMP, SUB_PRICE_CHANGE, PRICE_CHANGE_ENDED, 0, ALARM_STARTED, lBatch, 0);

	if(LOG_DETAIL_FLOW_CONTROL)  // 4.0.29.501 TD 290189
	{	
		CString sMsg; 				
		sMsg.Format("PriceChangeSuccess send alarm, lCatagory=%ld ,lSubCatagory=%ld,lAlarmNumber=%ld,lDevice=%ld,lAlarmStatus=%ld,lAlarmValue=%ld , lRetVal=%ld " ,
						CATEGORY_PUMP, SUB_PRICE_CHANGE, PRICE_CHANGE_SUCCESS, 0, ALARM_STARTED, lBatch, lRetVal);
		_LOGMSG.LogMsg(sMsg);
	}	


}

/******************************************************************************
 Description: Perform price change success operations. 
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			10/01/2011				Start 4.0.26.508 147183
******************************************************************************/

void CServerMain::PriceChangeCommit()
{
	if (LOG_DETAIL_FLOW_CONTROL)		
	{
		CString sMsg;
		sMsg.Format("Starting price change commit");
		m_cLogger.LogMsg(sMsg);
	}

	long lBatch = GetPriceChangeBatchNumber();
	
	//for recovery only:
	m_cServerInfo.SetInPriceChangeWithIntegrityProcessFlags(PRICE_CHANGE_WITH_INTEGRITY_GOT_COMMIT);
	
	long lFlags = MAX_UNIT_IS_BATCH_NUM | PRICE_CHANGE_COMMIT_PUMPS_ONLY;
	ActivatePriceChangeProcess(lFlags, lBatch);

	//Sent the commit alarm:
	m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,GOT_COMMIT_PRICE_CHANGE_COMMAND,0,ALARM_STARTED,lBatch,0); 
	
}

//4.0.12.518
void CServerMain::SetInPriceChangeProcess(BOOL bInPriceChangeProcess)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	m_cServerInfo.SetInPriceChangeProcess(bInPriceChangeProcess);

	SQLPumpSrvFile.SaveServerInfo();
}

//4.0.13.500
void CServerMain::CheckPrPTimerForTrs(CPumpTransact trs, long lPumpNum)
{
	CTime cCurTime = CTime::GetCurrentTime();
	CTimeSpan ts;

	//Check if we reach UnbalancedPrPTimer, then update the trs.
	if(trs.GetStatus() == ACCEPTED)
	{
		//check if it is a PrePay trs and the timer is not 0.
		if ((trs.GetRes() == PRE_PAY_AT_POS) && (GetUnbalancedPrPTimer() > 0))
		{
			if(cCurTime > trs.GetTime())
			{
				ts = cCurTime - trs.GetTime();				
				if(ts.GetTotalSeconds() >= GetUnbalancedPrPTimer())
				{

					CMD_STRUCT_RELEASE_PUMP cmdReleaseSinglePump;

					memset(&cmdReleaseSinglePump, 0 , sizeof(CMD_STRUCT_RELEASE_PUMP));

					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("Reach to UnbalancedPrPTimer, move the trs to Paid, and unblock the pump lock.");
						_LOGMSG.LogMsg(lPumpNum,LOG_PUMP,str);	
					}

					//Unlock the pump
					cmdReleaseSinglePump.lRes = PUMPSRV;
					cmdReleaseSinglePump.lResExt = IDLE;
					SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER,lPumpNum,&cmdReleaseSinglePump,sizeof(CMD_STRUCT_RELEASE_PUMP));


					if (LOG_BASIC_FLOW_CONTROL)
					{
						CString sLogStr;
						sLogStr.Format("Sent a command to release pump %d\n", lPumpNum);
						_LOGMSG.LogMsg(lPumpNum,LOG_PUMP,sLogStr); 				
					}
					//Changing the state to PUMP_WAIT_TO_BE_EXCLUSIVELY_LOCKED in the state machine
					m_cSinglePumpLock.SetPumpStateWaitUnlocked(lPumpNum);

					//The set trs to paid will be performed after the convert layer will send- SetPumpStatus(READY,NULL)

				}
			}
		}
	}
}


//4.0.5550.1504
void CServerMain::DataBaseMaintenanceTimeout(long lThrdSleepTime)
{

	if (m_cServerInfo.GetServerReservation() & DATABASE_MAINTENANCE)
	{
		m_lDataBaseMaintenanceTimer += lThrdSleepTime;
		if (m_lDataBaseMaintenanceTimer >= GetDataBaseMaintenanceTimeout() * 1000)
		{				
			//Unlock the database maintenance lock.
			m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_FORCED_UNLOCK);

			m_cServerInfo.SetServerReservation(UNLOCK_BY_TIMER);

			SetServerLockStatus(IGNORE_LOCK_STATUS);

			//4.0.5550.2001
			m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,DATABASE_MAINTENANCE_TIMEOUT,1,1,0,0);

			//reset the timer.
			m_lDataBaseMaintenanceTimer = 0;
		}
	}
	else
	{
		//reset the timer.
		m_lDataBaseMaintenanceTimer = 0;
	}
}


/******************************************************************************
 Description:When new transaction create clean garbage records from past that remaind in the system
 Returns:    None
 Parameters: Transaction Number  	
				
 //4.0.10.10
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 marik			20/07/2006				Start
******************************************************************************/
void CServerMain::CheckVlidityTransactionNumber(long lTrsNumber)
{
	EXTRA_INFO_REC	ExtraInfoRec;
	long lRtc= 0;
	CString str;

	// check for exist exatrainfo records.
	memset(&ExtraInfoRec , 0, sizeof(EXTRA_INFO_REC));
	ExtraInfoRec.info.lIndexNumber = lTrsNumber;
	lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);

	if (!lRtc)
	{
		//Delete old record.
		lRtc = IndexOperation(EXTRA_INFO_FILE, REC_DELETE, &ExtraInfoRec);

		if(LOG_BASIC_FLOW_CONTROL)
		{
			str.Format("unpredictable Extrainfo record record found Index=%ld, maintanace delete old record Rtc=%ld",lTrsNumber,lRtc );
			m_cLogger.LogMsg(str);
		}

	}

	DeleteFromAsh2000Qdx(lTrsNumber); //4.0.24.100 118124
	
}
/******************************************************************************
 Description: Retrieved	Timeout for fleet second transaction in seconds
 Returns:     Timeout 	
 Parameters:  None 

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 marik			13/06/2006   14:37		Start
******************************************************************************/

long CServerMain::GetFleetSecondTransactionTimeOut()
{
	return m_dwSecondTrsAuthTimeout;
}

/******************************************************************************
 Description:	When called, this method increases the WetstockMemoCounter 
				run time parameter by one.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			10/6/2007   18:54		Start Merge from TD 44000
******************************************************************************/
void CServerMain::IncreaseWetstockMemoCounter()
{
	//Use a new counter which is written to the INI runtime file to indicate the event number. 
	//(currnetly used by DataExport) this counter is updated every Memo event
	DWORD dwVal = 0;
	m_cParam.LoadParam("GeneralParam","WetstockMemoCounter",&dwVal,(DWORD)0, FALSE,TRUE,0,HOP_DIRECT_LOCAL,TRUE); 
	if (dwVal >= 0xFFFF) // 2 bytes
		dwVal = 0;
	dwVal++;
	m_cParam.SaveParam("GeneralParam","WetstockMemoCounter",dwVal,TRUE,0,0,0,TRUE); //4.0.15.151

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetWetStockData, Increase WetstockMemoCounter Prameter by one = %ld",dwVal); //4.0.15.161
		_LOGMSG.LogMsg(str);
	}
}
/******************************************************************************
 Description:	calculte the curent minute if fits the given interval (in minutes)
				return TRUE once.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			25/6/2007   18:54		Start TD 46793 - merge from 4.0.15.190
******************************************************************************/
BOOL CServerMain::IsTimeToProcessByMemo(const long lIntrervalMin) //4.0.19.502
{
	BOOL bRetVal = FALSE;
	static long lIsTimeToProcessByMemo = 0;
	long  lTmpTotalMinutes = 0;
	CTime cCurrentTime = CTime::GetCurrentTime(); 
	long lTmp = 0;
	
	long lCurrHour = cCurrentTime.GetHour();
	long lCurrMin = cCurrentTime.GetMinute();
 
	//	treat the time 00:??:??
	if (lCurrHour == 0)
		lCurrHour = 24;
	
	lTmpTotalMinutes = (lCurrHour * 60) + lCurrMin;

	// Check division by zero
	if ((lTmp = (lIntrervalMin / 1000) / 60) > 0) //4.0.15.200
	{
		if (!(lTmpTotalMinutes % lTmp))
		{
			lIsTimeToProcessByMemo = lIsTimeToProcessByMemo + 1 ; //we want to return TRUE only at the first time.
		}
		else
		{
			lIsTimeToProcessByMemo = 0;
		}
	}
	
	if (lIsTimeToProcessByMemo == 1)
		bRetVal = TRUE;
	else
		bRetVal = FALSE;

	return (bRetVal);
}


/******************************************************************************
 Description:	Get the flag which indicates if we arein the 
				Middle O fReceipt ReOrganize process.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			14/11/2007   18:54		Start TD //4.0.18.30 - TD 33898
******************************************************************************/
BOOL CServerMain::GetIsInTheMiddleOfDoAutomaticReceiptCheck()
{
	BOOL bVal = FALSE;
	
	bVal =  m_bIsInTheMiddleOfDoAutomaticReceiptCheck; 

	return bVal;
}

BOOL CServerMain::IsPAPEnabledDSS() //4.0.21.13 68756
{
	return (m_cProtectedDataHandler.IsPAPEnabled());
};	
BOOL CServerMain::IsPAPEnabledOLA()	//4.0.21.13 68756
{
	return m_bPAPEnabledOLA;
}


/******************************************************************************
 Description:	Set the flag which indicates if we arein the 
				Middle O fReceipt ReOrganize process.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			14/11/2007   18:54		Start TD //4.0.18.30 - TD 33898
******************************************************************************/
//4.0.18.30 - TD 33898
void CServerMain::SetInTheMiddleOfDoAutomaticReceiptCheck(BOOL bVal)
{
	m_bIsInTheMiddleOfDoAutomaticReceiptCheck = bVal;
}


/******************************************************************************
 Description:	calculte the curent minute if fits the given interval (in minutes)
				return TRUE once.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			24/2/2008   18:54		Start TD 46793 - merge from 4.0.15.190
******************************************************************************/
BOOL CServerMain::IsTimeToProcessByTime(const long lIntrervalMin) //4.0.19.502
{
	BOOL bRetVal = FALSE;
	static long lIsTimeToProcessByTime = 0;
	long  lTmpTotalMinutes = 0;
	CTime cCurrentTime = CTime::GetCurrentTime(); 
	long lTmp = 0;
	
	long lCurrHour = cCurrentTime.GetHour();
	long lCurrMin = cCurrentTime.GetMinute();
 
	//	treat the time 00:??:??
	if (lCurrHour == 0)
		lCurrHour = 24;
	
	lTmpTotalMinutes = (lCurrHour * 60) + lCurrMin;

	// Check division by zero
	if ((lTmp = (lIntrervalMin / 1000) / 60) > 0) //4.0.15.200
	{
		if (!(lTmpTotalMinutes % lTmp))
		{
			lIsTimeToProcessByTime = lIsTimeToProcessByTime + 1 ; //we want to return TRUE only at the first time.
		}
		else
		{
			lIsTimeToProcessByTime = 0;
		}
	}
	
	if (lIsTimeToProcessByTime == 1)
		bRetVal = TRUE;
	else
		bRetVal = FALSE;

	return (bRetVal);
}


//4.0.19.504 - 47559
long CServerMain::CalculateTaxValueRate(double dTmp ,long lTaxId, SALE_EXTRA_DETAILS  & cSaleExtraDetails, long  lItemIndex) //4.0.25.90 - TD 142798
{
	
	DWORD dwTaxRate = 0;
	DWORD dwTaxInc;
	CString sTaxTable;
	long lTmpTax = 0;
	double dTaxRate  = 0;
	double dTotalSale = 0;
	double dTaxAmount = 0;


	
	sTaxTable.Format("Taxes\\Tax%.2d", lTaxId);


	if ( m_cParam.CheckValidEntry((char *)(LPCTSTR)sTaxTable))
	{

		m_cParam.LoadParam((char *)((LPCTSTR)sTaxTable), "TaxRate", &dwTaxRate,(DWORD)0,FALSE); 
	
		if( dwTaxRate )
		{
			m_cParam.LoadParam((char *)((LPCTSTR)sTaxTable), "Included", &dwTaxInc,(DWORD)0,FALSE); 
			
			if(dwTaxInc) //Tax Included
			{
				cSaleExtraDetails.cItemInfo[lItemIndex].sProductTaxIncluded = 'Y'; //4.0.25.90 - TD 142798
				
				dTaxRate  = (double)dwTaxRate/100000.0 + 1.0;
				dTotalSale = dTmp/dTaxRate;
				dTaxAmount = dTmp - dTotalSale;
				lTmpTax = RoundDouble(dTaxAmount, 100); //4.0.26.0
			}
			else //Tax excluded
			{
				cSaleExtraDetails.cItemInfo[lItemIndex].sProductTaxIncluded = 'N'; //4.0.25.90 - TD 142798

				dTaxRate  = (double)dwTaxRate/100000.0;
				dTaxAmount = dTmp * dTaxRate;
				lTmpTax = RoundDouble(dTaxAmount, 100); //4.0.26.0
			}
		}
	}

	return lTmpTax;
}

void CServerMain::CalculateTaxLink(double dValue ,long *lTaxMap , long lTaxLink, SALE_EXTRA_DETAILS  & cSaleExtraDetails, long  lItemIndex) //4.0.25.90 - TD 142798
{
	for (int iTax=0; iTax <16; iTax++)
	{

		if (lTaxLink & 0x01)
		{			
			lTaxMap[iTax] = CalculateTaxValueRate(dValue , iTax + 1, cSaleExtraDetails, lItemIndex); //4.0.25.90 - TD 142798
		}

		lTaxLink = lTaxLink >> 1; 
	}
}


long CServerMain::GetTaxID(long lTax)
{
	DWORD dwTaxId;
	CString sTaxTable;	
	sTaxTable.Format("Taxes\\Tax%.2d", lTax);

	m_cParam.LoadParam((char *)((LPCTSTR)sTaxTable), "TaxID", &dwTaxId,(DWORD)0,FALSE); 
	
	return (long)dwTaxId;
}


long CServerMain::GetTaxRate(long lTax)
{
	DWORD dwTaxRate;
	CString sTaxTable;
	sTaxTable.Format("Taxes\\Tax%.2d", lTax);

	m_cParam.LoadParam((char *)((LPCTSTR)sTaxTable), "TaxRate", &dwTaxRate, (DWORD)0, FALSE);

	return (long)dwTaxRate;
}

 
/******************************************************************************
 Description: Calculate Tax and details
 Parameters :
				short nGrade , 
				SALE_EXTRA_DETAILS  & cSaleExtraDetails ,
				long lFuelValue, 
				long lWashValue , 
				long lWashProgram , 
				PAY_AT_PUMP_INFO & info 
 Return:  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			25/10/2007				Start
******************************************************************************/
void CServerMain::CalculateTax(short nGrade , SALE_EXTRA_DETAILS  & cSaleExtraDetails ,long lFuelValue, long lWashValue , long lWashProgram , PAY_AT_PUMP_INFO & info )
{
	#define MAX_TAX_BUFFER	6 


	DWORD	dwTaxLink = 0;
	double	dTmp;
	DWORD	dwTmp;
	long	lFuelTaxMap[MAX_TAXES] = {0};
	long	lCarwashTaxMap[MAX_TAXES] ={0};
	long    lTmpVal = 0;
	long	lTaxCode = 0;
	CString sWashProgram;
	long	TaxIndex = 1;

	int		iTaxPosition = 0;


// Fuel taxes
	CString sTaxTable;
	CString strGrade("Grades\\Grade");
	char sNumber[8];

	memset(sNumber,0,sizeof(sNumber));
	sprintf_s(sNumber, _countof(sNumber),"%02d",nGrade);
	strGrade += sNumber;

	if (nGrade)
	{
	
		m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "MapTaxLink", &dwTaxLink,(DWORD)0,FALSE); 
		m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "Code",        &dwTmp,(DWORD)0,FALSE); 

		dTmp = lFuelValue;
		dTmp = dTmp / 1000;


		CalculateTaxLink(dTmp ,lFuelTaxMap , dwTaxLink, cSaleExtraDetails, 0); //4.0.25.90 - TD 142798

		for (int i=0; i < MAX_TAXES; i++)
		{
			if (iTaxPosition > MAX_TAX_BUFFER)
				break;

			if (lFuelTaxMap[i])
			{
				l2a(lFuelTaxMap[i], cSaleExtraDetails.cItemInfo[0].cItemTax[iTaxPosition].sProductTaxAmount , sizeof(cSaleExtraDetails.cItemInfo[0].cItemTax[iTaxPosition].sProductTaxAmount));   
				lTaxCode = GetTaxID(i +1);
				l2a(lTaxCode ,cSaleExtraDetails.cItemInfo[0].cItemTax[iTaxPosition].sProductTaxCode , sizeof(cSaleExtraDetails.cItemInfo[0].cItemTax[iTaxPosition].sProductTaxCode)); 

				//lTmpVal = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1));
				//l2a(lFuelTaxMap[i] + lTmpVal, cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1));   
				//l2a(lTaxCode ,cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode1)); 
				long lTaxRate = GetTaxRate(i + 1);
				l2a(lTaxRate, cSaleExtraDetails.cItemTaxRate[iTaxPosition].sTransTaxRate, sizeof(cSaleExtraDetails.cItemTaxRate[iTaxPosition].sTransTaxRate));

				// VP Combina.
				switch (TaxIndex)
				{
				case 1:
						l2a(lFuelTaxMap[i], info.CardSaleInfo.extraData.sTaxAmt , sizeof(info.CardSaleInfo.extraData.sTaxAmt)); 
					break;	

				case 2:
						l2a(lFuelTaxMap[i], info.CardSaleExtraData2.sTaxAmt2 , sizeof(info.CardSaleExtraData2.sTaxAmt2)); 
					break;

				case 3:
						l2a(lFuelTaxMap[i], info.CardSaleExtraData2.sTaxAmt3 , sizeof(info.CardSaleExtraData2.sTaxAmt3)); 
					break;	

				case 4:
						l2a(lFuelTaxMap[i], info.CardSaleExtraData6.sTaxAmt4, sizeof(info.CardSaleExtraData6.sTaxAmt4));
					break;
				
				}

				TaxIndex++;

				iTaxPosition++;
			}
		}

	}		

	if (lWashProgram)
	{
		sWashProgram.Format("WashPrograms\\WashProgram%02ld", lWashProgram);

		m_cParam.LoadParam((char *)((LPCTSTR)sWashProgram), "MapTaxLink", &dwTaxLink,(DWORD)0,FALSE); 

		dTmp = lWashValue;
		dTmp = dTmp / 1000;

		CalculateTaxLink(dTmp ,lCarwashTaxMap , dwTaxLink, cSaleExtraDetails, 1); //4.0.25.90 - TD 142798

		iTaxPosition = 0; //4.0.22.481
		TaxIndex = 1;
		for (int i=0; i < MAX_TAXES; i++)
		{
			if (iTaxPosition > MAX_TAX_BUFFER)
				break;

			if (lCarwashTaxMap[i])
			{
				lTaxCode = GetTaxID(i + 1);
				l2a(lCarwashTaxMap[i], cSaleExtraDetails.cItemInfo[1].cItemTax[iTaxPosition].sProductTaxAmount , sizeof(cSaleExtraDetails.cItemInfo[1].cItemTax[iTaxPosition].sProductTaxAmount));   
				l2a(lTaxCode, cSaleExtraDetails.cItemInfo[1].cItemTax[iTaxPosition].sProductTaxCode , sizeof(cSaleExtraDetails.cItemInfo[1].cItemTax[iTaxPosition].sProductTaxCode)); 

				//lTmpVal = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1));
				//l2a(lCarwashTaxMap[i] + lTmpVal, cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount1));   
				//l2a(lTaxCode, cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode1 , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode1)); 
				long lTaxRate = GetTaxRate(i + 1);
				l2a(lTaxRate, cSaleExtraDetails.cItemTaxRate[iTaxPosition].sTransTaxRate, sizeof(cSaleExtraDetails.cItemTaxRate[iTaxPosition].sTransTaxRate));

				// VP Combina.
				switch (TaxIndex)
				{
				case 1:
						l2a(lCarwashTaxMap[i], info.CardSaleInfo.extraData.sTaxAmt, sizeof(info.CardSaleInfo.extraData.sTaxAmt));	
					break;	

				case 2:
						l2a(lCarwashTaxMap[i], info.CardSaleExtraData2.sTaxAmt2, sizeof(info.CardSaleExtraData2.sTaxAmt2));	
					break;

				case 3:
						l2a(lCarwashTaxMap[i], info.CardSaleInfo.extraData.SALES[0].sTax, sizeof(info.CardSaleInfo.extraData.SALES[0].sTax));
					break;	
				
				}

				TaxIndex++;


				iTaxPosition++;
			}
		}
	}

}


/******************************************************************************
 Description: Calculate the transaction total taxes according to products

 Parameters : SALE_EXTRA_DETAILS  & cSaleExtraDetails               
 Return:	  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella			30/08/2010				Start		4.0.25.90 - TD 142798
******************************************************************************/
void CServerMain::SetTotalTrsTaxes(SALE_EXTRA_DETAILS  & cSaleExtraDetails)
{
	//Set transaction taxes
	for (int iItemIndex = 0; iItemIndex < MAX_PRODUCTS; iItemIndex++)
	{
		for (int iTaxIndex = 0; iTaxIndex < MAX_TAXES_PER_PRODUCT; iTaxIndex++)
		{
			long lProductTaxCode = a2l(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxCode, sizeof(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxCode));
			
			if (lProductTaxCode > 0)
			{
				for (int iTaxPosition = 0; iTaxPosition < MAX_TAXES_PER_PRODUCT; iTaxPosition++)
				{
					long lTransTaxCode = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode, sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode));
					if ((lTransTaxCode == 0) || (lTransTaxCode == lProductTaxCode))
					{
						long lTransTaxAmount = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount));
						long lProductTaxAmount = a2l(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxAmount, sizeof(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxAmount));
						lTransTaxAmount += lProductTaxAmount;
						l2a(lProductTaxCode, cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode, sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode));
						l2a(lTransTaxAmount, cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount, sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount));

						break;
					}
				}
			}
		}
	}
}

/******************************************************************************
 Description: Calculate the total tax amount

 Parameters : SALE_EXTRA_DETAILS  & cSaleExtraDetails               
 Return:	  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella			12/09/2010				Start		4.0.26.0 - TD 145615
******************************************************************************/
long CServerMain::CalcTotalTaxAmount(SALE_EXTRA_DETAILS  & cSaleExtraDetails)
{
	long lTotalTaxAmt = 0;
			
	for (int iTaxPosition = 0; iTaxPosition < MAX_TAXES_PER_PRODUCT; iTaxPosition++)
	{
		long lTransTaxCode = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode, sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxCode));
		if (lTransTaxCode)
		{
			BOOL bFound = FALSE;
			for (int iItemIndex = 0; iItemIndex < MAX_PRODUCTS && (!bFound); iItemIndex++)
			{
				for (int iTaxIndex = 0; iTaxIndex < MAX_TAXES_PER_PRODUCT && (!bFound) ; iTaxIndex++)
				{
					long lProductTaxCode = a2l(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxCode, sizeof(cSaleExtraDetails.cItemInfo[iItemIndex].cItemTax[iTaxIndex].sProductTaxCode));

					if (lTransTaxCode == lProductTaxCode)
					{
						if (cSaleExtraDetails.cItemInfo[iItemIndex].sProductTaxIncluded == 'N')
						{
							long lTransTaxAmount = a2l(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount , sizeof(cSaleExtraDetails.cItemTotalsTaxInfo[iTaxPosition].sTransTaxAmount));
							lTotalTaxAmt += lTransTaxAmount;
						}

						bFound = TRUE;
					}
				}
			}		
		}
	}

	lTotalTaxAmt *= 10;

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("CServerMain::CalcTotalTaxAmount, TotalTaxAmount = %ld", lTotalTaxAmt);
		_LOGMSG.LogMsg(str);
	}

	return lTotalTaxAmt;
}


//4.0.13.200 //4.0.14.660
/******************************************************************************
 Description: Update OLA record , with transaction details and tax rate.
 Parameters :
               long lPumpNumber, 
			   long lTrsNumber,  
			   short nNozzle , 
			   long lVolume,
			   long lValue, 
			   short nLevel,
			   long lGradePrice,  
			   short nGrade , 
			   CPumpTransact &	trs , 
			   SALE_EXTRA_DETAILS  & cSaleExtraDetails
 Return:  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			25/10/2007				Start
 Liat			27/12/2007				Update
******************************************************************************/
void CServerMain::UpdateCardSaleData(long lPumpNumber, long lTrsNumber,  short nNozzle,long lVolume,long lValue,short nLevel,long lGradePrice,  short nGrade ,PAY_AT_PUMP_INFO * pPAPInfo, CPumpTransact & trs ,SALE_EXTRA_DETAILS  & cSaleExtraDetails)
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	DWORD		dwTmp;
	char		sTmpStr[MAX_FIELD_VAL] = {0};
	long		p =  lPumpNumber -1;
	DWORD		dwFuelLoyalApp = 0;
	CString		strGrade("Grades\\Grade");
	CString		strCarWash;
	char		sNumber[8];
	BYTE *		pTmp;
	long		lLen = sizeof(PAY_AT_PUMP_INFO);
	GPIRetCode	lRetCode = GPI_OK;
	long		lItemIndex = 0;
	DWORD       dwDiscountPerMinGals = m_CarWashGeneralDefinitions.dwDiscountPerMinGals;

	if (trs.GetRes() != PAY_AT_PUMP)
		return;

	if (pPAPInfo)
	{
		pTmp = (BYTE *)&(pPAPInfo->CardSaleInfo);
		for(int i=0;i < lLen ; i++)
		{
			if(pTmp[i] == 0) 
				pTmp[i] = ' ';
		}

	}
	else
	{
		CString str1;
		str1.Format("CServerMain::UpdateCardSaleData Invalid info parameter");
		m_cLogger.LogMsg(str1);
		lRetCode = GPI_INVALID_FIELD_NAME;
	}


	if (lRetCode == GPI_OK)
	{
		long lCarWashVal = 0, lCarWashProgramCode = 0, lTransLoyaltyAmount = 0;
		BOOL bIsWashCodeValid = FALSE;


		if(LOG_BASIC_FLOW_CONTROL) //4.0.22.237?
		{
			CString str;
			str.Format("CServerMain::UpdateCardSaleData, lPumpNumber = %ld ,bIsWashCodeValid=%d, lLen=%ld", lPumpNumber , bIsWashCodeValid ,lLen );
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
		}

		if (trs.m_lResExt == RES_EXT_PAP_EXTERNAL)  
		{
			try
			{
				if	((m_pIFSFTerminalSrvCtrl != NULL) && (lPumpNumber > 0))
					m_pIFSFTerminalSrvCtrl->GetWashCodeValid(lPumpNumber, (long *)&bIsWashCodeValid);
			}
			catch (_com_error& e)
			{
				CString		strLog;
 				strLog.Format("UpdateCardSaleData IFSFTerminalSrv COM Exception:[%s].", e.ErrorMessage()); 
 				m_cLogger.LogMsg(strLog, LOG_LEVEL_0);
 			}

			catch (...)
			{
				CString		strLog;
				DWORD dwLastError =GetLastError();
				strLog.Format("UpdateCardSaleData IFSFTerminalSrv  LastError:[%d].", dwLastError); 
 				m_cLogger.LogMsg(strLog, LOG_LEVEL_0);
			}

		}

		if (trs.m_lResExt == RES_EXT_MOBILE)
		{
			long lCarWashProgramNum = a2l((BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sDPTProdCode, sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sDPTProdCode));
			bIsWashCodeValid = (lCarWashProgramNum > 0);
		}

		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("CServerMain::UpdateCardSaleData, bIsWashCodeValid = %d", bIsWashCodeValid);
			m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
		}
		
		//4.0.23.500 - TD 76395
		if (bIsWashCodeValid)
		{
			lCarWashProgramCode = a2l((BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sDPTProdCode,sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sDPTProdCode));

			if (LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("CServerMain::UpdateCardSaleData, sDPTProdCode = %.2s, lCarWashProgramCode=%ld", pPAPInfo->CardSaleInfo.extraData.SALES[0].sDPTProdCode, lCarWashProgramCode);
				m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
			}

			// Check if need to calculate discount per minimum gallons for C/W
			if (lValue > 0 && lVolume > 0 && lCarWashProgramCode > 0)
			{

				if (m_CarWashGeneralDefinitions.dwMinGallons > 0 && lVolume >= (long)(m_CarWashGeneralDefinitions.dwMinGallons*1000))
				{
					dwDiscountPerMinGals *= 10; //4.0.140.40
				}
			}

			lCarWashVal = a2l((BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice,sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice));

			if (LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("CServerMain::UpdateCardSaleData, sUnitPrice = %.6s, lCarWashVal=%ld, dwDiscountPerMinGals=%ld", pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice, lCarWashVal, dwDiscountPerMinGals);
				m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
			}

			// Calculate the discount for C/W and update the data
			if (dwDiscountPerMinGals > 0)
			{
				if ((long)dwDiscountPerMinGals > lCarWashVal) //4.0.140.41 - TD 60120
					dwDiscountPerMinGals = lCarWashVal;

				l2a(dwDiscountPerMinGals / 10, (BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sDiscount,sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sDiscount)); //4.0.20.504 - TD 63316
				l2a(lCarWashVal/10, (BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice,sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice)); //4.0.20.504 - TD 63316

				lCarWashVal -= dwDiscountPerMinGals; //4.0.20.504

				//Get discount code
				l2a(m_CarWashGeneralDefinitions.dwDiscountCode, cSaleExtraDetails.cItemInfo[lItemIndex+1].sProductDiscountCode, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex+1].sProductDiscountCode));
				l2a(dwDiscountPerMinGals, cSaleExtraDetails.cItemInfo[lItemIndex+1].sProductDiscountAmount, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex+1].sProductDiscountAmount));
			}
		}
		
		CalculateTax(nGrade, cSaleExtraDetails , lValue , lCarWashVal ,lCarWashProgramCode ,*pPAPInfo);

		SetTotalTrsTaxes(cSaleExtraDetails); //4.0.25.90 - TD 142798

		long lTotalTaxAmt = CalcTotalTaxAmount(cSaleExtraDetails); //4.0.26.0 - TD 145615

		long lTotalTransactionAmount = lValue  + lCarWashVal + lTotalTaxAmt;
	
		l2a(lTotalTransactionAmount , cSaleExtraDetails.sTransAmount, sizeof(cSaleExtraDetails.sTransAmount)); //4.0.26.0 - TD 145615
		
		Convertl2Str2( lTotalTransactionAmount ,pPAPInfo->CardSaleInfo.extraData.sTotalAmt_Msb,sizeof(pPAPInfo->CardSaleInfo.extraData.sTotalAmt_Msb) , pPAPInfo->CardSaleInfo.extraData.sTotalAmt, sizeof(pPAPInfo->CardSaleInfo.extraData.sTotalAmt)); //4.0.26.501 - TD 156649
		Convertl2Str2( lValue /10 ,pPAPInfo->CardSaleInfo.extraData.sFuelAmt_Msb,sizeof(pPAPInfo->CardSaleInfo.extraData.sTotalAmt_Msb) , pPAPInfo->CardSaleInfo.extraData.sFuelAmt, sizeof(pPAPInfo->CardSaleInfo.extraData.sFuelAmt));	//4.0.20.504 - TD 63316
		
		cSaleExtraDetails.cItemInfo[lItemIndex].sProductLoyaltyApplicable = 'N';

		if (nGrade)
		{
			memset(sNumber,0,sizeof(sNumber));
			sprintf_s(sNumber, _countof(sNumber),"%02d",nGrade);
			strGrade += sNumber;

			m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "LoyaltyApplicable",&dwFuelLoyalApp,(DWORD)1,FALSE);
			cSaleExtraDetails.cItemInfo[lItemIndex].sProductLoyaltyApplicable = (dwFuelLoyalApp)?'Y' : 'N';

			if (dwFuelLoyalApp)
				lTransLoyaltyAmount = lTotalTransactionAmount; //4.0.26.0 - TD 145615

			m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "FullName", (char *)sTmpStr, sizeof(sTmpStr) ,"         ",TRUE);

			memcpy(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel ,sTmpStr ,  min(sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel) , strlen(sTmpStr)));

			m_cParam.LoadParam((char *)(LPCTSTR)strGrade, "Code",&dwTmp,(DWORD)0,FALSE);

			l2a(dwTmp ,cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode , sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode));
			l2a(dwTmp ,cSaleExtraDetails.cItemInfo[lItemIndex].sProductUPCCode , sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductUPCCode));
		
			//cSaleExtraDetails.cItemInfo[lItemIndex].sProductTaxIncluded = 'Y'; //4.0.25.90 - TD 142798
		
			l2a(lValue , cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount));
			l2a(lGradePrice, cSaleExtraDetails.cItemInfo[lItemIndex].sProductUnitPrice, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductUnitPrice));

			l2a(lVolume ,cSaleExtraDetails.cItemInfo[lItemIndex].sProductQty, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductQty));

			lItemIndex++;
		}
		
		//CarWash section
		//4.0.23.500 - TD 76395
		if ((lCarWashProgramCode > 0) && (bIsWashCodeValid)) 
		{
			l2a(lCarWashVal, cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount));
			l2a((lCarWashVal+dwDiscountPerMinGals) / 10, (BYTE *)pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice,sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sUnitPrice)); //4.0.20.504 - TD 63316
					
			l2a(lCarWashVal+dwDiscountPerMinGals, cSaleExtraDetails.cItemInfo[lItemIndex].sProductUnitPrice, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductUnitPrice));

			if (dwDiscountPerMinGals > 0)
			{
				l2a(dwDiscountPerMinGals, cSaleExtraDetails.sTransDiscountAmount2, sizeof(cSaleExtraDetails.sTransDiscountAmount2));
				memcpy(cSaleExtraDetails.sTransDiscountCode2, cSaleExtraDetails.cItemInfo[lItemIndex].sProductDiscountCode, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductDiscountCode));
			}
		

			CString sWashProgramCode = GetWashProgramCode(lCarWashProgramCode-1);
			CString sWashProgramName = GetWashProgramName(lCarWashProgramCode-1);
				
 			memcpy(cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode, sWashProgramCode.GetBuffer(0), min(sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode),sWashProgramCode.GetLength()));
			memcpy(cSaleExtraDetails.cItemInfo[lItemIndex].sProductUPCCode, sWashProgramCode.GetBuffer(0), min(sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductUPCCode),sWashProgramCode.GetLength()));
			memcpy(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel, sWashProgramName.GetBuffer(0), min(sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel),sWashProgramName.GetLength()));

			if (LOG_BASIC_FLOW_CONTROL)
			{
				CString str;
				str.Format("CServerMain::UpdateCardSaleData, Wash name: sTmpStr = %.15s, cSaleExtraDetails.cItemInfo[%ld].sProductLabel = %.15s", sTmpStr, lItemIndex, cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel);
				m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
			}


			long lCarWashQty = 1;
			l2a(lCarWashQty ,cSaleExtraDetails.cItemInfo[lItemIndex].sProductQty, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductQty));

			//4.0.20.504 - TD 63316
			l2a(lCarWashQty, pPAPInfo->CardSaleInfo.extraData.SALES[0].sQty, sizeof(pPAPInfo->CardSaleInfo.extraData.SALES[0].sQty));
			pPAPInfo->CardSaleInfo.extraData.sNumberOfExtraSale = '1';
			
			cSaleExtraDetails.cItemInfo[lItemIndex].sProductLoyaltyApplicable = (m_CarWashGeneralDefinitions.dwCarWashLoyaltyApplicable)?'Y' : 'N';
		
		}	
		// End CarWash section

		l2a(lTransLoyaltyAmount , cSaleExtraDetails.sTransLoyaltyAmount, sizeof(cSaleExtraDetails.sTransLoyaltyAmount));

		memcpy(cSaleExtraDetails.sInvoiceNumber, pPAPInfo->CardSaleExtraData2.sInvoiceNumber, sizeof(pPAPInfo->CardSaleExtraData2.sInvoiceNumber));
		
		/* car wash section */
		memcpy(&cSaleExtraDetails.sProductActivationCode1 , pPAPInfo->CardSaleInfo.extraData.sWashCode , min(sizeof(pPAPInfo->CardSaleInfo.extraData.sWashCode) ,sizeof(cSaleExtraDetails.sProductActivationCode1)));
		
		cSaleExtraDetails.sLoyaltyApplicable = pPAPInfo->CardSaleInfo.extraData.sLoyaltyActive; //4.0.22.511 - TD 74795

		SetLoyaltyTenderAmount(pPAPInfo, lTotalTransactionAmount, cSaleExtraDetails); // 4.0.22.1610	TD 389480
		
		l2a(lGradePrice, pPAPInfo->CardSaleExtraData2.sGradePrice, sizeof(pPAPInfo->CardSaleExtraData2.sGradePrice));

		m_cPumpArray[p].SetPAPInfo(pPAPInfo);	
		SQLPumpSrvFile.SavePAPInfo(p + 1, __FUNCTION__, __LINE__);

		
		char xxx[1024] = {0};
			sprintf_s(xxx, _countof(xxx), "sTransAmount %.10s ,\
			sTransLoyaltyAmount=%.10s , \
			sTransDiscountCode1=%.10s, \
			sTransDiscountAmount1=%.10s \
			sTransDiscountCode2=%.10s , \
			sTransDiscountAmount2=%.10s, \
			sTransLoyaltyTenderAmount=%.10s,\
			sTransTaxCode1=%.10s, \
			sTransTaxAmount1=%.10s, \
			sTransTaxCode2=%.10s,\
			sTransTaxAmount2=%.10s,\
			sProductLoyaltyApplicable1=%c,\
			sProductAmount1=%.10s,\
			sProductUnitPrice1=%.10s,\
			sProductTaxIncluded1=%c,\
			sProductLabel1=%.10s,\
			sProductCode1=%.10s,\
			sProductUPCCode1=%.10s,\
			sProductQty1=%.10s,\
			sProductLoyaltyApplicable2=%c,\
			sProductAmount2=%.10s,\
			sProductUnitPrice2=%.10s,\
			sProductTaxIncluded2=%c,\
			sProductLabel2=%.10s,\
			sProductCode2=%.10s,\
			sProductUPCCode2=%.10s,\
			sProductQty2=%.10s,\
			sProductActivationCode1=%.10s,\
			sInvoiceNumber=%.10s,\
			Tax %.5s",\
			cSaleExtraDetails.sTransAmount,\
			cSaleExtraDetails.sTransLoyaltyAmount,\
			cSaleExtraDetails.sTransDiscountCode1,\
			cSaleExtraDetails.sTransDiscountAmount1,\
			cSaleExtraDetails.sTransDiscountCode2 ,\
			cSaleExtraDetails.sTransDiscountAmount2,\
			cSaleExtraDetails.sTransLoyaltyTenderAmount,\
			cSaleExtraDetails.cItemTotalsTaxInfo[0].sTransTaxCode,\
			cSaleExtraDetails.cItemTotalsTaxInfo[0].sTransTaxAmount,\
			cSaleExtraDetails.cItemTotalsTaxInfo[1].sTransTaxCode,\
			cSaleExtraDetails.cItemTotalsTaxInfo[1].sTransTaxAmount,\
			cSaleExtraDetails.cItemInfo[0].sProductLoyaltyApplicable,\
			cSaleExtraDetails.cItemInfo[0].sProductAmount ,\
			cSaleExtraDetails.cItemInfo[0].sProductUnitPrice,\
			cSaleExtraDetails.cItemInfo[0].sProductTaxIncluded,\
			cSaleExtraDetails.cItemInfo[0].sProductLabel,\
			cSaleExtraDetails.cItemInfo[0].sProductCode,\
			cSaleExtraDetails.cItemInfo[0].sProductUPCCode,\
			cSaleExtraDetails.cItemInfo[0].sProductQty,\
			cSaleExtraDetails.cItemInfo[1].sProductLoyaltyApplicable,\
			cSaleExtraDetails.cItemInfo[1].sProductAmount ,\
			cSaleExtraDetails.cItemInfo[1].sProductUnitPrice,\
			cSaleExtraDetails.cItemInfo[1].sProductTaxIncluded,\
			cSaleExtraDetails.cItemInfo[1].sProductLabel,\
			cSaleExtraDetails.cItemInfo[1].sProductCode,\
			cSaleExtraDetails.cItemInfo[1].sProductUPCCode,\
			cSaleExtraDetails.cItemInfo[1].sProductQty,\
			cSaleExtraDetails.sProductActivationCode1,\
			cSaleExtraDetails.sInvoiceNumber,\
			pPAPInfo->CardSaleInfo.extraData.sTaxAmt);


		if(LOG_BASIC_FLOW_CONTROL)
		{	
			m_cLogger.LogMsg(xxx);	
		}	

	}

}

/******************************************************************************
 Description: Retrieve extra details for PrePay receipt for TerminalSrv
 Parameters :
               long lPumpNumber, 
			   long lTrsNumber,  
			   CPumpTransact &trs, 
			   SALE_EXTRA_DETAILS  & cSaleExtraDetails
 Return:  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella			21/06/2009				Start		4.0.22.511 - TD 74796
 Ella			27/07/2010				Update		4.0.25.50 - TD 136915
 Ella			22/08/2010				Update		4.0.25.80 - TD 140655
******************************************************************************/
void CServerMain::UpdatePrePayExtraDetails(long lPumpNumber, long lTrsNumber, CPumpTransact & trs ,SALE_EXTRA_DETAILS  & cSaleExtraDetails, short nGrade, long lVolume, long lValue, PAY_AT_PUMP_INFO * info)
{
	if (trs.GetRes() != PRE_PAY_AT_POS)
		return;

	RECEIPT_INFO cReceiptInfo;
	PAY_AT_PUMP_INFO PayAtPumpInfo;
	EXTRA_INFO_REC	ExtraInfoRec;
	ITEMS_INFO	cItemInfo;
	long lRtc= 0;
	CString str;

	memset(&cReceiptInfo, ' ', sizeof(RECEIPT_INFO));
	memset(&PayAtPumpInfo, ' ', sizeof(PAY_AT_PUMP_INFO));
	ExtraInfoRec.ClearRecord(); // RFUEL-3708
	memset(&cItemInfo, ' ' , sizeof(ITEMS_INFO));

	//////////////////////////////////////
	// Get prepay info from receipt Qdex

	char sTrsNum[7] = {0};
	sprintf_s(sTrsNum, _countof(sTrsNum), "%ld", lTrsNumber);
	memcpy(cReceiptInfo.cReceipt1.Index.sTrack2, sTrsNum, min(strlen(sTrsNum), sizeof(sTrsNum)));
	cReceiptInfo.cReceipt1.Index.byIndex = 0;
	
	lRtc = IndexOperation(RECEIPT_FILE, REC_READ, &cReceiptInfo);				

	if(lRtc == OK)
	{
		//4.0.22.74 - TD 74796
		char sTmpAuthAmt [10] = {0};

		ConvertReceiptToOla(&cReceiptInfo, &trs, &PayAtPumpInfo);

		memcpy(sTmpAuthAmt,PayAtPumpInfo.CardSaleInfo.extraData.sAuthAmt_Msb,sizeof(PayAtPumpInfo.CardSaleInfo.extraData.sAuthAmt_Msb));
		memcpy(sTmpAuthAmt+5,PayAtPumpInfo.CardSaleInfo.cardData.sAuthAmt,sizeof(PayAtPumpInfo.CardSaleInfo.cardData.sAuthAmt));
	
		memcpy(&cSaleExtraDetails.sPreAuthAmt, sTmpAuthAmt, sizeof(sTmpAuthAmt));

	}
	

	////////////////////////////////////////////////////////
	// Get extra info record for that specific transaction	
	ExtraInfoRec.info.lIndexNumber = lTrsNumber;
	lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);

	if (!lRtc)
	{
		cSaleExtraDetails.sLoyaltyApplicable = ExtraInfoRec.info.sLoyaltyApplicable;
		cSaleExtraDetails.sTranType = ExtraInfoRec.info.sTranType;
		memcpy(cSaleExtraDetails.sPOSReferenceNumber, ExtraInfoRec.info.sPMTReferenceNumber, sizeof(ExtraInfoRec.info.sPMTReferenceNumber)); //4.0.25.50 - TD 136918
		memcpy(&cSaleExtraDetails.sLoyalId, &ExtraInfoRec.info.sLoyalId, min(sizeof(cSaleExtraDetails.sLoyalId), sizeof(ExtraInfoRec.info.sLoyalId)));		//4.0.26.508 TD 177984
	}

	long  lItemIndex = 0;

	//4.0.25.50 - TD 136915
	// Get the product name
	char sNumber[8];
	DWORD dwTmp;
	char sTmpStr[MAX_FIELD_VAL] = {0};
	CString strGrade("Grades\\Grade");

	if (nGrade)
	{
		memset(sNumber,0,sizeof(sNumber));
		sprintf_s(sNumber, _countof(sNumber),"%02d",nGrade);
		strGrade += sNumber;

		m_cParam.LoadParam((char *)((LPCTSTR)strGrade), "FullName", (char *)sTmpStr, sizeof(sTmpStr) ,"         ",TRUE);

		memcpy(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel ,sTmpStr ,  min(sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel) , strlen(sTmpStr)));

		//4.0.25.80 - TD 140655
		m_cParam.LoadParam((char *)(LPCTSTR)strGrade, "Code",&dwTmp, (DWORD)0, FALSE);
		l2a(dwTmp ,cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode , sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductCode));

		l2a(lValue , cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount, sizeof(cSaleExtraDetails.cItemInfo[lItemIndex].sProductAmount));

		CalculateTax(nGrade, cSaleExtraDetails , lValue , 0 ,0 ,*info);
		SetTotalTrsTaxes(cSaleExtraDetails); //4.0.25.90 - TD 142798

		if(LOG_BASIC_FLOW_CONTROL)
		{							
			str.Format("UpdatePrePayExtraDetails - Tax Details: sTaxAmt=%.5s, sTransTaxCode1=%.10s, sTransTaxAmount1=%.10s" , info->CardSaleInfo.extraData.sTaxAmt, cSaleExtraDetails.cItemTotalsTaxInfo[0].sTransTaxCode, cSaleExtraDetails.cItemTotalsTaxInfo[0].sTransTaxAmount);
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
		}
	}

	if(LOG_BASIC_FLOW_CONTROL)
	{							
		str.Format("UpdatePrePayExtraDetails: nGrade = %ld, sProductLabel=%.20s" , nGrade, cSaleExtraDetails.cItemInfo[lItemIndex].sProductLabel);
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}

	
	/////////////////////////////////////
	// Get items info from items qdex
	
	lItemIndex = a2l(PayAtPumpInfo.CardSaleExtraData2.sItemsLinkIndex,sizeof(PayAtPumpInfo.CardSaleExtraData2.sItemsLinkIndex));
	cItemInfo.ItemRec.lIndexNumber = lItemIndex;
	cItemInfo.ItemRec2.lIndexNumber = lItemIndex + 1;

	lRtc = IndexOperation(ITEMS_FILE,REC_READ,&cItemInfo);
	if (!lRtc)
	{
		CItemsFile cItemsFile;
		BAP_ALL_DATA_STRUCTS  cItemsRec;

		cItemsFile.ConstructItemsRecordToBAP(cItemInfo ,cItemsRec);
		
		memcpy(&cSaleExtraDetails.sDryItemsTotal, cItemsRec.cBAPReceiptItem.sItemsTotal, sizeof(cItemsRec.cBAPReceiptItem.sItemsTotal));

		if(LOG_BASIC_FLOW_CONTROL)
		{							
			str.Format("Read Index=%ld from file Items succeeded" , cItemInfo.ItemRec.lIndexNumber);
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
		}
	}	

	if(LOG_BASIC_FLOW_CONTROL)
	{							
		str.Format("UpdatePrePayExtraDetails: LoyaltyApplicable = '%c', TranType = '%c', ItemsTotal = %s" , cSaleExtraDetails.sLoyaltyApplicable, cSaleExtraDetails.sTranType, cSaleExtraDetails.sDryItemsTotal);
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
	}
}


//4.0.13.200 //4.0.14.660
/******************************************************************************
 Description: Update OLA record , with transaction details and tax rate.
 Parameters :
               long lPumpNumber, 
			   long lTrsNumber,  
			   short nNozzle , 
			   long lVolume,
			   long lValue, 
			   short nLevel,
			   long lGradePrice,  
			   short nGrade , 
			   CPumpTransact &	trs , 
			   SALE_EXTRA_DETAILS  & cSaleExtraDetails
 Return:  None
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			27/12/2007				Start
******************************************************************************/
void CServerMain::GetSaleExtraDetails__(long lPumpNumber, long lFlags, BSTR sData,  BSTR *sRetData, long *pVal)  
{
	GPIRetCode	retCode = GPI_OK;
	DWORD		dwLastErr = 0;

	PAY_AT_PUMP_INFO	info;
	memset(&info,0,sizeof(info));

	SALE_EXTRA_DETAILS  cSaleExtraDetails;
	memset(&cSaleExtraDetails , ' ', sizeof(SALE_EXTRA_DETAILS));

	CARD_SALE_ALL3 cardDataAll3;
	memset(&cardDataAll3,0,sizeof(CARD_SALE_ALL3));

	int iLen = Bstr2Buffer(sData, (void *)&cardDataAll3,sizeof(CARD_SALE_ALL3));

	if(iLen == 0)
	{
		dwLastErr = GetLastError();
		retCode = GPI_LAST_ERROR;

		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("GetSaleExtraDetails__() - lFlags = %ld, ilen = %d, last error = %ld retCode = %d", lFlags, iLen, dwLastErr, retCode);
			_LOGMSG.LogMsg("ServerMain","GetSaleExtraDetails",lPumpNumber,LOG_PUMP,str);
		}
	}

	if (retCode == GPI_OK)
	{
		info.CardSaleInfo.cardData = cardDataAll3.CardSaleAll.data;
		info.CardSaleInfo.extraData = cardDataAll3.CardSaleAll.extData;
		info.CardSaleExtraData2 = cardDataAll3.extData2;
		info.CardSaleExtraData3 = cardDataAll3.extData3;
		CPumpTransact trs;
		
		memset(&trs, 0, sizeof(trs));

		trs.m_lRes = PAY_AT_PUMP;

		UpdateCardSaleData(lPumpNumber, 0, 0, 0, 0, 0, 0, 0, &info, trs, cSaleExtraDetails);
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("lFlags=%ld ,ilen=%d UpdateCardSaleData was called", lFlags ,iLen);
			_LOGMSG.LogMsg("ServerMain","GetSaleExtraDetails",lPumpNumber,LOG_PUMP,str);
		}

		BYTE sTmp[sizeof(SALE_EXTRA_DETAILS)+2];
		Str2StrNull((BYTE *)&cSaleExtraDetails,sizeof(SALE_EXTRA_DETAILS),sTmp);
		CComBSTR strResult(sizeof(sTmp),(LPCSTR)sTmp); 
		*sRetData = strResult.Copy();
	}	

	if(pVal != NULL)
		*pVal = retCode;
}

/******************************************************************************
 Description:	Parse receipt list  received form IFSFtermianl
 Returns:      	none
 Parameters:   	ParseReceiptRowDataArray(BSTR  & sArrayBuffer, long & lRecords , long & lPosNumber)
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			29/10/2007   11:34		Start
******************************************************************************/
void CServerMain::ParseReceiptRowDataArray(BSTR  & sArrayBuffer, long & lRecords , long & lPosNumber)
{
	PAY_AT_PUMP_INFO	cPAPInfo;
	RECEIPT_TRANSACTIONS_LIST *pRec;
	long lPumpNumber = 0;
	long lVolume = 0 ;
	long lValue = 0, lTotalValue = 0; 
	BOOL bFound= FALSE;
	CPumpTransact trs;
	BYTE byIndex = 0;
	
	// Parse data only if received records.	
	if (lRecords)
	{
		pRec =  new RECEIPT_TRANSACTIONS_LIST[lRecords + 1];

		if (pRec)
		{
			memset(pRec , ' ',(sizeof(RECEIPT_TRANSACTIONS_LIST) *  (lRecords + 1)));

			int iLen = Bstr2Buffer(sArrayBuffer, (void *)pRec, (sizeof(RECEIPT_TRANSACTIONS_LIST) * lRecords));


			for (int i= 0 ; i < lRecords; i++)
			{

				memset(&cPAPInfo , ' ' , sizeof(cPAPInfo));
				lPumpNumber = 	a2l(pRec[i].sPumpNumber , sizeof(pRec[i].sPumpNumber));

				if (lPumpNumber)
				{
					trs.Clear();

					trs.m_lGradePrice = i +1;

					memcpy(cPAPInfo.CardSaleExtraData2.sInvoiceNumber , pRec[i].sInvoiceNumber , sizeof(pRec[i].sInvoiceNumber));
					memcpy(cPAPInfo.CardSaleInfo.cardData.sAuthAmt ,&pRec[i].sAuthAmount[5] , sizeof(cPAPInfo.CardSaleInfo.cardData.sAuthAmt));
					memcpy(cPAPInfo.CardSaleInfo.extraData.sAuthAmt_Msb ,pRec[i].sAuthAmount , sizeof(cPAPInfo.CardSaleInfo.extraData.sAuthAmt_Msb));
					memcpy(cPAPInfo.CardSaleInfo.cardData.sFullVehicleId, pRec[i].sVehicleId , sizeof(cPAPInfo.CardSaleInfo.cardData.sFullVehicleId));
					memcpy(cPAPInfo.CardSaleInfo.cardData.sTranNbr , cPAPInfo.CardSaleExtraData2.sInvoiceNumber , sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr));
					memcpy(&cPAPInfo.CardSaleInfo.cardData.sTrack2Data[0] , pRec[i].sInvoiceNumber , sizeof(pRec[i].sInvoiceNumber));

					lTotalValue = a2l(pRec[i].sTransTaxAmount1 , sizeof(pRec[i].sTransTaxAmount1));

					Convertl2Str2(lTotalValue ,cPAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb,sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb) , cPAPInfo.CardSaleInfo.extraData.sTotalAmt, sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt));
					

					lValue = a2l(pRec[i].sFuelAmount , sizeof(pRec[i].sFuelAmount));
					lVolume = a2l(pRec[i].sFuelVolume , sizeof(pRec[i].sFuelVolume));

					trs.m_lRoundedVolume = lVolume;
					trs.m_lRawVolume = lVolume;
					trs.m_lRoundedValue = lValue;
					trs.m_lPump = lPumpNumber;
					trs.m_lNumber  = a2l(pRec[i].sInvoiceNumber ,sizeof(pRec[i].sInvoiceNumber));

					// 4.0.140.30
					char sTmpDateAndTime[32];

					memset(sTmpDateAndTime, ' ', sizeof(sTmpDateAndTime));

					sprintf_s(sTmpDateAndTime, _countof(sTmpDateAndTime),"%.2s%.2s%.2s%.2s%.2s",
								&pRec[i].sDateTime.sYear[2], 
								pRec[i].sDateTime.sMonth,
								pRec[i].sDateTime.sDay,
								pRec[i].sDateTime.sHour,
								pRec[i].sDateTime.sMinute);

					memcpy(cPAPInfo.CardSaleInfo.extraData.sPrnDateTime, sTmpDateAndTime , sizeof(cPAPInfo.CardSaleInfo.extraData.sPrnDateTime));
					

					memcpy(cPAPInfo.CardSaleInfo.extraData.sTaxAmt , &pRec[i].sTransTaxAmount1[5], sizeof(cPAPInfo.CardSaleInfo.extraData.sTaxAmt));

					memcpy(cPAPInfo.CardSaleInfo.cardData.sAccountNumber ,pRec[i].sMaskedAccountNumber , sizeof(cPAPInfo.CardSaleInfo.cardData.sAccountNumber));

					memcpy(cPAPInfo.CardSaleExtraData2.sMediaMasterType ,pRec[i].sCardType , sizeof(cPAPInfo.CardSaleInfo.cardData.sCardType));


					Convertl2Str2( (lValue  /10) ,cPAPInfo.CardSaleInfo.extraData.sFuelAmt_Msb,sizeof(cPAPInfo.CardSaleInfo.extraData.sTotalAmt_Msb) , cPAPInfo.CardSaleInfo.extraData.sFuelAmt, sizeof(cPAPInfo.CardSaleInfo.extraData.sFuelAmt));

					cPAPInfo.CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK; 

					if (a2l(pRec[i].sTransactionStatus , sizeof(pRec[i].sTransactionStatus)))
					{
						cPAPInfo.CardSaleInfo.cardData.sTranStatus =  CD_DECLINE_DECLINED;
					}

					 byIndex++;
					m_cMemPumpArray[lPumpNumber - 1].SetMemPumpInfo(&cPAPInfo ,&trs ,NULL,byIndex); //4.0.0.6 //4.0.30.0 270322
				
					bFound = TRUE;		
				}
			}

			delete[] pRec;
		}


		if (bFound)
		{
			//Get handle Pos receipt 
			CSingleLock slPosMap( &(m_csPosMap));	
			slPosMap.Lock(INFINITE);
			CPosInfo tmpPos;
			
			if(m_cPosMap.Lookup(lPosNumber,tmpPos))
			{
				tmpPos.SendEventReceipt();
				m_cPosMap.SetAt(lPosNumber,tmpPos);

			}
			slPosMap.Unlock();				
		}
	}
}


/******************************************************************************
 Description:	Parse receipt list  recived form IFSFtermianl as OLA_REC5
 Returns:      	none
 Parameters:   	ParseReceiptRowDataArray(BSTR  & sArrayBuffer, long & lRecords , long & lPosNumber)
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Liat			19/12/2007   14:24		Start
******************************************************************************/
void CServerMain::ParseReceiptRowDataArrayAsOLARec(BSTR  & sArrayBuffer, long & lRecords , long & lPosNumber)
{	
	PAY_AT_PUMP_INFO	cPAPInfo;
	TAG_OLA_REC5_EX cTagOlaRec;
	RECEIPT_TRANSACTIONS_LIST *pRec;
	long lPumpNumber=0;
	long lVolume = 0 ;
	long lValue = 0, lTotalValue = 0; 
	BOOL bFound= FALSE;
	CPumpTransact trs;
	BYTE byIndex =0;
	
	memset(&cTagOlaRec, ' ', sizeof(cTagOlaRec));
	
	// Parse data only if received records.	
	if (lRecords)
	{
		pRec =  new RECEIPT_TRANSACTIONS_LIST[lRecords + 1];

		if (pRec)
		{
			memset(pRec , ' ',(sizeof(RECEIPT_TRANSACTIONS_LIST) *  (lRecords + 1)));

			int iLen = Bstr2Buffer(sArrayBuffer, (void *)pRec, (sizeof(RECEIPT_TRANSACTIONS_LIST) * lRecords));

			CSingleLock slPosMap1( &(m_csPosMap));	
			slPosMap1.Lock(INFINITE);

			CPosInfo tmpPos;
			if(!m_cPosMap.Lookup(lPosNumber,tmpPos))
			{
				return;
			}

			tmpPos.m_cPOSTrsList.RemoveAll();
			
			for (int i= 0 ; i < lRecords; i++)
			{

				memset(&cPAPInfo , ' ' , sizeof(cPAPInfo));
				lPumpNumber = 	a2l(pRec[i].sPumpNumber , sizeof(pRec[i].sPumpNumber));

				if (lPumpNumber)
				{
					trs.Clear();

					trs.m_lGradePrice = i +1;

					memcpy(cTagOlaRec.extraData2.sInvoiceNumber , pRec[i].sInvoiceNumber , sizeof(pRec[i].sInvoiceNumber));
					memcpy(cTagOlaRec.cardData.sAuthAmt ,&pRec[i].sAuthAmount[5] , sizeof(cTagOlaRec.cardData.sAuthAmt));
					memcpy(cTagOlaRec.extraData.sAuthAmt_Msb ,pRec[i].sAuthAmount , sizeof(cTagOlaRec.extraData.sAuthAmt_Msb));
					memcpy(cTagOlaRec.cardData.sFullVehicleId, pRec[i].sVehicleId , sizeof(cTagOlaRec.cardData.sFullVehicleId));
					memcpy(cTagOlaRec.cardData.sTranNbr , cTagOlaRec.extraData2.sInvoiceNumber , sizeof(cTagOlaRec.cardData.sTranNbr));
					memcpy(&cTagOlaRec.cardData.sTrack2Data[0] , pRec[i].sInvoiceNumber , sizeof(pRec[i].sInvoiceNumber));

					lTotalValue = a2l(pRec[i].sTransTaxAmount1 , sizeof(pRec[i].sTransTaxAmount1));

					Convertl2Str2(lTotalValue ,cTagOlaRec.extraData.sTotalAmt_Msb,sizeof(cTagOlaRec.extraData.sTotalAmt_Msb) , cTagOlaRec.extraData.sTotalAmt, sizeof(cTagOlaRec.extraData.sTotalAmt));
					

					lValue = a2l(pRec[i].sFuelAmount , sizeof(pRec[i].sFuelAmount));
					lVolume = a2l(pRec[i].sFuelVolume , sizeof(pRec[i].sFuelVolume));

					trs.m_lRoundedVolume = lVolume;
					trs.m_lRawVolume = lVolume;
					trs.m_lRoundedValue = lValue;
					trs.m_lPump = lPumpNumber;
					trs.m_lNumber  = a2l(pRec[i].sInvoiceNumber ,sizeof(pRec[i].sInvoiceNumber));

					// 4.0.140.26
					char sTmpDateAndTime[32];

					memset(sTmpDateAndTime, ' ', sizeof(sTmpDateAndTime));

					sprintf_s(sTmpDateAndTime, _countof(sTmpDateAndTime),"%.2s%.2s%.2s%.2s%.2s",
								&pRec[i].sDateTime.sYear[2], 
								pRec[i].sDateTime.sMonth,
								pRec[i].sDateTime.sDay,
								pRec[i].sDateTime.sHour,
								pRec[i].sDateTime.sMinute);

					memcpy(cTagOlaRec.extraData.sPrnDateTime, sTmpDateAndTime , sizeof(cTagOlaRec.extraData.sPrnDateTime));
					
					
					trs.Convert2PumpTrsStruct(&cTagOlaRec.tagTrs);
					 memcpy(cTagOlaRec.extraData.sTaxAmt , &pRec[i].sTransTaxAmount1[5], sizeof(cTagOlaRec.extraData.sTaxAmt));

					 memcpy(cTagOlaRec.cardData.sAccountNumber ,pRec[i].sMaskedAccountNumber , sizeof(cTagOlaRec.cardData.sAccountNumber));

					 memcpy(cTagOlaRec.extraData2.sMediaMasterType ,pRec[i].sCardType , sizeof(cTagOlaRec.cardData.sCardType));


					 Convertl2Str2( (lTotalValue  /10) ,cTagOlaRec.extraData.sFuelAmt_Msb,sizeof(cTagOlaRec.extraData.sTotalAmt_Msb) , cTagOlaRec.extraData.sFuelAmt, sizeof(cTagOlaRec.extraData.sFuelAmt));

					 cTagOlaRec.cardData.sTranStatus = CD_APPROVE_OK; 

					 if (a2l(pRec[i].sTransactionStatus , sizeof(pRec[i].sTransactionStatus)))
					 {
						cTagOlaRec.cardData.sTranStatus =  CD_DECLINE_DECLINED;
					 }

					 byIndex++;

					tmpPos.m_cPOSTrsList.InsertAt(i, cTagOlaRec);
					bFound = TRUE;		
				}
			}
			m_cPosMap.SetAt(lPosNumber,tmpPos);
			delete[] pRec;
			slPosMap1.Unlock();
		}


		if (bFound)
		{
			//Get handle Pos receipt 
			CSingleLock slPosMap( &(m_csPosMap));	
			slPosMap.Lock(INFINITE);
			CPosInfo tmpPos;
			
			if(m_cPosMap.Lookup(lPosNumber,tmpPos))
			{
				tmpPos.SendEventReceipt();
				m_cPosMap.SetAt(lPosNumber,tmpPos);

			}
			slPosMap.Unlock();				
		}
	}
}


/******************************************************************************
 Description:	Update POS with new receipt information
 Returns:      	none
 Parameters:   	SendFormatReceiptData(long lPosNumber, CComBSTR & sReceipt)
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			29/10/2007   11:34		Start
******************************************************************************/
void CServerMain::SendFormatReceiptData(long lPosNumber, CComBSTR & sReceipt)
{
	if (sReceipt.Length())
	{
		//Get handle Pos receipt 
		CSingleLock slPosMap( &(m_csPosMap));	
		slPosMap.Lock(INFINITE);
		CPosInfo tmpPos;
		
		if(m_cPosMap.Lookup(lPosNumber,tmpPos))
		{
			tmpPos.SetReceiptText(sReceipt);
			tmpPos.SendEventReceipt();
			m_cPosMap.SetAt(lPosNumber,tmpPos);

		}
		slPosMap.Unlock();				
	}
					
}

//4.0.19.504 - 47559
/******************************************************************************
 Description:	Calculate transaction limit coming from TerminalSrv 
				according to site limitations and report it
 Returns:      	None
 Parameters:   	long lPumpNumber
				long * lLimitType  [in,out]
				long * lLimitValue [in,out]

 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella			24/12/2007   12:00		Start
******************************************************************************/
void CServerMain::CalculateTrsLimit(long lPumpNumber, long * lLimitType, long * lLimitValue)
{
	long lMaxValue = 0;
	long lFlags = 0;
	long lPresetValue = * lLimitValue;
	long lPresetType = * lLimitType;
	
	try
	{
		if (GetIFSFTerminalSrvInUse())
		{
			if ((lLimitValue != NULL) )
			{
				BOOL bPreSetLimitation =  FALSE;
				long lTrmSrvPresetType = 0;
				long lTrmSrvPresetValue = 0;

				if (LimitedPreSet())
					bPreSetLimitation = TRUE;
		

				try
				{
					if	((m_pIFSFTerminalSrvCtrl != NULL) && (lPumpNumber > 0))   
						m_pIFSFTerminalSrvCtrl->GetPreSetLimit(lPumpNumber, &lTrmSrvPresetType, &lTrmSrvPresetValue);
				}
				catch (_com_error& e)
				{
					CString		strLog;
					strLog.Format("CalculateTrsLimit IFSFTerminalSrv COM Exception:[%s].", e.ErrorMessage()); 
					m_cLogger.LogMsg(strLog, LOG_LEVEL_0);
					lTrmSrvPresetType = 0;	lTrmSrvPresetValue = 0;
				}
				catch (...)
				{
					CString		strLog;
					DWORD dwLastError =GetLastError();
					strLog.Format("CalculateTrsLimit IFSFTerminalSrv  LastError:[%d].", dwLastError); 
					m_cLogger.LogMsg(strLog, LOG_LEVEL_0);
					lTrmSrvPresetType = 0;	lTrmSrvPresetValue = 0;
				}



				if (lTrmSrvPresetValue > 0)
				{
					lPresetValue = lTrmSrvPresetValue;
					lPresetType = lTrmSrvPresetType;
				}

				if (lPresetType & LIMIT_BY_VALUE)
				{
					lFlags = LIMIT_BY_VALUE;
					if (bPreSetLimitation)
					{
						lMaxValue = GetLimit(PRICE_LEVEL_CASH,lPumpNumber);
						
						if (lMaxValue > lPresetValue)
							lMaxValue = lPresetValue;																							
					}
					else
					{
						lMaxValue = lPresetValue;
					}

				}
				else if (lPresetType & LIMIT_BY_VOLUME)
				{
					lFlags = LIMIT_BY_VOLUME;
					if (bPreSetLimitation)
					{
						lMaxValue = GetStationLimitVolume();											
						if (lMaxValue > lPresetValue)
							lMaxValue = lPresetValue;																							
					}
					else
						lMaxValue = lPresetValue;
				}
				else //case LIMIT_FILL_UP:					
				{
					if ( IsSiteLimitByVolume() )
					{
						lMaxValue =  GetStationLimitVolume();
						lFlags = LIMIT_BY_VOLUME; //4.0.20.504
					}
					else
					{
						lMaxValue = GetLimit(PRICE_LEVEL_CASH,lPumpNumber);
						lFlags = LIMIT_BY_VALUE; //4.0.20.504
					}
				}
				
				//4.0.140.100
				if (lLimitType)
					*lLimitType = lFlags;

				if (lLimitValue)
					*lLimitValue = lMaxValue;
			}
		}
	}
	catch (_com_error& e)
	{
		m_cLogger.LogClassMsg("ServerMain","CalculateTrsLimit",lPumpNumber,LOG_PUMP,e.ErrorMessage(),LOG_LEVEL_0);
		return;
	}
	catch(...)
	{
		if (LOG_LOGIC_ERROR )
		{
			CString sMsg;
			sMsg.Format("Failed to CalculateTrsLimit");
			_LOGMSG.LogMsg(sMsg,LOG_LOGIC_ERROR);			
		}
		return;
	}
}

//4.0.19.508
/******************************************************************************
 Description: Retun flags status of ssaving zero Debit transaction to receipt qdx.
 Return:  Flags status ON/Off
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Marik			04/07/2006				Start
******************************************************************************/

long CServerMain::GetDebitZeroCompleteDataFlags()
{
	return (m_dwSaveDebitZeroCompleteData);
}

			  long CServerMain::GetSaveZeroPakTrs()
			  {
				  return (m_dwSaveZeroPakTrs);
			  }


/******************************************************************************
 Description:	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 Gena			16/06/2008   11:54		Merge		//4.0.20.52 (62818)
******************************************************************************/
void CServerMain::SetStartDeliveryTime()
{	
	SYSTEMTIME curSysTime;
	SZ_TAG_SYSTEMTIME szTagTime;

	GetLocalTime(&curSysTime);		
	szTagTime.sNull = 0;
	SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	
	m_cParam.SaveParam("GeneralParam", "StartDeliveryTime", (char *)&szTagTime, TRUE, 0, 0, 0, TRUE);	
}


/******************************************************************************
 Description:	
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 Gena			16/06/2008   11:54		Merge		//4.0.20.52 (62818)
******************************************************************************/
void CServerMain::SetEndDeliveryTime()
{
	SYSTEMTIME curSysTime;
	SZ_TAG_SYSTEMTIME szTagTime;

	GetLocalTime(&curSysTime);		
	szTagTime.sNull = 0;
	SystemTime2Tag(&curSysTime,&szTagTime.sTime);
	
	m_cParam.SaveParam("GeneralParam", "EndDeliveryTime", (char *)&szTagTime, TRUE, 0, 0, 0, TRUE);	
}

/******************************************************************************
 Description:	reset the Accumulated Delivery Emulation Sales to zero for all tanks
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 AmitH			04/06/2008   11:54		Start		//4.0.19.160
 Gena			16/06/2008   11:54		Merge		//4.0.20.52 (62818)
******************************************************************************/
void CServerMain::ReSetAccumulatedDeliveryEmulationSales()
{
	if(GetSupportDeliveryEmulation() == TRUE)
	{
		for(long tn = 0; tn < MAX_TANKS; tn++)
		{
			//save zero to memory 
			m_cTankArray[tn].ReSetAccumulatedDeliveryEmulationSales();
		
			//save to ini 
			m_cTankArray[tn].SaveAccumulatedDeliveryEmulationSales();
			
		}
	}	
}

/******************************************************************************
 Description:	If running kill both DataExprtSrv and its agent. 	
 Returns:      	void
 Parameters:   	None

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			05/8/2008   9:00		Start
******************************************************************************/
void CServerMain::KillDataExportSrvAndAgent() //4.0.21.0
{
	long lCounter = 0;
	long lRtc1 = NOT_RUNNING;
	long lRtc2 = NOT_RUNNING;

	lRtc1= m_cCompChecker.IsRunning("DESSrv"); 

	if(lRtc1 == RUNNING)	 
	{
		m_cLogger.LogMsg("DataExportSrv.exe is running !",LOG_LEVEL_1);
		lCounter++;
	}

	lRtc2 = m_cCompChecker.IsRunning("DESAgent");   

	if(lRtc2 == RUNNING)	 
	{
		m_cLogger.LogMsg("DataExportAgent.exe is running !",LOG_LEVEL_1);
		lCounter++;
	}

	for (int i = 0; i < lCounter;i++)
	{
		m_cCompChecker.KillProcess("DataEx");

		CString msg;
		msg.Format("DataEx~%ld.exe is running ! - kill it !",i+1);
		m_cLogger.LogMsg(msg,LOG_LEVEL_1);

		Sleep(100);
	}	
}


/******************************************************************************
 Description:	For each tank, fill in the tank connected pumps bit mask
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 AmitH			04/10/2008   11:54		Start		4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::LoadTanksConnectedPumps()
{
	int numValidPumps = GetLastValidPump();
	for (int p = 0; p < numValidPumps; p++) //loop on all valid pumps
	{
		for (int n = 0; n < MAX_POSITIONS_PER_PUMP ; n++ ) //loop on all the optional positions (nuzzles) of pump
		{
			DWORD dwValidPosition = 0;
			m_cParam.GetParam("Position",p+1,n+1,"ValidEntry",FIELD_DWORD,NULL,0,&dwValidPosition,FALSE);
			if (dwValidPosition) //This position is valid in this pump
			{
				long lTank = 0;
				lTank = m_cPumpArray[p].GetTankPerPosition(n+1);//Return the tank that this nuzzle belongs to
				
				//Mark that this pump is connected to this tank:
				if(p < MAX_PUMPS) // 0<p<32
				{
					if (lTank)
						m_cTankArray[lTank-1].SetPumpsLinkedMap1(p+1);
				}

				else // < MAX_PUMPS_64 => 32<p<64
				{
					if (lTank)
						m_cTankArray[lTank-1].SetPumpsLinkedMap2(p+1);
				}
			}
		}			
	}
}

/******************************************************************************
 Description:	According to a given tank number, lock only the 
				pumps which are connected to it.
 Returns:      	
 Parameters:   	lTankNumber
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 AmitH			06/10/2008   11:54		Start		4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::LockTankConnectedPumps(const long lTankNumber)
{

	long lTankConnectedPumpsMap1 = 0;
	long lTankConnectedPumpsMap2 = 0;
	
	lTankConnectedPumpsMap1 = m_cTankArray[lTankNumber-1].GetPumpsLinkedMap1();
	lTankConnectedPumpsMap2 = m_cTankArray[lTankNumber-1].GetPumpsLinkedMap2();

	for (int p = 0; p < m_lLastValidPump; p++)
	{
		if (p < MAX_PUMPS)
		{
			if (lTankConnectedPumpsMap1 & (1<<p)) //The P bit in lTankConnectedPumpsMap1 is on
				DoAutomaticPumpLock(p+1,MAINTENANCE);
		}
		else //MAX_PUMPS_64
		{
			if (lTankConnectedPumpsMap2 & (1<<p)) //The P bit in lTankConnectedPumpsMap2 is on
				DoAutomaticPumpLock(p+1,MAINTENANCE);
		}		
	}
}

/******************************************************************************
 Description:	According to tank number, lock only the 
				pumps which are connected to it.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 AmitH			06/10/2008   11:54		Start		4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::DoAutomaticTankLock__() //TD 66935
{
	try
	{
		DoAutomaticTankLock();
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticTankLock()", LOG_LEVEL_0);

		exit(1);
	}
}

/******************************************************************************
 Description:	According to  tank number, lock only the 
				pumps which are connected to it.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 AmitH			06/10/2008   11:54		Start		4.0.21.500 TD 66935
******************************************************************************/
void CServerMain::DoAutomaticTankLock()
{
	SingleTankLockStatus lSingleTankLockStatus ;
	for(long lTankIndex = 0; lTankIndex < m_lLastValidTank; lTankIndex++)
	{
		if (m_cServerInfo.GetDeliveryEmulationSingleTankStatus(lTankIndex+1) != DES_SINGLE_TANK_IDLE)
		{
			lSingleTankLockStatus = m_cServerInfo.GetSingleTankLockStatus(lTankIndex+1);
			
			switch(lSingleTankLockStatus)
			{				
				case SINGLE_TANK_LOCK_STARTED:
				case SINGLE_TANK_WAIT_LOCK:
				//-----------------------------------------------------------------------------------
				{
					BOOL bAllConnectedPumpsLocked = TRUE;

					if( FALSE == (m_cServerInfo.GetServerReservation() & MAINTENANCE))	//4.0.19.450 TD 69684						
						bAllConnectedPumpsLocked = SetPumpsLockState(lTankIndex,TRUE);
							
					if(bAllConnectedPumpsLocked)
					{
						m_cServerInfo.SetSingleTankLockStatus(lTankIndex+1,SINGLE_TANK_LOCKED);
						
						/****************/
						//Tank Is locked !
						/****************/
						
						CString str;
						str.Format("DoAutomaticTankLock - All pumps of Tank Number = %ld are locked.",lTankIndex+1);
						m_cLogger.LogMsg(str);
					}
				}
				break;

				//-----------------------------------------------------------------------------------
				case SINGLE_TANK_UNLOCK_STARTED:
				case SINGLE_TANK_WAIT_UNLOCK:
				{
					BOOL bAllConnectedPumpsUnLocked = TRUE;

					if( FALSE == (m_cServerInfo.GetServerReservation() & MAINTENANCE) )	//4.0.19.450 TD 69684
						bAllConnectedPumpsUnLocked = SetPumpsLockState(lTankIndex,FALSE);
					else
						ClearPumpsConnectedToTankStatus(lTankIndex); // 4.0.19.2100   TD 396017
						
					if(bAllConnectedPumpsUnLocked)
					{						
						m_cServerInfo.SetSingleTankLockStatus(lTankIndex+1,SINGLE_TANK_UNLOCKED);
						
						/******************/
						//Tank Is Unlocked !
						/******************/
						
						CString str;
						str.Format("DoAutomaticTankLock - All pumps of Tank Number = %ld are Unlocked.",lTankIndex+1);
						m_cLogger.LogMsg(str);	
					}
				}
				break;

				//-----------------------------------------------------------------------------------	
				case SINGLE_TANK_WAIT_RESPONSE:
				case SINGLE_TANK_LOCKED:
				case SINGLE_TANK_UNLOCKED:
				{
					//do nothing					
				}
				break;
				//-----------------------------------------------------------------------------------
				default:
				{
					//do nothing
				}
				break;					
			}
		}
		
	}
	
}

/******************************************************************************
 Description:	The main state machine methtod for the Lock/UnLock pump process
				by mode tank.
 Returns:      	TRUE when pump is locked
 Parameters:   	None.

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amit H			12/10/2008   15:50		Start
******************************************************************************/
BOOL CServerMain::DoAutomaticLockPumpByTank(const long lPumpNumber)
{
	BOOL lPumpIsLocked = FALSE;
	long p = lPumpNumber - 1;
	PumpLockType eLockType = LOCK_TYPE_MAINT;

	long lPumpLockStatus = PTL_UNLOCK;
	
	//if reserved by pumpsrv ignore process until will be released
	if( !(m_cServerInfo.GetServerReservation() & EMERGENCY_LOCK) )		//4.0.21.500
	{		
		lPumpLockStatus = m_cPumpsLockbyTankStateArray[p].GetPumpLockStatus();

		switch(lPumpLockStatus)
		{
			case PTL_START_LOCK:
			{
				//Pump is already reserved by PumpSrv or in maintanace lock process
				if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) )
				{
					lPumpIsLocked = TRUE;
					
					SetLockPumpByTankStatus(p+1, PTL_LOCKED);

					CString str;
					str.Format("DoAutomaticLockPumpByTank - pumps is already locked by another process.");
					m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,str);
					
				}
				else //start the single pump lock process
				{
					if(m_cPumpArray[p].CanReserveForPumpLock(eLockType))  // check if can send reserve pump 
					{
						CMD_STRUCT_RESERVE_PUMP cmdInfo;
						cmdInfo.lRes	= PUMPSRV;
						cmdInfo.lResExt = MAINTENANCE; 
												
						SetCommand(CMD_RESERVE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
						SetLockPumpByTankStatus(p+1, PTL_WAIT_LOCK);				
					}
					else if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
							(m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
							(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
							(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) ||
							(m_cPumpArray[p].GetStat().GetStatus() == UNKNOWN_STATUS))	 //4.0.24.70 - TD 113017
					{
						SetLockPumpByTankStatus(p+1, PTL_WAIT_LOCK);					
					}
				}
				break;
			}
			case PTL_WAIT_LOCK:
			{
				if( (m_cPumpArray[p].GetStat().GetRes() == PUMPSRV) ||
					(m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
					(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
					(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) ||
					(m_cPumpArray[p].GetStat().GetStatus() == UNKNOWN_STATUS))	//4.0.24.70 - TD 113017
				{
					SetLockPumpByTankStatus(p+1, PTL_LOCKED);					
				}
				break;
			}

			case PTL_START_UNLOCK:
			{
				//We would start unlocking the pump by tank only if it's
				//not exclusively locked
                if(!m_cSinglePumpLock.IsExclusivelyLocked(p+1)) //pump is locked by something else
				{				
					CMD_STRUCT_RELEASE_PUMP cmdInfo;
					cmdInfo.lRes	= PUMPSRV;				
					cmdInfo.lResExt = MAINTENANCE;
									
					SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RELEASE_PUMP));	
					lPumpIsLocked = TRUE; //pump is still Considered locked in this stage.
					SetLockPumpByTankStatus(p+1, PTL_WAIT_UNLOCK);					
				}
				else
				{
					lPumpIsLocked = TRUE; //we cant unlock the pump right now becasue it is Exclusively Locked...
				}
				break;
			}

			case PTL_WAIT_UNLOCK:
			{
				lPumpIsLocked = TRUE; //pump is still Considered locked !

				if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
				{
					if (m_cPumpsLockbyTankStateArray[p].GetPumpLockStatus() != PTL_UNLOCK)
					{
						SetLockPumpByTankStatus(p+1, PTL_UNLOCK); 
					}
				}				
				break;
			}
			
			case PTL_UNLOCK:
				{
					m_cPumpArray[p].SetLockStatus(UNLOCK);	//4.0.21.500
					lPumpIsLocked = FALSE;
				}
				break;
				
			case PTL_LOCKED:
				{
				
					//If the pump is supposed to be locked by tank according to the state machine
					//and isn't locked it's a mistake caused somehow and we should lock it
					if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
					{
						if(m_cPumpArray[p].CanReserveForPumpLock(eLockType))  // Check if we can send a reserve pump command 
						{
							CMD_STRUCT_RESERVE_PUMP cmdInfo;
							cmdInfo.lRes	= PUMPSRV;
							cmdInfo.lResExt = MAINTENANCE; 
													
							SetCommand(CMD_RESERVE_PUMP, SERVER_POS_NUMBER, p+1,&cmdInfo,sizeof(CMD_STRUCT_RESERVE_PUMP));						
						   _LOGMSG.LogMsg(p+1,LOG_PUMP,"DoAutomaticLockPumpByTank, Pump should be locked by Tank and isn't locked. Locking it again.");
						}
						//**************************************************
						//Treat non active Pumps: consider them as locked !  4.0.24.70 - TD 113017
						//**************************************************
						if( (m_cPumpArray[p].GetStat().GetStatus() == OUT_OF_SERVICE) ||
							(m_cPumpArray[p].GetStat().GetStatus() == ERROR_TERMINATED) ||
							(m_cPumpArray[p].GetStat().GetStatus() == COMMS_TERMINATED) ||
							(m_cPumpArray[p].GetStat().GetStatus() == UNKNOWN_STATUS))
						{
							lPumpIsLocked = TRUE; 
						}
					}
					else
					{
						//**************************
						//Pump is locked !
						//**************************
						
						lPumpIsLocked = TRUE;
						
						if (m_cPumpArray[lPumpNumber-1].GetLockStatus() != LOCKED)
							m_cPumpArray[lPumpNumber-1].SetLockStatus(LOCKED);
						
					}
				}
				break;

			default:
				break;
				//do nothing
		}
	}
	
	return lPumpIsLocked;
}

/******************************************************************************
 Description:	Sets the Lock state machine for a specific pump per tank	
 Returns:      	void
 Parameters:   	long - lPumpNumber
				enum - LockPumpByTankStatus
		
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 AmitH			15/10/2008   15:55		Start
******************************************************************************/
void CServerMain::SetLockPumpByTankStatus(const long lPumpNum,const LockPumpByTankStatus eLockPumpByTankStatus)
{
	m_cPumpsLockbyTankStateArray[lPumpNum-1].SetPumpLockStatus(eLockPumpByTankStatus);
	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString tmpStr;
		CString cState;
		switch(eLockPumpByTankStatus)
		{
			case PTL_UNLOCK:
			{
				cState = "PTL_UNLOCK";
				break;
			}
			case PTL_START_LOCK:
			{
				cState = "PTL_START_LOCK";
				break;
			}
			case PTL_WAIT_LOCK:
			{
				cState = "PTL_WAIT_LOCK";
				break;
			}
			case PTL_LOCKED:
			{
				cState = "PTL_LOCKED";
				break;
			}
			case PTL_START_UNLOCK:
			{
				cState = "PTL_START_UNLOCK";
				break;
			}
			case PTL_WAIT_UNLOCK:
			{
				cState = "PTL_WAIT_UNLOCK";
				break;
			}
		}
		tmpStr.Format("SetLockPumpByTankStatus ,New Status:");
		tmpStr += cState;
		_LOGMSG.LogMsg(lPumpNum,LOG_PUMP,tmpStr);
	}
}

/******************************************************************************
 Description:	Checks if the pump was locked by the single Tank locked process 	
 Returns:      	BOOL - TRUE: pump was locked due to the process
					   FALSE: not locked by the process
 Parameters:   	long - lPumpNumber

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 AmitH			15/10/2008   15:53		Start
******************************************************************************/
BOOL CServerMain::IsPumpLockedByTank(const long lPumpNumber)
{
	BOOL bLockedByTank = FALSE;

	//first check if the process is active
	if( m_cPumpsLockbyTankStateArray[lPumpNumber-1].IsLockedByTank() )
			bLockedByTank = TRUE;
	return bLockedByTank;
}


/******************************************************************************
 Description:Insert the receipt XML data into Receipt QDX
 Parameters: BSTR & bstrInXML - receipt xml buffer
			 CPumpTransact & trs - transaction
				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella			25/01/2009				Start		//4.0.22.500 - TD 70353
******************************************************************************/
long CServerMain::InsertXMLReceiptIntoReceiptQDX(long lFlags,BSTR & bstrInXML,CPumpTransact & trs, long lPumpNumber)
{	
	BOOL				bRet = TRUE;
	long				lRtc = OK;
	long				lBuffSize = 0;
	char				sXmlBuff[MAX_XML_BUF_LEN];
	TAG_OLA_REC13		cTagOlaRec;
	PAY_AT_PUMP_INFO	cPAPInfo;
	char				sTrsNum[7] = {0};

	memset(&sXmlBuff, 0, sizeof(sXmlBuff)); //4.0.26.0 - TD 69677
	memset(&cTagOlaRec, ' ', sizeof(cTagOlaRec));

	lBuffSize = Bstr2Buffer(bstrInXML, (void *)&sXmlBuff, sizeof(sXmlBuff)); //4.0.26.0 - TD 69677
	if (lBuffSize > 0)
	{
		RECEIPT_INFO cReceiptInfo;
		RECEIPT_REC_EX_DATA cExData;
		memset(&cExData,0,sizeof(cExData));
// unreferenced
//		char  sDateTimeExt[sizeof(cPAPInfo.CardSaleInfo.extraData.sDateTimeExt) + 1];  // 4.0.24.343

		if(LOG_DETAIL_FLOW_CONTROL)
			m_cLogger.LogOLABufferMsg(lPumpNumber,LOG_PUMP, "CServerMain::InsertXMLReceiptIntoReceiptQDX. XML",sXmlBuff);

		m_cXmlConvertorEx.ConvertFromXmlToStruct((char *)sXmlBuff, &cTagOlaRec);
		cPAPInfo.CardSaleInfo.cardData  = cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.cardData;
		cPAPInfo.CardSaleInfo.extraData = cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData;
		cPAPInfo.CardSaleExtraData2     = cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData2;
		cPAPInfo.CardSaleExtraData3     = cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData3;
		cPAPInfo.CardSaleExtraData4     = cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData4; //4.0.22.511
		cPAPInfo.CardSaleExtraData5     = cTagOlaRec.tagOlaRec12.extraData5; //4.0.27.47
		cPAPInfo.CardSaleExtraData6		= cTagOlaRec.extraData6; //4.0.27.47

		//4.0.27.32 TD 223052 (merge from 1024)
		//4.0.24.340 TD 223052

		//
		memcpy(cPAPInfo.CardSaleInfo.cardData.sDateTime, (unsigned char *)&cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.tagTrs.sDateTime + 2, sizeof cPAPInfo.CardSaleInfo.cardData.sDateTime);
		memcpy(cPAPInfo.CardSaleInfo.extraData.sDateTimeExt, (unsigned char *)&cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.tagTrs.sDateTime + 12, sizeof cPAPInfo.CardSaleInfo.extraData.sDateTimeExt);

		
		//4.0.22.511 - TD 74796
		//In case sTranType or sLoyaltyActive are not empty insert those fields into extra info qdex
		if ((cPAPInfo.CardSaleInfo.extraData.sLoyaltyActive != ' ') || (cPAPInfo.CardSaleInfo.cardData.sTranType != ' ') || lFlags & MULTIPLE_VOLUME_AND_AMOUNT_LIMIT)
		{
			trs.SetLink(trs.GetLinkFlags() + TRS_LINK_EXTRA_INFO, trs.m_lNumber);
		
			//Create record in Extra Info qdex										
			EXTRA_INFO		cExtraInfo;
			memset(&cExtraInfo, 0, sizeof(EXTRA_INFO));					//4.0.24.71 No TD //4.0.26.0 - TD 69677

			cExtraInfo.lIndexNumber = trs.m_lNumber;
			cExtraInfo.sLoyaltyApplicable = cPAPInfo.CardSaleInfo.extraData.sLoyaltyActive;
			cExtraInfo.sTranType = cPAPInfo.CardSaleInfo.cardData.sTranType;
			memcpy(cExtraInfo.sPMTReferenceNumber, cPAPInfo.CardSaleExtraData3.sPMTReferenceNumber, sizeof(cPAPInfo.CardSaleExtraData3.sPMTReferenceNumber));	//4.0.25.50 - TD 136918
			memcpy(&cExtraInfo.sLoyalId, &cPAPInfo.CardSaleInfo.extraData.sLoyalId, sizeof(cPAPInfo.CardSaleInfo.extraData.sLoyalId));							//4.0.26.506 - TD 177984
			cExtraInfo.lControllerSeqNum = trs.m_lNumber; //4.0.24.480 278543

			if(lFlags & MULTIPLE_VOLUME_AND_AMOUNT_LIMIT)
				SetGradeLimitsAndDiscounts(lPumpNumber, cPAPInfo, cExtraInfo); // CR 370688
						
			long lRtc = IndexOperation(EXTRA_INFO_FILE,REC_INSERT,&cExtraInfo);
				
			if(LOG_DETAIL_FLOW_CONTROL)
			{
				CString sLogMsg; 
				sLogMsg.Format("Insert extra info PrePay record (Trs %d, Status %d, link Number %d, RetCode=%ld)", 									
					trs.m_lNumber,
					trs.m_lStatus,
					trs.m_lLinkNumber , 
					lRtc);
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,sLogMsg); 
			}
		}

		if (!GetOLAFlags(cPAPInfo.CardSaleExtraData2.sFlags ,FL_PAP_AS_THIRD_REC))
		{			
			long lTmp = a2l(cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags)) + FL_PAP_AS_THIRD_REC;
			l2a(lTmp ,cPAPInfo.CardSaleExtraData2.sFlags ,sizeof(cPAPInfo.CardSaleExtraData2.sFlags));
		}

		sprintf_s(sTrsNum, _countof(sTrsNum), "%ld", trs.m_lNumber);
		memset(cPAPInfo.CardSaleInfo.cardData.sTrack2Data, ' ', sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data));
		memcpy(cPAPInfo.CardSaleInfo.cardData.sTrack2Data, sTrsNum, strlen(sTrsNum));

		//4.0.22.509 - TD 76096
		if(m_cProtectedDataHandler.GetPCIActiveFlag() == PCI_FLAG_ON)
		{
			memset(cPAPInfo.CardSaleInfo.cardData.sAccountNumber, ' ', sizeof(cPAPInfo.CardSaleInfo.cardData.sAccountNumber));
			memcpy(cPAPInfo.CardSaleInfo.cardData.sAccountNumber, sTrsNum, min(strlen(sTrsNum), sizeof(cPAPInfo.CardSaleInfo.cardData.sAccountNumber)));
		}
		
		//Insert Items to item qdex
		lRtc = InsertItemsToItemQdx(&cPAPInfo, &cTagOlaRec, lPumpNumber);
		if (lRtc && LOG_BASIC_FLOW_CONTROL)
		{
			CString strTmp;
			strTmp.Format("CServerMain::InsertXMLReceiptIntoReceiptQDX. Items were not inserted to Items Qdex, Rtc=%ld", lRtc );
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
		}

		//Insert zones to receiptE qdex
		lRtc = InsertZonesToReceiptEQdx(&cPAPInfo, &cTagOlaRec, lPumpNumber, trs.m_lNumber);
		if (lRtc && LOG_BASIC_FLOW_CONTROL)
		{
			CString strTmp;
			strTmp.Format("CServerMain::InsertXMLReceiptIntoReceiptQDX. Zones were not inserted to ReceiptE Qdex, Rtc=%ld", lRtc );
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
		}
		
		m_cBaseReceipt->ConvertOlaToReceipt(&trs, &cPAPInfo, &cReceiptInfo,0,0,TRS_NUMBER_IN_RECEIPT_INDEX); // RFUEL-1917

		CReceiptInfo ReceiptInfo;
		_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(&trs, &cPAPInfo, ReceiptInfo);//4.0.9.503
		long lRtc2 = CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

		if (lRtc && LOG_BASIC_FLOW_CONTROL)
		{
			CString strTmp;
			strTmp.Format("CServerMain::InsertXMLReceiptIntoReceiptQDX. Fail to Insert to Receipt Qdex, Rtc=%ld", lRtc );
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
			bRet = FALSE;
		}
	}
	else 
		bRet = FALSE;													

	if(LOG_BASIC_FLOW_CONTROL)						//4.0.24.71 No TD
	{
		CString str;
		str.Format("CServerMain::InsertXMLReceiptIntoReceiptQDX: trs number = %ld, lRetCode=%ld, lBuffSize=%ld", trs.m_lNumber, bRet, lBuffSize);
		_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, str);							
	}

	return bRet;
}

/******************************************************************************
 Description: Insert items into item qdex
 Parameters:  PAY_AT_PUMP_INFO *pcPAPInfo, TAG_OLA_REC12 *pcTagOlaRec, long lPumpNumber
 				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		15/02/2009	12:00			Start		//4.0.22.501 - TD 70353
******************************************************************************/
long CServerMain::InsertItemsToItemQdx(PAY_AT_PUMP_INFO *pcPAPInfo, TAG_OLA_REC13 *pcTagOlaRec, long lPumpNumber)
{
	CItemsFile				cItemsFile;
	BAP_ALL_DATA_STRUCTS	cItemRec; 
	ITEMS_INFO				cItemInfo;
	long					lItemIndex;
	long					lRtc = 0;

	memset(&cItemRec , ' ' , sizeof(cItemRec));
	memset(&cItemInfo , ' ' , sizeof(cItemInfo));

	long lItemsNumber = a2l(pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.Items.sItemsNumber, sizeof(pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.Items.sItemsNumber));

	if (lItemsNumber > 0)
	{
		lItemIndex = NewItemsIndex();
		l2a(lItemIndex ,pcPAPInfo->CardSaleExtraData2.sItemsLinkIndex, sizeof(pcPAPInfo->CardSaleExtraData2.sItemsLinkIndex));					

		cItemRec.cBAPReceiptItem = pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.Items;
		cItemRec.cBAPReceiptItem2 = pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.Items2;

		if (!GetOLAFlags(pcPAPInfo->CardSaleExtraData2.sFlags ,FL_EXTRA_ITEM_REC))
		{
			long lTmp = a2l(pcPAPInfo->CardSaleExtraData2.sFlags ,sizeof(pcPAPInfo->CardSaleExtraData2.sFlags)) + FL_EXTRA_ITEM_REC;
			l2a(lTmp ,pcPAPInfo->CardSaleExtraData2.sFlags ,sizeof(pcPAPInfo->CardSaleExtraData2.sFlags)); 
		}
		
		cItemsFile.SplitBAPRecorToItems(lItemIndex,cItemRec,cItemInfo);
		lRtc = IndexOperation(ITEMS_FILE,REC_INSERT,&cItemInfo);
		
		if(LOG_BASIC_FLOW_CONTROL)
		{
			CString strMsg;
			if (lRtc)
				strMsg.Format("InsertItemsToItemQdx. Insert Index=%ld to Items file FAILED!!!" , cItemInfo.ItemRec.lIndexNumber);
			else
				strMsg.Format("InsertItemsToItemQdx. Insert Index=%ld to Items file succeeded" , cItemInfo.ItemRec.lIndexNumber);

			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strMsg);
		}
	}

	if (lRtc && LOG_BASIC_FLOW_CONTROL)
	{
		CString strTmp;
		strTmp.Format("InsertItemsToItemQdx. Items were not inserted to Items Qdex, Rtc=%ld", lRtc );
		_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,strTmp);
	}

	return lRtc;
}

/******************************************************************************
 Description: Insert items into item qdex
 Parameters:  PAY_AT_PUMP_INFO *pcPAPInfo, TAG_OLA_REC10 *pcTagOlaRec, long lPumpNumber
 				
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		08/09/2009	15:00			Start		//4.0.23.501 - TD 75947
******************************************************************************/
long CServerMain::InsertZonesToReceiptEQdx(PAY_AT_PUMP_INFO *pcPAPInfo, TAG_OLA_REC13 *pcTagOlaRec, long lPumpNumber, long lTrsNumber)
{
	long lRtc = 0;
	
	if (!ChrAll((char *)pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.ReceiptExtraInfo.sFiler2043, sizeof(pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.ReceiptExtraInfo.sFiler2043)))
	{
		PS::RECEIPT_EXTRA_INFO_REC	cReceiptExtraRec;
		memset(&cReceiptExtraRec, ' ', sizeof(PS::RECEIPT_EXTRA_INFO_REC));
		cReceiptExtraRec.info.lIndexNumber = lTrsNumber;

		if (!GetOLAFlags(pcPAPInfo->CardSaleExtraData2.sFlags, FL_EXTRA_RECEIPT_REC))
		{
			long lTmp = a2l(pcPAPInfo->CardSaleExtraData2.sFlags, sizeof(pcPAPInfo->CardSaleExtraData2.sFlags)) + FL_EXTRA_RECEIPT_REC;
			l2a(lTmp, pcPAPInfo->CardSaleExtraData2.sFlags, sizeof(pcPAPInfo->CardSaleExtraData2.sFlags));
		}

		memcpy(cReceiptExtraRec.info.sFiler2043, pcTagOlaRec->tagOlaRec12.tagOlaRec11.tagOlaRec10.ReceiptExtraInfo.sFiler2043, sizeof(cReceiptExtraRec.info.sFiler2043));
		lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_INSERT, cReceiptExtraRec);
		//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_INSERT,&cReceiptExtraRec);

		//If the record already exist in receipt extra data qdx - update it. //TD 223042 - 4.0.27.31
		if (lRtc == ERR_EXISTS)
		{
			lRtc = CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_UPDATE, cReceiptExtraRec);
			//lRtc = IndexOperation(RECEIPT_EXTRA_DATA_FILE,REC_UPDATE,&cReceiptExtraRec);
			if (LOG_DETAIL_FLOW_CONTROL)
			{
				CString str;
				str.Format("Update extra receipt information Index=%ld , Rtc=%ld , trs number = %ld ", cReceiptExtraRec.info.lIndexNumber, lRtc, lTrsNumber);
				_LOGMSG.LogMsg("GCI", "PAPReadyTransaction", lPumpNumber, LOG_PUMP, str);	//4.0.20.40
			}
		}
	}

	if (lRtc && LOG_BASIC_FLOW_CONTROL)
	{
		CString strTmp;
		strTmp.Format("InsertZonesToReceiptEQdx. Zones were not inserted to ReceiptE Qdex, Rtc=%ld", lRtc );
		_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, strTmp);
	}

	return lRtc;
}

/******************************************************************************
 Description:	Automatic procedure done for the asynchronous report request process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		03/02/2009   11:00			Start		4.0.22.501 TD 69905
******************************************************************************/
void CServerMain::DoAutomaticRequestReport__()
{
	try
	{
		DoAutomaticRequestReport();
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticRequestReport__()", LOG_LEVEL_0);
		exit(1);
	}
}

/******************************************************************************
 Description:	Automatic procedure done for the asynchronous report request process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		03/02/2009   11:00			Start		4.0.22.501 TD 69905
******************************************************************************/
void CServerMain::DoAutomaticRequestReport()
{
	m_cServerInfo.HandleGenerateReportProcess();
}

/******************************************************************************
 Description:	Init generate report process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		05/02/2009   15:00			Start		4.0.22.501 TD 69905
            24/03/2013                                         TD 351225
******************************************************************************/
void CServerMain::GetWetStockReportAsync()
{
	CString						strLog;
	ReportRequestState			eState = m_cServerInfo.GetReportRequestState();
	strLog.Format("CServerMain::GetWetStockReportAsync: Received in process state[%s]", ReportRequestState_str[eState]);
	m_cLogger.LogMsg(strLog);
	
	if (REPORT_READY == eState || REPORT_PROCESS_IDLE == eState) //4.0.22.512 - TD 75378 //TD 351225: Wet stock report doesn't print
	{
		if (REPORT_READY == eState)
		{
			m_cServerInfo.SetReportRequestState(REPORT_PROCESS_IDLE, "GetWetStockReportAsync");
		}
		m_cServerInfo.HandleGenerateReportProcess(TRUE);
	}
	else
	{
		//TD 351225: Wet stock report doesn't print, log the reason...
		strLog.Format("CServerMain::GetWetStockReportAsync - Received in unexpected process state[%s], ignoring", ReportRequestState_str[eState]);
		m_cLogger.LogMsg(strLog);
	}
}

/******************************************************************************
 Description:	Automatic procedure for changing product in tank
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		25/02/2009   13:40			Start		4.0.22.503 - TD 72189
******************************************************************************/
void CServerMain::DoAutomaticChangeProductInTank__()
{
	try
	{
		DoAutomaticChangeProductInTank();
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticChangeProductInTank__()", LOG_LEVEL_0);
		exit(1);
	}
}

/******************************************************************************
 Description:	Automatic procedure for changing product in tank
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		25/02/2009   13:40			Start		4.0.22.503 - TD 72189
******************************************************************************/
void CServerMain::DoAutomaticChangeProductInTank()
{
	m_cServerInfo.HandleChangeProductInTankProcess();
}


/******************************************************************************
 Description:	Return timeout for closing open sales
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		03/03/2009   10:40			Start		4.0.22.503 - TD 72189
******************************************************************************/
DWORD CServerMain::GetCloseOpenSalesTimeout() 
{
	return m_dwCloseOpenSalesTimeOut;
}

/******************************************************************************
 Description:	Return wetstock report include old data flag
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		15/03/2009   16:00			Start		4.0.22.503 - TD 69905
******************************************************************************/
DWORD CServerMain::GetWetStockReportIncludeOldDataFlag()
{
	return (long)m_dwWetStockReportIncludeOldData;
}


/******************************************************************************
					Configuration Thread wrap Methods
  
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena			01/05/2009   ??:??		Start	//4.0.22.45 TD 72716
******************************************************************************/

inline void	CServerMain::LoadConfigurationThread(const BOOL bCreate) 
{
	m_cConfigurationThread.LoadConfiguration(bCreate);

	if (TRUE == m_cConfigurationThread.IsForecourtLockedByConfigurationThread())
	{
		m_cLogger.LogMsg("CServerMain::LoadConfigurationThread, Server locked by ConfigurationThread. Set Flag=[MP_FORCED_UNLOCK]", LOG_LEVEL_1);

		m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_FORCED_UNLOCK);

		m_cConfigurationThread.SetForecourtLocked(FALSE);
	}

}


inline BOOL	CServerMain::CreateConfigurationThread()
{
	return (m_cConfigurationThread.Init() == THREAD_OK) ? TRUE : FALSE;
}


inline void	CServerMain::StartConfigurationThread()	
{
	m_cConfigurationThread.StartThread();
}


BOOL CServerMain::SetConfiguratonThreadData(const BYTE* szThreadData, const size_t iDataLength)
{
	return m_cConfigurationThread.SetThreadData(szThreadData, iDataLength);
}


inline void	CServerMain::StopConfigurationThread()
{
	m_cConfigurationThread.StopThread();
}


inline void	CServerMain::CleanUpConfigurationThread()
{
	if (m_cConfigurationThread.IsThreadAlive() == TRUE)
		m_cConfigurationThread.CleanUp();
}

/******************************************************************************/

/******************************************************************************
 Description:	Automatic process which manages the price change with ack from CL
				per pump process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		21/10/2009   12:00			Start		4.0.19.820 - TD 78775
******************************************************************************/
void CServerMain::DoAutomaticPriceChangeWithAckPerPump__()
{
	try
	{
		DoAutomaticPriceChangeWithAckPerPump();
	}
	catch(...)
	{
		if(LOG_ERROR)

			_LOGMSG.LogMsg("CServerMain::DoAutomaticPriceChangeWithAckPerPump()", LOG_LEVEL_0);

		exit(1);
	} 
}

/******************************************************************************
 Description:	Automatic process which manages the price change with ack from CL
				per pump process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		21/10/2009   12:00			Start		4.0.19.820 - TD 78775
******************************************************************************/
void CServerMain::DoAutomaticPriceChangeWithAckPerPump()
{
	if (m_cServerInfo.GetInPriceChangeWithAckProcessFlag())
		m_cServerInfo.HandlePriceChangeWithAckPerPumpProcess();
}

/******************************************************************************
 Description:	Return timeout for price change with ack per pump CL response timeout
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		21/10/2009   14:15			Start		4.0.19.820 - TD 78775
******************************************************************************/
DWORD CServerMain::GetPriceChangeWithAckPerPumpResponseTimeout() 
{
	return m_dwPriceChangeWithAckPerPumpTimeout;
}


/******************************************************************************
 Description:	Check if pump is in COMMS_TERMINATED state
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		21/10/2009   16:05			Start		4.0.19.820 - TD 78775
******************************************************************************/
BOOL CServerMain::PumpInCommsTerminatedState(long lPumpNumber)
{
	BOOL bRetVal;

	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	if( m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() == COMMS_TERMINATED )
		bRetVal = TRUE;
	else
		bRetVal = FALSE;

	return bRetVal;
}


/******************************************************************************
 Description:	Set Redundancy By Controller according to HydraActiveBitMap
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/12/2009   16:05			Start		//4.0.23.508
******************************************************************************/
void  CServerMain::SetRedundancyByCL(DWORD dwHydraActiveBitMap)
{
	m_bRedundancyByCL = (dwHydraActiveBitMap & HYDRA_REDUNDANCY_BY_CL) ? TRUE : FALSE;
}


/******************************************************************************
 Description:	IsRedundancyByCL
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/12/2009   16:05			Start		//4.0.23.508  TD 89049
******************************************************************************/
BOOL CServerMain::IsRedundancyByCL()const
{
	return m_bRedundancyByCL;
}


/******************************************************************************
 Description:	Handle Redundancy By Controller set HydraActive to not active
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/12/2009   16:05			Start		//4.0.23.508  TD 89049
******************************************************************************/
void CServerMain::HandleRedundancyByCL()
{
	m_dwHydraActive = HYD_NOT_ACTIVE;
	
	if(LOG_BASIC_FLOW_CONTROL)	
	{
		m_cLogger.LogMsg("PumpSrv is running without HydService with REDUNDANCY by CL");
	}
}


//4.0.23.508 TD 94548
BOOL CServerMain::IsCurrentRegion(DWORD dwRegion) const
{
	BOOL bRetCode = (m_dwRegion == dwRegion) ? TRUE : FALSE;

	return bRetCode;
}


/******************************************************************************
 Description:	Reset Empty ExtraInfo Qdx data
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena			23/12/2009   11:44(AUS)		Start	//4.0.23.510 no TD
******************************************************************************/

void CServerMain::ResetExtraInfoQdxData()
{
	// TODO: delete all recored from extra info database.
	//m_cExtraInfoFile.EmptyExtraInfoFile();
}


/******************************************************************************
 Description:	Reset Empty ExtraInfo Qdx data
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena			28/03/2010   17:34		Start	//4.0.24.70  TD 114655
******************************************************************************/

void CServerMain::GetPumpInfo(const long lPumpNumber, PUMP_INFO* pPumpInfoOut)
{
	long lPumpIndex = lPumpNumber - 1;

	memset(pPumpInfoOut, 0, sizeof(PUMP_INFO));	
	
	pPumpInfoOut->m_lNumber			= lPumpNumber;
	pPumpInfoOut->m_lType			= m_cPumpArray[lPumpIndex].GetType();
	pPumpInfoOut->m_cPumpStat		= m_cPumpArray[lPumpIndex].GetStat();
	pPumpInfoOut->m_lLockStatus		= m_cPumpArray[lPumpIndex].GetLockStatus();
	pPumpInfoOut->m_lShiftNumber	= m_cPumpArray[lPumpIndex].GetShiftNumber();
	m_cPumpArray[lPumpIndex].GetName((char *)pPumpInfoOut->m_sPumpMenufacture, MAX_NAME_LENGTH);		
	m_cPumpArray[lPumpIndex].GetOlaStat(&pPumpInfoOut->m_cOLA); 

	for (int i = 0; i < MAX_TRS_IN_LIST; i++)
	{		
		m_cPumpArray[lPumpIndex].GetTrsByIndex(i, &pPumpInfoOut->m_cTrs[i]);	
	}
}

/******************************************************************************
 Description:	Check if pump is in UNKNOWN_STATUS state
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		01/04/2010   15:00			Start		4.0.24.70 - TD 115975
******************************************************************************/
BOOL CServerMain::PumpInUnknownState(long lPumpNumber)
{
	BOOL bRetVal;

	CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

	if( m_cPumpArray[lPumpNumber-1].GetStat().GetStatus() == UNKNOWN_STATUS )
		bRetVal = TRUE;
	else
		bRetVal = FALSE;

	return bRetVal;
}

//4.0.24.71 No TD
void CServerMain::ConvertXmlReceiptAndLoyaltyDiscountToDBData( long lPumpNumber, const char* szXmlBuffIn, CPumpTransact* pPumpTransactInOut, PRE_PAY_INFO* pPrePayInfoInOut, TAG_DISCOUNT_LOYALTY_INFO4* pDiscountLoyaltyInfoInOut )
{
	TAG_OLA_REC13	cTagOlaRec; //4.0.27.47
	memset(&cTagOlaRec, ' ', sizeof(TAG_OLA_REC13));

	if ( m_cXmlConvertorEx.ConvertFromXmlToStruct((char *)szXmlBuffIn, &cTagOlaRec) )
	{
		PAY_AT_PUMP_INFO	cPAPInfo;	
		
		m_cCommonFunction.ConvertFromTagOlaRecToPAPInfo(&cPAPInfo, &cTagOlaRec.tagOlaRec12);

		//4.0.27.500 - merged from 4.0.124.354 215339
		char				sTrsNum[7] = {0};
		sprintf_s(sTrsNum, _countof(sTrsNum), "%ld", pPumpTransactInOut->m_lNumber);
		memset(cPAPInfo.CardSaleInfo.cardData.sTranNbr, ' ', sizeof(cPAPInfo.CardSaleInfo.cardData.sTranNbr)); 
		memcpy(cPAPInfo.CardSaleInfo.cardData.sTranNbr, sTrsNum, strlen(sTrsNum));

		pPumpTransactInOut->SetLink( pPumpTransactInOut->GetLinkFlags() + TRS_LINK_EXTRA_INFO, pPumpTransactInOut->m_lNumber);
		
		m_cCommonFunction.UpdateOLAFlags( &cPAPInfo, FL_PAP_AS_THIRD_REC );
		
		//Items
		{
			ITEMS_INFO	cItemInfo;
			if ( m_cCommonFunction.ConvertFromTagOlaRecToItems(&cItemInfo, &cTagOlaRec.tagOlaRec12) == OK )
			{
				//Set Items Link Index Size
				memcpy(cPAPInfo.CardSaleExtraData2.sItemsLinkIndex, cTagOlaRec.tagOlaRec12.tagOlaRec11.tagOlaRec10.extraData2.sItemsLinkIndex, sizeof(cPAPInfo.CardSaleExtraData2.sItemsLinkIndex) );

				m_cCommonFunction.UpdateOLAFlags( &cPAPInfo, FL_EXTRA_ITEM_REC );

				long lRtc = IndexOperation(ITEMS_FILE, REC_INSERT, &cItemInfo);

				CString tmpStr;
				tmpStr.Format("insert to items Qdx, retCode = %ld", lRtc);
				_LOGMSG.LogMsg(tmpStr);
			}
		}
																
		//Zones
		{
			PS::RECEIPT_EXTRA_INFO_REC	cReceiptExtraRec;
			if (m_cCommonFunction.ConvertFromTagOlaRecToZones(&cReceiptExtraRec, &cTagOlaRec.tagOlaRec12, pPumpTransactInOut->m_lNumber) == OK)
			{
				m_cCommonFunction.UpdateOLAFlags(&cPAPInfo, FL_EXTRA_RECEIPT_REC);

				CSQLPumpSrvReceiptExtraInfoDB::GetInstance().OperationEx(REC_INSERT, cReceiptExtraRec);
				//IndexOperation(RECEIPT_EXTRA_DATA_FILE, REC_INSERT, &cReceiptExtraRec);
			}
		}
		
		//Receipt
		{															
			RECEIPT_INFO			cReceiptInfo;
			char					szTrsNum[7] = {0};

			//Update track2 and accountNum to trs number, it's will be RECEIPT INDEX in PrePay transactions
			sprintf_s(szTrsNum, _countof(szTrsNum), "%ld", pPumpTransactInOut->m_lNumber );
			memcpy( cPAPInfo.CardSaleInfo.cardData.sTrack2Data, szTrsNum, min(strlen(szTrsNum), sizeof(cPAPInfo.CardSaleInfo.cardData.sTrack2Data)) );
			memcpy( cPAPInfo.CardSaleInfo.cardData.sAccountNumber, szTrsNum, min(strlen(szTrsNum), sizeof(cPAPInfo.CardSaleInfo.cardData.sAccountNumber)));
			
			m_cBaseReceipt->ConvertOlaToReceipt(pPumpTransactInOut, &cPAPInfo, &cReceiptInfo, 0, 0, TRS_NUMBER_IN_RECEIPT_INDEX);

			CReceiptInfo ReceiptInfo;
			_Module.m_server.m_cBaseReceipt->ConvertOlaToReceipt(pPumpTransactInOut, &cPAPInfo, ReceiptInfo);//4.0.9.503
			CSQLReceiptDB::GetInstance().UpdateReceipt(ReceiptInfo);

		}
		
		//Loyalty
		{
			CheckVlidityTransactionNumber( pPumpTransactInOut->m_lNumber ); 
			m_cCommonFunction.ConvertFromTagOlaRecToTagDiscountLoyalty( pDiscountLoyaltyInfoInOut, &cTagOlaRec, lPumpNumber);

			m_cCommonFunction.CalcLoyaltyVolumeLimit( pDiscountLoyaltyInfoInOut );

			if (pPrePayInfoInOut->sPreSetLimitType == LIMIT_BY_VOLUME)	
			{
				m_cCommonFunction.SetLowesBetweenOLAandLoyaltyLimits( lPumpNumber, pDiscountLoyaltyInfoInOut, pPrePayInfoInOut );
			}														
		}
	}
}


//4.0.22.131 
void CServerMain::UpdatePrePayWithXmlReceiptAndDiscountData( long lPumpNumber, const char* szXmlBuffIn, CPumpTransact* pPumpTransactInOut, PRE_PAY_INFO* pPrePayInfoInOut )
{
	TAG_DISCOUNT_LOYALTY_INFO4	sDiscountLoyaltyInfo;

	memset( &sDiscountLoyaltyInfo, ' ', sizeof(sDiscountLoyaltyInfo) );
	
	//We need to turn on the loyalty flag here since we have discounts to be used in QueueHandle:
	pPrePayInfoInOut->lFlags |= LOYALTY_DISCOUNT_DATA;											//4.0.24.75

	ConvertXmlReceiptAndLoyaltyDiscountToDBData( lPumpNumber, szXmlBuffIn, pPumpTransactInOut, pPrePayInfoInOut, &sDiscountLoyaltyInfo );		

	//finally insert all the data to the extra info qdx
	long lRtc = TrsLinkOperation( REC_INSERT, pPumpTransactInOut, pPrePayInfoInOut, &sDiscountLoyaltyInfo );

	CString tmpStr;
	tmpStr.Format("insert to extra info Qdx, retCode = %ld", lRtc);
	_LOGMSG.LogMsg(tmpStr);
}


//4.0.22.131 
void CServerMain::SetAddEncodingStringToVPXml(DWORD dwAddEncodingStringToVPXml)
{
	m_dwAddEncodingStringToVPXml = dwAddEncodingStringToVPXml;
}


//4.0.24.90 TD 106227 
DWORD CServerMain::GetAddEncodingStringToVPXml()
{
	return m_dwAddEncodingStringToVPXml;
}

//4.0.24.90 TD 106227
void CServerMain::SetSingleCoreActive(DWORD dwSingleCoreActive)
{
	m_dwSingleCoreActive = dwSingleCoreActive;
}


//4.0.24.90 TD 106227 
DWORD CServerMain::GetSingleCoreActive()
{
	return m_dwSingleCoreActive;
}
/******************************************************************************
 Description:	Set the process to work with a single core according to parameter
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amith		26/04/2010   15:00			Start		4.0.24.90 - TD 106227
******************************************************************************/
void CServerMain::SetApplicationSingleCore()
{
	if ((GetSingleCoreActive()) && (IsRunningMultiCores()))
	{
		m_cLogger.LogMsg("Setting Processor Affinity to work in single core");
		SetProcessAffinityToSingleCore();

		if (IsRunningMultiCores())
			m_cLogger.LogMsg("Error - Processor Affinity is still running in multiple cores !",LOG_LEVEL_1);
	}
}

//4.0.25.50 - TD 108311
void CServerMain::SetSingleShiftAccumulationsActive(DWORD dwSingleShiftAccumulationsActive)
{
	m_dwSingleShiftAccumulationsActive = dwSingleShiftAccumulationsActive;
}


//4.0.25.50 - TD 108311
DWORD CServerMain::GetSingleShiftAccumulationsActive()
{
	return m_dwSingleShiftAccumulationsActive;
}

//4.0.26.501 - TD 116227
short CServerMain::GetExtGradeByGrade(long lGradeId, long *plExtGradeId, long lPumpNumber)
{
	short nRetCode = RetCode_Success;
	long lExtendedGradeId = 0;

	m_cExtendedGradeMap.GetExtGradeByGrade(lGradeId, lExtendedGradeId, lPumpNumber);
	if (plExtGradeId && lExtendedGradeId > 0)
		*plExtGradeId = lExtendedGradeId;
	else
		nRetCode = RetCode_Failure;

	return nRetCode;
}

//4.0.26.501 - TD 116227
short CServerMain::GetExtGradeByGrade(BYTE *sGradeId, long lSize, long lPumpNumber)
{
	short nRetCode = RetCode_Success;
	long lExtendedGradeId = 0;

	m_cExtendedGradeMap.GetExtGradeByGrade(sGradeId, lSize, lExtendedGradeId, lPumpNumber);
	if (lExtendedGradeId > 0)
		l2a(lExtendedGradeId, sGradeId, lSize);
	else
		nRetCode = RetCode_Failure;

	return nRetCode;
}

//4.0.26.501 - TD 116227
short CServerMain::GetGradeByExtGrade(long lExtGradeId, long *plGradeId, long lPumpNumber)
{
	short nRetCode = RetCode_Success;
	long lNonExtendedGradeId = 0;
	
	m_cExtendedGradeMap.GetGradeByExtGrade(lExtGradeId, lNonExtendedGradeId);
	if (plGradeId && lNonExtendedGradeId > 0)
		*plGradeId = lNonExtendedGradeId;
	else
		nRetCode = RetCode_Failure;

	return nRetCode;
}

BOOL CServerMain::IsActiveANPR() //4.0.26.505 157073
{
	return (m_dwActiveANPR > 0)? TRUE:FALSE;
}

void CServerMain::SetANPRState(DWORD dwState)
{
	m_dwActiveANPR = dwState;
}

//4.0.26.508 147183 start
void CServerMain::SetNumOfPricePoleDisplays(long lNum)
{
	m_dwNumOfPricePoleDisplays = lNum;
}

BOOL CServerMain::IsActivePricePole()
{
	if (m_dwNumOfPricePoleDisplays > 0)
	{
		return TRUE;
	}
	return FALSE;
}

void CServerMain::ActivatePriceChangeProcess(long lFlags, long lMaxUnitForDiscount)
{
	if(IsRollbackOnPriceChangeFailure() || m_cServerInfo.IsInPriceChangeWithIntegrityProcess())					//4.0.12.515 //4.0.27.20
	{

		//update the flag to indicate of price change process 
		SetInPriceChangeProcess(TRUE); //4.0.12.518

		m_cAlarm.AddSendMessage(CATEGORY_PUMP,SUB_PRICE_CHANGE,PRICE_CHANGE_START,1,ALARM_STARTED,lMaxUnitForDiscount,0); //4.0.12.518

		SetInOriginalPriceChangeProcess(TRUE);
	}
	else
	{
		//Send alarm to inform start of price change.
		m_cAlarm.AddSendMessage(CATEGORY_PUMP,SUB_PRICE_CHANGE,PRICE_CHANGE_START,1,ALARM_STARTED,0,0);
	}

	//4.0.19.820 - TD 78775
	if((lFlags & MAX_UNIT_IS_BATCH_NUM) && (lFlags & PRICE_CHANGE_WITH_ACK_PER_PUMP))
	{
		m_cServerInfo.SetPriceChangeWithAckRefNumber(lMaxUnitForDiscount);
		m_cServerInfo.StartPriceChangeWithAckPerPumpProcess();	
	}
	

	if(LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("Price Change Process was activated" );
		m_cLogger.LogMsg(str);	
	}
}

void CServerMain::SetPriceChangeBatchNumber(long lNewNumber) //4.0.26.508 147183
{
	m_lPriceChangeBatchNumber = lNewNumber;
}

BOOL CServerMain::IsFlowRateActive()									//4.0.27.41 TD 165585
{
	return (m_dwFlowRateActive > 0)? TRUE:FALSE;
}

void CServerMain::SetFlowRateActive(DWORD dwState)						//4.0.27.41 TD 165585
{
	m_dwFlowRateActive = dwState;
}

//4.0.26.508 147183 end
/******************************************************************************
 Description:	DoAutomaticQdxMaintenance__ general
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
void CServerMain::DoAutomaticQdxMaintenance__()
{
	try
	{
		if ( IsAutomaticQdxMaintenanceActive() == TRUE && IsAutomaticQdxMaintenanceTimeOut() == TRUE )
		{
			DoAutomaticQdxMaintenance();
		}
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticQdxMaintenance()", LOG_LEVEL_0);
		exit(1);
	}
}


/******************************************************************************
 Description:	DoAutomaticQdxMaintenance internal
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
void CServerMain::DoAutomaticQdxMaintenance()
{
	//////////////////////////////////////////////////
	// Start QDX maintenance process

	/*
	CString str("DoAutomaticQdxMaintenance - Start QDX maintenance!");
	m_cLogger.LogMsg(str);

	if (!m_cQDXMaintThread.StartQDXMaintThread())
	{
		SaveReloadQdxLastTime();

		CString str("DoAutomaticQdxMaintenance - QDX Maintenance started successfully!");
		m_cLogger.LogMsg(str);
	}
	*/
	m_cLogger.LogMsg("DoAutomaticQdxMaintenance - Not Active!", LOG_LEVEL_0);
}

/******************************************************************************
 Description:	set method
 Returns:      	
 Parameters:   pTagTime - source value

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
void CServerMain::SetReloadQdxLastTime(const SZ_TAG_SYSTEMTIME* pTagTime)
{
	Tag2SystemTime((TAG_SYSTEMTIME*)&pTagTime->sTime, &m_cReloadQdxLastTime);
}


/******************************************************************************
 Description:	Update m_cReloadQdxLastTime member with current time
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
void CServerMain::UpdateReloadQdxLastTime()
{
	memset(&m_cReloadQdxLastTime, 0, sizeof(m_cReloadQdxLastTime));
	GetLocalTime(&m_cReloadQdxLastTime);
}


/******************************************************************************
 Description:	Save m_cReloadQdxLastTime member to RunTime ini file
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
void CServerMain::SaveReloadQdxLastTime()
{
	SZ_TAG_SYSTEMTIME	szTagTime;

	memset(&szTagTime, 0, sizeof(szTagTime));
	szTagTime.sNull = 0;

	UpdateReloadQdxLastTime();
	SystemTime2Tag(&m_cReloadQdxLastTime, &szTagTime.sTime);

	m_cParam.SaveParam("GeneralParam", "ReloadQDXLastTime", (char *)&szTagTime, TRUE, 0, 0, 0, TRUE);	
}
	

/******************************************************************************
 Description:	Is Automatic QdxMaintenance Active
 Returns:      	TRUE -> active
				FALSE -> not active
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
BOOL CServerMain::IsAutomaticQdxMaintenanceActive()const
{
	BOOL bRetVal = TRUE;

	bRetVal = (m_dwReloadQDXEveryXDays == 0) ? FALSE : TRUE;

	return bRetVal;
}


/******************************************************************************
 Description:	Is Automatic QdxMaintenance TimeOut
 Returns:      	TRUE -> TimeOut
				FALSE -> not yet
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		09/11/2010   15:00			Start		//4.0.26.501 TD 144220
******************************************************************************/
BOOL CServerMain::IsAutomaticQdxMaintenanceTimeOut()const
{
	BOOL		bRetVal = TRUE;
	CTime		cCurrentTime;
	CTime		cNextActionTime;
	CTime		cLastActionTime;
	CTimeSpan 	cTimeDelta(m_dwReloadQDXEveryXDays, 0, 0, 0);

	cLastActionTime = m_cReloadQdxLastTime;
	cCurrentTime = CTime::GetCurrentTime();
	cNextActionTime = cLastActionTime + cTimeDelta;
		
	bRetVal = ( cCurrentTime >= cNextActionTime ) ? TRUE : FALSE;

	return bRetVal;
}



/******************************************************************************
 Description:	Do AutomaticExportSiteConfiguration
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Gena		28/12/2010   20:36			Start		//4.0.26.508 TD 146575
******************************************************************************/
void CServerMain::DoAutomaticExportSiteConfiguration__()
{
	try
	{
		DoAutomaticExportSiteConfiguration();
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticExportSiteConfiguration()", LOG_LEVEL_0);

		exit(1);
	}
}


void CServerMain::DoAutomaticExportSiteConfiguration()
{
	m_cSiteConfigurationExporter.ExportSiteConfiguration();
}


/******************************************************************************
Description: Set internal PrePay flag. 

  WHO			WHEN                    WHAT
  -------------------------------------------------------------------------------
  marik							 		Start //4.0.24.351 //4.0.124.355 //4.0.27.60 231255
******************************************************************************/
void CServerMain::SetPrePayReTryReservation(long lPumpNumber, long lVal)
{
	m_lPrePayReTryReservation[lPumpNumber] 	= lVal;								
}

/******************************************************************************
 Description: recalculate the tax amount with out the overfill amount and save it to the pData	
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shuki Y		02/05/2011   12:35		Start		4.0.27.500	TD 231498
******************************************************************************/
void CServerMain::UpdateTaxAmountWithoutOverfill(PAY_AT_PUMP_INFO *pData)
{

	long lOverFillAmount = a2l(pData->CardSaleExtraData5.sOverFillAmount,sizeof(pData->CardSaleExtraData5.sOverFillAmount));
	if(lOverFillAmount > 0)
	{
		long lFuelAmount = 0;
		long lFuelAmountNoOverFill = 0;
		long lTaxRate = 0;
		long lTaxAmountNoOverFill = 0;

		lFuelAmount = ConvertStringsToLong(pData->CardSaleInfo.extraData.sFuelAmt,sizeof(pData->CardSaleInfo.extraData.sFuelAmt),pData->CardSaleInfo.extraData.sFuelAmt_Msb,sizeof(pData->CardSaleInfo.extraData.sFuelAmt_Msb));
		lFuelAmountNoOverFill = (lFuelAmount - lOverFillAmount) * 10;


		BYTE sTmpVat[sizeof(pData->CardSaleInfo.extraData.sVAT_Rate)+sizeof(pData->CardSaleExtraData5.sVAT_RateMSB)] = {' '}; //4.0.31.500  TD 404911
		PackFields(pData->CardSaleInfo.extraData.sVAT_Rate, sizeof(pData->CardSaleInfo.extraData.sVAT_Rate), &pData->CardSaleExtraData5.sVAT_RateMSB, sizeof(pData->CardSaleExtraData5.sVAT_RateMSB), sTmpVat);	
		lTaxRate  = a2l(sTmpVat,sizeof(sTmpVat)); // OmerT - need to check, might not need to mutiply after adding anther byte

		lTaxAmountNoOverFill = lFuelAmountNoOverFill - (long)((lFuelAmountNoOverFill * 100) / (lTaxRate/(float)1000 + 100));
		lTaxAmountNoOverFill = ((lTaxAmountNoOverFill + 5) / 10) * 10;

		memset(&pData->CardSaleExtraData3.sTaxAmt_Msb2 ,' ', sizeof(pData->CardSaleExtraData3.sTaxAmt_Msb2));
		memset(&pData->CardSaleExtraData3.sTaxAmt_Msb ,' ', sizeof(pData->CardSaleExtraData3.sTaxAmt_Msb));
		memset(&pData->CardSaleInfo.extraData.sTaxAmt ,' ', sizeof(pData->CardSaleInfo.extraData.sTaxAmt));
		Convertl2Str3(lTaxAmountNoOverFill, &pData->CardSaleExtraData3.sTaxAmt_Msb2 , sizeof(pData->CardSaleExtraData3.sTaxAmt_Msb2), pData->CardSaleExtraData3.sTaxAmt_Msb, sizeof(pData->CardSaleExtraData3.sTaxAmt_Msb),  pData->CardSaleInfo.extraData.sTaxAmt, sizeof(pData->CardSaleInfo.extraData.sTaxAmt));
	}
}


/******************************************************************************
 Description: Reset the grade price table when running with PRICE_CHANGE_INTEGRITY mode
			  We reset the table only in the first price change.

 Returns:      	
 Parameters:  nGrade - grade to change 
			  lMode - Full or Service mode
			  nLevel - case or credit
			  nFlags - flags

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT          18/05/2011   12:35		Start	
******************************************************************************/
void CServerMain::ResetGradePriceTable(short nGrade, long lMode, short nLevel,short nFlags)
{
	static BOOL bIsFirstTime = TRUE;

	if( (nFlags & PRICE_CHANGE_INTEGRITY)  && (bIsFirstTime) )
	{

		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString sMsg;
			sMsg.Format("CServerMain::ResetGradePriceTable, First Price change recived.Reset valid grades started");
			_LOGMSG.LogMsg(sMsg);
		}

		bIsFirstTime = FALSE;
		
		//Load Grades Code
		for(int i = 1; i <= MAX_GRADES_99; i++)
		{
			DWORD dwTmp;
			CString str("Grades\\Grade");
			char sNumber[8];
			memset(sNumber,0,sizeof(sNumber));	
			sprintf_s(sNumber, _countof(sNumber),"%02d",i);
			str += sNumber;

			m_cParam.LoadParam((LPCSTR)str, "ValidEntry",&dwTmp,(DWORD)0, FALSE);
			if (dwTmp)
			{
				m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_FullService", &dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)str), "Old_PriceCash_FullService", dwTmp,TRUE,0,0,0,TRUE);    
				
				
				m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_FullService", &dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)str), "Old_PriceCredit_FullService", dwTmp,TRUE,0,0,0,TRUE);    
				
				
				m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_SelfService", &dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)str), "Old_PriceCash_SelfService", dwTmp,TRUE,0,0,0,TRUE);    
				
				m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_SelfService", &dwTmp,(DWORD)0,TRUE,TRUE,0,HOP_DIRECT_LOCAL,TRUE);
				m_cParam.SaveParam((char *)((LPCTSTR)str), "Old_PriceCredit_SelfService", dwTmp,TRUE,0,0,0,TRUE);    
			}
		}	
	}

	// if it's the last price change set the flag on again
	if((nFlags & PRICE_CHANGE_INTEGRITY) && (nFlags & PRICE_END_OF_LIST))
	{
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString sMsg;
			sMsg.Format("CServerMain::ResetGradePriceTable, Last price change recived");
			_LOGMSG.LogMsg(sMsg);
		}
		bIsFirstTime = TRUE;
	}
}	// TD 236747


//4.0.28.502  - TD 256429
/******************************************************************************
 Description:	Terminal commands handler
 Returns:      	Zero on success, otherwise failure. 
 
 WHO			            WHEN                    WHAT
-------------------------------------------------------------------------------
  AlexM			24/08/2011    - Start
******************************************************************************/
long CServerMain::ProcessTerminalCmd(TerminalCmdCode eTerminalCmdCode, long lTerminalId) 
{
	long lRtc = 0;

	if (CheckOLA() != OLASRV_COM_ERROR)
	{
		CString str;
		str.Format("CServerMain::ProcessTerminalCmd TerminalId: %ld, Command: %ld",lTerminalId, eTerminalCmdCode);
		_LOGMSG.LogMsg(str);
		
       lRtc = m_cCommonFunction.HandleTerminalCmd(eTerminalCmdCode, lTerminalId);  

	}

	return lRtc; 
}

/******************************************************************************
Description: Sets a session complete vs OLA when PAK

  WHO			WHEN                    Version/TD
  -------------------------------------------------------------------------------
  OmerT			22/08/11    4.0.14.1390/TD 67387 | 4.0.21.0 | 4.0.124.441/TD 256101 
******************************************************************************/
void CServerMain::SetForceSessionCompletePak(long p)
{
	if (LOG_DETAIL_FLOW_CONTROL)
	{
		CString str("CServerMain::SetForceSessionCompletePak");
		_LOGMSG.LogMsg(p, LOG_PUMP, str, LOG_LEVEL_3); 
	}

	if( m_cPumpArray[p].IsForceZeroPakCompletionOn() && 
	  ( m_cPumpArray[p].IsLoyaltyClub() || m_cPumpArray[p].IsPapToPakTrs())) 
	{	
		OLA_STAT ola;

		m_cPumpArray[p].SetInPAKLoyaltyWithComplete(TRUE);
		m_cPumpArray[p].GetOlaStat(&ola);
		ola.m_lSessionNumber = 0; 
		ola.m_byCheckCount = 0;
		ola.m_byState = OLA_REQUEST_TO_SEND | SESSION_COMPLETE;
		m_cPumpArray[p].SetOlaStat(&ola); 

		ClearPAPInfo(p+1);   //4.0.23.1130 TD 258004
		_Module.m_server.m_cFuelLoayaltyPS.InitSavedLoyaltyInfo(p); //RFUEL-2378 clear all former promotions to avoid redundancy
		if(LOG_BASIC_FLOW_CONTROL)
		{
			m_cLogger.LogOLAMsg(p+1, ola.m_byState, ola.m_lSessionNumber);
			CString str;
			str.Format("ForceZeroPakCompletion flag is ON - session complete is starting");
			m_cLogger.LogMsg("GCI","SetPumpStatus",p+1,LOG_PUMP,str);							
		}	
	}
}

/******************************************************************************
 Description:	Check for timeout Expiry and report to RFS when needed 
				
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 OmerT			11/08/2011   11:54		Start		4.0.23.1050 TD 233242
******************************************************************************/
void CServerMain::DoAutomaticTrsAutoReconcile__()
{
	try
	{
		DoAutomaticTrsAutoReconcile();
	}
	catch(...)
	{
		if(LOG_ERROR)
			_LOGMSG.LogMsg("CServerMain::DoAutomaticTrsAutoReconcile()", LOG_LEVEL_0);
		
		exit(1);
	}
}

/******************************************************************************
 Description:	Check for timeout Expiry and report to RFS when needed 
				Goes over the pump array, for each trs check if auto reconcile 
				timeout expired using CTimeOutManager. If timeout expired 
				and trs status is WAIT_PROGRESS or IN_PROGRESS report
				RFS using CMD_GENERAL_SYSTEM_EVENT.
 Returns:      	
 Parameters:   	
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 OmerT			11/08/2011   11:54		Start		4.0.23.1050 TD 233242
******************************************************************************/
void CServerMain::DoAutomaticTrsAutoReconcile()
{
	int iPumpArraySize = GetMaxPumps();
	for (int p = 0; p < iPumpArraySize; p++)
	{
		CTimeOutManager cAutoReconcileTimeOut;
		const TRS_ARRAY * pTrsArray = m_cPumpArray[p].GetTrsArray();
		int iArraySize = pTrsArray->GetSize();
		for(int iTrs = 0; iTrs < iArraySize; iTrs++)
		{	
			// get the trs
			CPumpTransact pPumpTrs = pTrsArray->GetAt(iTrs);
			if(pPumpTrs.GetAutoReconcileTimeout() > 0 && 
				(pPumpTrs.GetStatus() == WAIT_PROGRESS || pPumpTrs.GetStatus() == IN_PROGRESS))
			{
				// set starting time and timeout interval
				cAutoReconcileTimeOut.SetTimeOutIntervalInMiuntes( pPumpTrs.GetAutoReconcileTimeout() , pPumpTrs.GetStartTime());
				if( cAutoReconcileTimeOut.IsExpired() )
					// timeout expired, set auto-reconcile event
					SetCommand(CMD_GENERAL_SYSTEM_EVENT, p + 1 , GCI_EVENT_AUTO_RECONCILE);				
			}
		}	
	}
}

/******************************************************************************
 Description: Sets reconcile timeout for the given trs.
								
 Returns:     
 Parameters:  const TAG_DISCOUNT_LOYALTY_INFO4 * pLoyaltyInfo - Holds the reconcile timeout recived from POS
													
			  
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 OmerT			11/08/2011   11:54		Start		4.0.23.1050 TD 233242
******************************************************************************/
void CServerMain::SetAutoReconcileTimeout(long lPumpNumber , const TAG_DISCOUNT_LOYALTY_INFO4 * pLoyaltyInfo , CPumpTransact * pTrs)
{
	// get the timeout from the loyalty struct 
	SHORT nAutoReconcileTimeout = (SHORT)a2l( (unsigned char *) pLoyaltyInfo->sTrsAutoReconcileTimeout, sizeof(pLoyaltyInfo->sTrsAutoReconcileTimeout));
	
	if(nAutoReconcileTimeout > 0)
	{
		// set it into the trs
		pTrs->SetAutoReconcileTimeout(nAutoReconcileTimeout); 

		// update pump array
		CentralUpdateTrs(lPumpNumber,pTrs->m_lNumber,pTrs,FALSE);
		
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			str.Format("Recived AutoReconcile timeout for Prepay trs %d timeout=%d", pTrs->m_lNumber , nAutoReconcileTimeout);
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
		}
	}
}

/******************************************************************************
 Description: Looks for a trs with a given reservation in a given pump.
			  Set the given timeout in that trs. 
 Assumption:  There is only one pending PAP trs in a pump.  				
 Returns:     True if found a trs with a PAY_AT_PUMP reservation.	
 Parameters:  SHORT nTimeOut - auto reconcile timeout to be set.
			  long lPumpNum  - The pump number 
 
 WHO			WHEN                    WHAT		Version
-------------------------------------------------------------------------------
 OmerT			11/08/2011   11:54		Start		4.0.23.1050 TD 233242
******************************************************************************/
void CServerMain::SetAutoReconcileTimeout(long lPumpNumber , SHORT nTimeOut , PumpReservation res)
{
	int iTrsNum;
	int iTrsIndex = m_cPumpArray[lPumpNumber - 1].GetTrsIndexByReservation(res, iTrsNum);
	if(iTrsIndex != -1)
	{
		m_cPumpArray[lPumpNumber - 1].SetAutoReconcileTimeout(nTimeOut,iTrsIndex);
		if(LOG_DETAIL_FLOW_CONTROL)
 		{
 			CString str;
 			str.Format("Recived AutoReconcile timeout for trs %d timeout=%d" , iTrsNum , nTimeOut);
 			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
 		}
	}
	else
	{
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString str("Recived AutoReconcile timeout but couldn't set it to a PAP trs!");
			_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str,LOG_LEVEL_1); // add pump number to log
		}
		// log not find and not set 
	}
}

/******************************************************************************
Description:	This method clears the discounts info in CardSaleData
Returns:      	
Parameters:   

  WHO			WHEN                    WHAT
  -------------------------------------------------------------------------------
  Ella		20/09/2011   12:00			Start		4.0.28.503 - TD 263766
******************************************************************************/
void CServerMain::ClearDiscountsInfo(long lPumpNumber, PAY_AT_PUMP_INFO *pPAPInfo)
{
	for(int i=0 ; i< MAX_GRADES; i++)
	{
		l2a(0, pPAPInfo->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount, sizeof(pPAPInfo->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount));
	}	
	
	memset(pPAPInfo->CardSaleExtraData3.GradeLimitsArray, ' ', sizeof(pPAPInfo->CardSaleExtraData3.GradeLimitsArray));
	memset(pPAPInfo->CardSaleInfo.extraData.sLoyalId, ' ', sizeof(pPAPInfo->CardSaleInfo.extraData.sLoyalId));
	memset(pPAPInfo->CardSaleExtraData2.sPromotionNumber, ' ', sizeof(pPAPInfo->CardSaleExtraData2.sPromotionNumber));
	
	_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,"Clear discounts data.");
}

/******************************************************************************
Description:	Handle state UNLOCK in shift change process
Returns:      	
Parameters:   

  WHO			WHEN                    WHAT
  -------------------------------------------------------------------------------
  Ella		04/08/2011   08:00			Start		4.0.29.0 - TD 241916
******************************************************************************/
void CServerMain::HandleShiftStateUnlock()
{
	long lTmpLockResExt = m_cServerInfo.GetServerReservation();
	
	//4.0.12.509
	DWORD dwShiftLock; 
	m_cParam.LoadParam("GeneralParam","ShiftLock",&dwShiftLock,0,FALSE);
	if (dwShiftLock)
	{
		m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE,SUB_PUMPSRV,ALARM_FORECOURT_IN_MAINTENANCE,0,1,0,0);
	}
	
	//Add by Yaron for Ctrl Events
	m_cEventManager.AddEvent(CTRL_EVENT_SHIFT_STARTED,0);
	
	if(m_cCurrentShift.bExportSiteConfiguration)
		m_cSiteConfigurationExporter.ExportSiteConfiguration(TRUE);		//4.0.26.508 TD 146575
	
	
	//4.0.1.32 Add by Yaron for GCI Events
	SetCommand(CMD_GENERAL_SYSTEM_EVENT,0,GCI_EVENT_SHIFT_STARTED);
	
	if(m_cCurrentShift.byReconcileTankSrv)	//4.0.3.60 
		SetCommand(CMD_GENERAL_SYSTEM_EVENT,0,GCI_EVENT_CLOSE_RECONCILIATION_SHIFT);
	
	//Throw the GPI event: //4.0.19.504 - 47559
	if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse()) // CR 444830
	{
		m_cGPIEventMgr.AddGeneralSystemEvent(GPI_EVENT_SHIFT_STARTED, 0, m_cCurrentShift.dwActiveShiftNumber);
	}

	lTmpLockResExt &= MAINTENANCE;  //3.0.1.84			
	lTmpLockResExt |= SHIFT_CHANGE;
	
	if (m_cCurrentShift.bDoTankReading)
		lTmpLockResExt |= TANK_READING;
	if (m_cCurrentShift.bDoPumpTotalsReading)
		lTmpLockResExt |= PUMP_TOTALS_READING;	
	
	if (m_cCurrentShift.byForceShiftOLA)    //4.0.3.39
		lTmpLockResExt |= FORCE_SHIFT_OLA;					
	
	//4.0.5550.1504
	if (m_cCurrentShift.bDataBaseMaintenance)
		lTmpLockResExt |= DATABASE_MAINTENANCE; 
	
	//4.0.8.500
	
	
	if(LOG_BASIC_FLOW_CONTROL)
	{	
		CString str("Shift Process includes - ");
		if (m_cCurrentShift.bDoTankReading)
			str += "Tank Reading";
		if (m_cCurrentShift.bDoPumpTotalsReading)
			str += " ,Total Reading";			
		if (m_cCurrentShift.bLockPumpAtEndShift)
			str += " , Lock pump After Shift";					
		if (m_cCurrentShift.byForceShiftOLA)
			str += " , Force shift without check OLA";
		if(m_cCurrentShift.byReconcileTankSrv)
			str += " , reconcile TankSrv with tank gauge";
		if (m_cCurrentShift.bLockShiftIgnorCurrentShift) //4.0.5.39
			str += " , Force Shift lock";
		if (m_cCurrentShift.bLockShiftDuringProcess)//4.0.10.504
			str += ",  Lock Pumps During Process ";
		if (lTmpLockResExt & MAINTENANCE)   //4.0.7.504
			str += " , Server already lock for maintenance";
		
		if (lTmpLockResExt & DATABASE_MAINTENANCE)   //4.0.5550.1504
			str += " , Server already lock for database maintenance";
		
		m_cLogger.LogMsg(str);
	}	
	
	m_cServerInfo.SetServerReservation(lTmpLockResExt); //4.0.8.500
	SetServerLockStatus(STARTED);
	
	//4.0.18.501 - TD 33898
	if (m_dwReloadQDXEveryXShifts > 0)
	{
		m_lReloadQDXShiftsCounter++;
		m_cParam.SaveParam("GeneralParam","ShiftsToMaintenance",(m_dwReloadQDXEveryXShifts - m_lReloadQDXShiftsCounter),FALSE,0,0,0,TRUE);//33898
		if (m_dwReloadQDXEveryXShifts - m_lReloadQDXShiftsCounter == 1)	//4.0.19.0
		{
			m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE, SUB_PUMPSRV, NEXT_SHIFT_INCLUDES_RELOAD, 0, ALARM_STARTED, 0, 0);
		}
	}

	m_bShiftStateUnlockHandled = TRUE;
}


/******************************************************************************
Description:	Handle state STARTED or WAIT_LOCK in shift change process
Returns:      	
Parameters:   

  WHO			WHEN                    WHAT
  -------------------------------------------------------------------------------
  Ella		04/08/2011   08:00			Start		4.0.29.0 - TD 241916
******************************************************************************/
void CServerMain::HandleShiftStateStarted()
{
	BOOL bAllPumpsLocked = TRUE;							
	BOOL bAllPumpsDone = TRUE;							
	BOOL bForeCourtCloseByMaintenence  = (m_cServerInfo.GetServerReservation() & MAINTENANCE)? TRUE : FALSE;  //3.0.1.84


	for (int p = 0; p < m_lLastValidPump; p++)  //4.0.0.79
	{
		BOOL bUpdateShiftNumber = FALSE;		

		// M.L START 2/5/98
		// Pump Totals Reading & Tank Reading 
		//----------------------------------------
		if((m_cCurrentShift.bDoPumpTotalsReading)&&(m_cCurrentShift.bDoTankReading))
		{
			if(	m_cPumpArray[p].GetShiftNumber() != GetActiveShiftNumber())
			{
				bAllPumpsDone  = FALSE;
				bAllPumpsLocked  = FALSE;
				int iRetVal = 0;


				// if the forecourte is close, do not try to lock 	


				if (m_cServerInfo.GetShiftLockFlags())
					iRetVal = DoAutomaticReadTotal(p+1);
				else
					iRetVal = DoAutomaticReadTotal(p+1,FALSE);

				if(iRetVal == 0) //in progress 
				{
					// do nothing 
				}
				if(iRetVal == 1) //done 
				{
					bUpdateShiftNumber = TRUE;								
					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("Total Read done !"); 
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}	
				}
				if(iRetVal == 2) //cant start 
				{
					long lTmpLockResExt = m_cServerInfo.GetServerReservation();
					
					if (!bForeCourtCloseByMaintenence)   //3.0.1.84
					{
						DoAutomaticPumpLock(p+1,m_cServerInfo.GetServerReservation());
					}
					else if (bForeCourtCloseByMaintenence)  //4.0.7.506
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("Server detect conflict between Server info Maintenence to IDLE , Force clear server state !"); 
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}	

						m_cServerInfo.GetServerReservation();

						bForeCourtCloseByMaintenence  = FALSE; 
						lTmpLockResExt &= (~MAINTENANCE);
						m_cServerInfo.SetServerReservation(lTmpLockResExt);
						
						DoAutomaticPumpLock(p+1,lTmpLockResExt);
					}
				}
			}
		}
		// Pump Totals Reading ONLY 
		//--------------------------
		else if((m_cCurrentShift.bDoPumpTotalsReading)&&(!m_cCurrentShift.bDoTankReading))
		{
			if(	m_cPumpArray[p].GetShiftNumber() != GetActiveShiftNumber())
			{
				bAllPumpsDone  = FALSE;
				int iRetVal = 0;

				// if the forecourte is close, do not try to lock
				if(m_cServerInfo.GetShiftLockFlags())
					iRetVal = DoAutomaticReadTotal(p+1);
				else
					iRetVal = DoAutomaticReadTotal(p+1,FALSE);

				if(iRetVal == 0) //in progress 
				{
					// do nothing 
				}
				if(iRetVal == 1) //done 
				{
					bUpdateShiftNumber = TRUE;								
					if(LOG_BASIC_FLOW_CONTROL)
					{	
						CString str;
						str.Format("Total Read done !"); 
						m_cLogger.LogMsg(p+1,LOG_PUMP,str);
					}
				}

				if(iRetVal == 2) //cant start 
				{
					long lTmpLockResExt = m_cServerInfo.GetServerReservation();
					if (!bForeCourtCloseByMaintenence)   //4.0.7.506
					{
						DoAutomaticPumpLock(p+1,lTmpLockResExt);
					}
					else if (bForeCourtCloseByMaintenence)
					{
						if(LOG_BASIC_FLOW_CONTROL)
						{	
							CString str;
							str.Format("Server detect conflict between Server info Maintenence to IDLE Pump %02d, Force clear server state !", p+1); 
							m_cLogger.LogMsg(p+1,LOG_PUMP,str);
						}	

						bForeCourtCloseByMaintenence  = FALSE; 
						lTmpLockResExt &= (~MAINTENANCE);
						m_cServerInfo.SetServerReservation(lTmpLockResExt);
						DoAutomaticPumpLock(p+1,lTmpLockResExt);
					}
				}
			}
			else
			{
				if ((m_cServerInfo.GetShiftLockFlags())&& (!bForeCourtCloseByMaintenence))
					if(!DoAutomaticPumpUnLock(p+1))
						bAllPumpsDone = FALSE;
			}
		}
		// Tank Reading ONLY 
		//--------------------------
		else if((!m_cCurrentShift.bDoPumpTotalsReading)&&(m_cCurrentShift.bDoTankReading))
		{
			if(m_cPumpArray[p].GetShiftNumber() != GetActiveShiftNumber())
			{
				bAllPumpsDone  = FALSE;

				if ((m_cServerInfo.GetShiftLockFlags())&& (!bForeCourtCloseByMaintenence)) //3.0.1.86
				{
					if(!DoAutomaticPumpLock(p+1,m_cServerInfo.GetServerReservation()))
						bAllPumpsLocked = FALSE;
					else
						bUpdateShiftNumber = TRUE;															
				}
				else
					bUpdateShiftNumber = TRUE;
			}
		}
		// No Operation required  
		//--------------------------
		else
		{
			bUpdateShiftNumber = TRUE;
		}

		if(bUpdateShiftNumber)
		{
			m_cPumpArray[p].SetShiftNumber( GetActiveShiftNumber());
			SavePumpInfo(p+1);		

			if(LOG_BASIC_FLOW_CONTROL)
			{	
				CString str;
				str.Format("change shift number to %d .", m_cPumpArray[p].GetShiftNumber()); 
				m_cLogger.LogMsg(p+1,LOG_PUMP,str);
			}	
		}
	}

	if(m_cCurrentShift.bDoTankReading)
	{
		if(bAllPumpsLocked)
			SetServerLockStatus(LOCKED);				
	}
	else // Tank Reading not needed 
	{
		if(bAllPumpsDone)
			SetServerLockStatus(RESPONSE_RECEIVED); // go direct to end state.
	}
}

/******************************************************************************
 Description:	Handle state LOCKED in shift change process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		04/08/2011   08:00			Start		4.0.29.0 - TD 241916
******************************************************************************/
void CServerMain::HandleShiftStateLocked()
{
	if (m_bShiftStateUnlockHandled == FALSE) //4.0.29.0 - TD 241916
		HandleShiftStateUnlock();
	else
	{
		m_bTankReadingRcved = FALSE;
		m_bDeliveryReportRcved = FALSE;	
		
		CMD_STRUCT_TANK_READING cmdInfo;
		cmdInfo.lStatus = TANK_STATUS_IDLE;							
		SetCommand(CMD_GET_TANK_READING, SERVER_POS_NUMBER, 0,&cmdInfo,sizeof(CMD_STRUCT_TANK_READING)); // 0 - All tanks.
		SetCommand(CMD_GET_DELIVERY_REPORT, SERVER_POS_NUMBER, 0); // 0 - All deliveries for all tanks
		
		SetServerLockStatus(WAIT_RESPONSE);			
		m_lServerWaitCounter = 0;
		
		if(LOG_BASIC_FLOW_CONTROL)
		{						
			m_cLogger.LogMsg("Send Command : GET_TANK_READING ,GET_DELIVERY_REPORT ");
		}
	
		m_cShiftProcess.CheckStuckTransaction(); //4.0.8.500
	}
}

/******************************************************************************
Description:	Handle state WAIT_RESPONSE in shift change process
Returns:      	
Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		04/08/2011   08:00			Start		4.0.29.0 - TD 241916
******************************************************************************/
void CServerMain::HandleShiftStateWaitResponse()
{
	if((m_bTankReadingRcved)&&(m_bDeliveryReportRcved))
	{
		NewActiveReadNumber();					
		SetServerLockStatus(RESPONSE_RECEIVED);			
	}
	else
	{
		m_lServerWaitCounter++;
		if(m_lServerWaitCounter == 1200) // TimeOut after 2 minute.
		{
			SetServerLockStatus(RESPONSE_RECEIVED);			
			
			if(LOG_DETAIL_FLOW_CONTROL)
			{	
				CString str;
				str.Format("ShiftChangeProcess: Time Out on WAIT_RESPONSE , switch to RESPONSE_RECEIVED");
				m_cLogger.LogMsg(str);
			}
		}
	}
}

/******************************************************************************
 Description:	Handle state RESPONSE_RECEIVED in shift change process
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Ella		04/08/2011   08:00			Start		4.0.29.0 - TD 241916
******************************************************************************/
void CServerMain::HandleShiftStateResponseReceived()
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	if (FALSE == m_cServerInfo.GetRequiredQDXMaintenance())
	{
		//4.0.18.501 - TD 33898
		if ((m_lReloadQDXShiftsCounter == (long)m_dwReloadQDXEveryXShifts) && (m_dwReloadQDXEveryXShifts > 0))	//4.0.18.31 4.0.19.0
		{
			m_lReloadQDXShiftsCounter = 0;
			m_cParam.SaveParam("GeneralParam","ShiftsToMaintenance",(m_dwReloadQDXEveryXShifts - m_lReloadQDXShiftsCounter),FALSE,0,0,0,TRUE);//33898
			m_cServerInfo.SetRequiredQDXMaintenance(TRUE);
		}

		BOOL bForeCourtCloseByMaintenence  = (m_cServerInfo.GetServerReservation() & MAINTENANCE)? TRUE : FALSE;  //3.0.1.84
		BOOL bLockedOnStopAll = m_cServerInfo.GetInStopAllPumps(); //4.0.29.0 - TD 241916

		if(m_cCurrentShift.dwFormalShiftNumber != m_cCurrentShift.dwActiveShiftNumber)					
		{
			m_cCurrentShift.dwFormalShiftNumber = m_cCurrentShift.dwActiveShiftNumber;
			SQLPumpSrvFile.SaveShiftInfo();
						
		}

		if (FALSE == m_cServerInfo.GetRequiredQDXMaintenance())
		{			
			BOOL bAllPumpsUnLocked = TRUE;

			if ((m_cServerInfo.GetShiftLockFlags()) && (!bForeCourtCloseByMaintenence) && (!bLockedOnStopAll))  //3.0.1.84 //4.0.29.0 - TD 241916
			{
				if(m_cCurrentShift.bDoTankReading)
				{
					for(int p=0;p< m_lLastValidPump;p++)   //4.0.0.79
					{
						if(!DoAutomaticPumpUnLock(p+1))
						{
							bAllPumpsUnLocked = FALSE;
						}
					}
				}
			}				

			///////////////////////////////////////////////////
			///////////// Handle Reconfigure //////////////////
			///////////////////////////////////////////////////
			BOOL bReconfigureProcedureInProgress = DoAutomaticReconfigure(bAllPumpsUnLocked);
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			
			if (bAllPumpsUnLocked && (FALSE == bReconfigureProcedureInProgress))
			{
				m_cServerInfo.SetRequiredShiftProcessFlags(FALSE);
				m_cServerInfo.SetServerReservation(0);

				if (!bForeCourtCloseByMaintenence && !bLockedOnStopAll) //4.0.29.0 - TD 241916
					SetServerLockStatus(UNLOCK);
				else if (bLockedOnStopAll) //4.0.29.0 - TD 241916
					SetServerLockStatus(LOCKED);
				else
				{
					m_cServerInfo.SetServerReservation(MAINTENANCE);
					SetServerLockStatus(LOCKED);
				}

				//4.0.5550.1504
				if (m_cCurrentShift.bDataBaseMaintenance)
				{
					m_cServerInfo.SetServerReservation(DATABASE_MAINTENANCE);
				}

				SQLPumpSrvFile.SaveServerInfo();

				//4.0.25.50 - TD 108311
				//Reset Single Shift Accumulation data
				if (GetSingleShiftAccumulationsActive())
					m_cSingleShiftAccumMgr.ResetAllRecordsInDB();
				
				//Add by Yaron for Ctrl Events
				m_cEventManager.AddEvent(CTRL_EVENT_SHIFT_ENDED,0);
				
				SetCommand(CMD_GENERAL_SYSTEM_EVENT,0,GCI_EVENT_SHIFT_END);
											
				m_cParam.SaveParam("GeneralParam","PrevShiftLastTrsNum",m_dwTransactNumber,TRUE,TRUE,0,0,TRUE);	//4.0.20.52

				m_bShiftStateUnlockHandled = FALSE; //RFUEL-2859

				//amram 4.0.10.504 
				//after the shift change we have to set the flag that used in lock shift 
				DWORD dwTmp = 0;
				m_cCurrentShift.bLockShiftDuringProcess = '0';

				if(LOG_TRS_FILE)
					m_cTrsLog.LogShift(m_cCurrentShift.dwFormalShiftNumber-1);

				// 4.0.3.50
				if (m_cCurrentShift.bLockPumpAtEndShift || m_cCurrentShift.bDataBaseMaintenance) //4.0.5550.1504 
				{					
					CString str("Do Automatic Pump Lock After shift");
					m_cServerInfo.SetRequiredMaintenanceProcessFlags(TRUE);
					
					if (m_cServerInfo.GetServerReservation() & DATABASE_MAINTENANCE)						//4.0.18.504
						m_cServerInfo.SetRequiredMaintenanceProcessFlags(MP_DB_MAINTENANCE_LOCK);

					SetServerLockStatus(IGNORE_LOCK_STATUS);

					m_cLogger.LogMsg(str);
				}
			}

			// lock station after shift if require
			if (bForeCourtCloseByMaintenence)
			{					
				CString str("ForeCourte lock Do nothing !!!");
				m_cLogger.LogMsg(str);
			}

			 if (ACCUMULATE_SHIFT_TOTAL)
				m_cAccumulationShiftTotal.ClearShiftdata(m_cCurrentShift.dwActiveShiftNumber);
		}
		else
		{
			//////////////////////////////////////////////////
			// Start QDX maintenance process
			//CString str("Start QDX maintenance!");
			//m_cLogger.LogMsg(str);
			//m_cAlarm.AddSendMessage(CATEGORY_SOFTWARE, SUB_PUMPSRV, NEXT_SHIFT_INCLUDES_RELOAD, 0, ALARM_ENDED, 0, 0);	//4.0.19.0
			//if (!m_cQDXMaintThread.StartQDXMaintThread())
			//{
			//	CString str("CServerMain::ShiftChangeProcess - QDX Maintenance started successfully!");
			//	m_cLogger.LogMsg(str);
			//}
		}
	}
}


//4.0.29.500 TD 277379
BOOL CServerMain::IfExistTrsByControllerSeqNum(long lPumpNumber, long lFlags , long lControllerSeqNum, long lTrsNumber)
{
	BOOL bRetVal = FALSE;
	BOOL bDuplicated = FALSE;
	CPumpTransact trs;	
	int iArraySize = m_cPumpArray[lPumpNumber-1].GetTrsArraySize();
	
	if(iArraySize)
	{
		for (int iTrs=0; iTrs < iArraySize; iTrs++)
		{
			m_cPumpArray[lPumpNumber-1].GetTrsByIndex(iTrs,&trs);
			
			if(trs.m_lControllerSeqNum == lControllerSeqNum) 	// TD 303934 4.0.22.831
			{
				bDuplicated = TRUE;
				
                if(lFlags & PAK_CHECK_DUBLICATE_BY_TRS_NUMBER)  //4.0.25.480 TD 277030
				{
                    if(0 != lTrsNumber && trs.m_lNumber != lTrsNumber) //4.0.25.700 merge from 1022 TD 317020: Second transaction number in PakReadyTrs was zero, no duplication block in this case
						bDuplicated = FALSE;
				}
			}
			if (bDuplicated)
			{
				bRetVal = TRUE;
				
				if (trs.m_lControllerSeqNum == 0) 
				{
					bRetVal = (trs.GetStatus() == UNPAID) || (trs.GetStatus() == PAID);
				}
				break;
			}	
		}
	}	
	return bRetVal;
}




//4.0.29.500 TD 277379
BOOL  CServerMain::IsPakTransZero(long lVolume,long lValue, long lFlags)
{
	BOOL bRetCode = FALSE;
	if ( (lVolume == 0) && (lValue == 0) && (!(lFlags  & PAK_INCLUDE_IGNORE_VALUE_VOLUME_CHECK))) //4.0.10.591 4.0.10.240 4.0.10.1000
	{
		m_cLogger.LogMsg("PAKTransaction with Zero Value and Volume - Ignored.");
		bRetCode  = TRUE;
	}
	
	return bRetCode;
}


//4.0.29.500 TD 277379
BOOL  CServerMain::IsPakTransDuplControllerSeqNum(long lPumpNumber, long lFlags, long lControllerSeqNum, long lTrsNumber)
{
    BOOL bFoundDuplicate = FALSE; 
	if (lFlags & PAK_INCLUDE_CONTROLLER_TRS_NUMBER)
	{
       	bFoundDuplicate = IfExistTrsByControllerSeqNum(lPumpNumber, lFlags ,lControllerSeqNum,lTrsNumber);
	}
	
    if (bFoundDuplicate)
	{
		m_cLogger.LogMsg("PAKTransaction with duplicate ControllerSeqNum - Ignored.");
	}
	
	return bFoundDuplicate;	
}


void CServerMain::CreateFuelMobileSrvThread()
{
	if (m_dwFuelMobileSrvInUse)
	{
		if (m_cFuelMobileSrvThread.Init() == THREAD_OK)
			m_cFuelMobileSrvThread.StartThread();
	}
	
}
void CServerMain::FuelMobileSrvThreadCleanUp()
{
	if (m_dwFuelMobileSrvInUse)
	{
		m_cFuelMobileSrvThread.CleanUp();
	}
}


//4.0.29.500 TD 277379
GCIRetCode  CServerMain::CheckPakReadyTransaction(long lPumpNumber, long lVolume,long lValue, long lFlags, long lTotalVal, long lTrsNumber)
{
	GCIRetCode retCode = GCI_OK;
	
	if (IsPakTransZero(lVolume, lValue, lFlags))
	{
		retCode = GCI_INVALID_VALUES;
	}
	
	
    if (retCode == GCI_OK) 
	{
        if (IsPakTransDuplControllerSeqNum(lPumpNumber, lFlags, lTotalVal, lTrsNumber))
		{
			retCode = GCI_TRS_DUPLICATE_UPDATE;
		}
	}
	
	return retCode;	
}

// 4.0.29.501 TD 288369
BOOL CServerMain::GetQdxIsFail()
{
	return m_bQdxIsGone;
}

// 4.0.29.501 TD 288369
void CServerMain::SetQdxIsGone(BOOL bQdxIsGone)
{
	m_bQdxIsGone = bQdxIsGone;
}

/******************************************************************************
 Description:	Sets Site Limit to AuthorizeAndLimit command

 Returns:      	void 
 Parameters:    long lPumpNumber, long lSyncNumber, long lFlags, BSTR *pRec, long *pVal
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			21/03/2012   14:00		Start	   4.0.22.850  TD 307758
******************************************************************************/
void CServerMain::SetSiteLimit(long p , short nLevel , CMD_STRUCT_AUTHORIZE_LIMIT & cmdAuthorize)
{
	if ( IsSiteLimitByVolume())
	{
		cmdAuthorize.lMaxValue =  0; 
		cmdAuthorize.lMaxVolume =  GetStationLimitVolume();
		cmdAuthorize.lFlags |= LIMIT_BY_VOLUME;
	}
	else
	{
		cmdAuthorize.lMaxValue = GetLimit(nLevel,p+1);
		cmdAuthorize.lMaxVolume = 0;
	}
}

/******************************************************************************
 Description: return the value of m_dwIndicateAuthorizePumpSent
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Shuki Y		17/06/2012   17:10		Start		4.0.30.500	TD 320068
******************************************************************************/
DWORD CServerMain::GetIndicateAuthorizePumpSentFlag()
{
	return m_dwIndicateAuthorizePumpSent;
}



/******************************************************************************
Description: Search for trs with status IN_PROGRESS/WAIT_PROGRESS
			 If m_dwRemoveStuckTrs is on, change the status of the trs to PAID 
			 

 WHO			WHEN                    WHAT
---------------------------------------------------------------------------------
 OmerT			22/07/2012				 // 4.0.24.770  TD 275612
******************************************************************************/
BOOL CServerMain::SearchForStuckTrs(long lPumpNumber)
{
	CPumpTransact cTrs;
	BOOL bFoundTrs = TRUE;
	if(IsRemoveStuckTrsConfigured())
	{
		while(bFoundTrs)
		{
			bFoundTrs = !(m_cPumpArray[lPumpNumber-1].GetInProgressWaitProgressTrs(&cTrs));
			if(bFoundTrs) // found
			{
				// set the status to paid
				cTrs.SetStatus(PAID);
				CentralUpdateTrs(lPumpNumber,cTrs.m_lNumber,&cTrs,FALSE);

				if (cTrs.m_nLinkFlags & TRS_LINK_CASH_ACCEPTOR_INFO) //342701 4.0.124.810
				{
					long lRtc = GCI_OK;
					PRE_PAY_INFO	cTmpPrePayinfo;
					CPumpTransact	cTempTrs = cTrs;
					lRtc = TrsLinkOperation(REC_READ,&cTempTrs,&cTmpPrePayinfo);
					if (!lRtc)	
					{
						lRtc = TrsLinkOperation(REC_UPDATE,&cTrs,&cTmpPrePayinfo);
						if (!lRtc)
						{
							EXTRA_INFO_REC	ExtraInfoRec;

							memset(&ExtraInfoRec , 0 , sizeof(EXTRA_INFO_REC));
							ExtraInfoRec.info.lIndexNumber = cTrs.m_lNumber;	

							long p = lPumpNumber-1; //4.0.21.500 69415
							long lRtc = IndexOperation(EXTRA_INFO_FILE, REC_READ, &ExtraInfoRec);

							if (ExtraInfoRec.info.lCashDepositTotal > 0) //4.0.24.280 160508 //4.0.124.310
							{
								m_cPumpArray[p].IncreaseUnBalancePrePayCounter(); //The number of unbalanced is increased in setPumpStatus
								if(LOG_BASIC_FLOW_CONTROL)
								{	
									CString str;
									str.Format("SearchForStuckTrs, trs %ld was closed as unbalanced",cTrs.m_lNumber);
									_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
								}
							}
							else
							{
								if(LOG_BASIC_FLOW_CONTROL)
								{	
									CString str;
									str.Format("SearchForStuckTrs, trs %ld was closed as 0 deposit",cTrs.m_lNumber);
									_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,str);
								}

							}
						}
					}
				}
				// log to PumpSrv's log
				CString sMsg;
				sMsg.Format("CGCI::SetCashAcceptorData Trs = %d was set to Paid!",cTrs.m_lNumber);
				_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,sMsg);

				// log the trs into the stuck trs log
				m_cStuckTrsLog.LogTrs(&cTrs);
			}
		}
	}
	else
	{
		bFoundTrs = !(m_cPumpArray[lPumpNumber-1].GetInProgressWaitProgressTrs(&cTrs));
	}

	return bFoundTrs;
}

/******************************************************************************
 Description:	Unlock Pump
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT		  25/12/2012   15:00			Start		TD 348577
******************************************************************************/
void CServerMain::UnlockPump(long p)
{
	if(m_cPumpArray[p].GetStat().GetRes() != PUMPSRV)
	{
		long lMisc = m_cPumpArray[p].GetStat().GetMisc();
		lMisc &= MISC_CLEAR_PROCESS_FLAGS;
		
		m_cPumpArray[p].SetLockStatus(UNLOCK,lMisc);

		//in case pumpsrv fail in middle of process change price & 
		// one of the pump is in reservation for PrePay
		ReleasePumpMessages(p , PUMP_NO_MSG);	

		SavePumpInfo(p+1);
	}
	else
	{	
		m_cPumpArray[p].m_lWaitCounter++;
		if(m_cPumpArray[p].m_lWaitCounter == 300)
		{
			long lMisc = m_cPumpArray[p].GetStat().GetMisc();
			lMisc |= MISC_WAIT_RESPONSE_TIMEOUT;
			
			m_cPumpArray[p].SetLockStatus(LOCKED,lMisc);							
			SavePumpInfo(p+1);
			
			SetCommand(CMD_GET_PUMP_STATUS, SERVER_POS_NUMBER, p+1);
			
			if(LOG_DETAIL_FLOW_CONTROL)
			{	
				CString str;
				str.Format("DoAutomaticPumpUnLock: Time Out on WAIT_RESPONSE , return to LOCKED");
				m_cLogger.LogMsg(p+1,LOG_PUMP,str);
			}
		}
	}
}


/******************************************************************************
 Description: Returns True the the pump is connected to the tank
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			31/12/2012   15:00			Start		TD 353515
******************************************************************************/
BOOL CServerMain::IsPumpConnctedToTank(long lTankNumber,int p)
{			
	long lTankConnectedPumpsMap = 0;

	if (p < MAX_PUMPS) 
		lTankConnectedPumpsMap = m_cTankArray[lTankNumber].GetPumpsLinkedMap1();
	else
		lTankConnectedPumpsMap = m_cTankArray[lTankNumber].GetPumpsLinkedMap2();	

	if (lTankConnectedPumpsMap & (1<<p))
			return TRUE;

	return FALSE;
}

/******************************************************************************
 Description: Locks/Unlock the pumps that connected to the tank, returns TRUE
			  If all pump were locked/Unlockd	
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			31/12/2012   15:00			Start		TD 353515
******************************************************************************/
BOOL CServerMain::SetPumpsLockState(long lTankNumber,BOOL bLock)
{
	LockPumpByTankStatus eLockStauts = (bLock ? PTL_START_LOCK : PTL_START_UNLOCK);
	SingleTankLockStatus eSingleTankLockStatus = (bLock ? SINGLE_TANK_WAIT_LOCK : SINGLE_TANK_WAIT_UNLOCK);

	for (int p = 0; p < m_lLastValidPump; p++)
	{			
		if (IsPumpConnctedToTank(lTankNumber,p) && FALSE == m_cSinglePumpLock.IsExclusivelyLocked(p+1)) //4.0.19.430 
		{				
			if(bLock)
			{
				if(FALSE == IsPumpLockedByTank(p+1)) 
					SetLockPumpByTankStatus(p+1,eLockStauts);
			}
			else
			{
				if(m_cPumpsLockbyTankStateArray[p].IsLocked())
					SetLockPumpByTankStatus(p+1,eLockStauts);
			}

			if(DoAutomaticLockPumpByTank(p+1) != bLock)
			{		
				//Not all the pumps are locked! - remain tank in this state
				if(m_cServerInfo.GetSingleTankLockStatus(lTankNumber+1) != eSingleTankLockStatus) 
					m_cServerInfo.SetSingleTankLockStatus(lTankNumber+1,eSingleTankLockStatus);

				return FALSE;
			}															
		}						
	}		
	return TRUE;
}


void CServerMain::PriceChangeNoChangeEvent()
{
	DWORD dwTmp = 0;

	if (LOG_DETAIL_FLOW_CONTROL)
	{
		CString sMsg;
		sMsg.Format("Price no change event");
		m_cLogger.LogMsg(sMsg);
	}

	SetInPriceChangeProcess(FALSE); //4.0.12.518


	m_cParam.LoadParam("GeneralParam", "PriceChangeBatchNumber", &dwTmp, (DWORD)0, FALSE, FALSE, 0, HOP_DIRECT_LOCAL, TRUE);
	m_cAlarm.AddSendMessage(CATEGORY_PUMP, SUB_PRICE_CHANGE, PRICE_CHANGE_NO_CHANGE, GetPriceChangeResponseDeviceNum(), ALARM_STARTED, (long)dwTmp, 0);

	//Reset the device num of the success price change
	SetPriceChangeResponseDeviceNum(0);
}


// TD 332389
void CServerMain::UnMaskAccountNumber(long lPumpNumber ,PAY_AT_PUMP_INFO * pInfo)
{
	if((pInfo->CardSaleExtraData3.sMaskAccountNumber == 'N'))
	{
		memcpy(pInfo->CardSaleInfo.cardData.sAccountNumber,
			pInfo->CardSaleExtraData2.sFormattedAccount,
			min(sizeof(pInfo->CardSaleInfo.cardData.sAccountNumber),sizeof(pInfo->CardSaleExtraData2.sFormattedAccount)));


		memset(pInfo->CardSaleExtraData2.sParam2 , ' ' , sizeof(pInfo->CardSaleExtraData2.sParam2 ));
		ChangeNullChar2Char((char *)pInfo->CardSaleInfo.cardData.sAccountNumber,sizeof(pInfo->CardSaleInfo.cardData.sAccountNumber));

		if(LOG_DETAIL_FLOW_CONTROL)
			_LOGMSG.LogMsg("CServerMain","UnMaskAccountNumberOnSessionComplete",0,LOG_NONE,"Unmasking the accountNumber!");
	} 
}

// TD 327153
BOOL CServerMain::CheckTripleAFlow( long lPumpNumber ,long lMediaMasterType)
{	
	PAY_AT_PUMP_INFO cInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cInfo);

	if(lMediaMasterType == CARD_TYPE_TRIPLE_A)
	{
		memcpy(cInfo.CardSaleExtraData4.sFormattedClubCardNumber,cInfo.CardSaleInfo.extraData.sLoyalId,sizeof(cInfo.CardSaleExtraData4.sFormattedClubCardNumber));
		memset(cInfo.CardSaleInfo.extraData.sLoyalId, ' ',sizeof(cInfo.CardSaleInfo.extraData.sLoyalId));
		m_cPumpArray[lPumpNumber-1].SetPAPInfo(&cInfo);
		return TRUE;
	}

	return FALSE;
}


// TD 356872
BOOL CServerMain::IsAfterOrInTheMiddleCancel( OLA_STAT * pOla )
{
	return (pOla->m_byState == OLA_NONE || pOla->m_byState == OLA_LOYALTY_CANCEL_TICKET_AFTER_START_TICKET ||SESSION_TYPE(pOla->m_byState) == SESSION_COMPLETE);
}

void CServerMain::OpenNeedMoreParam(PAY_AT_PUMP_INFO & cTmpInfo, long lPumpNumber, CString sMsg, int iMaxNumOfOpenKeys, long lTimeOut, short nONMPProperties, long lScreenId,PromptType ePromptType )
{
	memset(cTmpInfo.CardSaleInfo.cardData.sResultMsg, ' ', sizeof cTmpInfo.CardSaleInfo.cardData.sResultMsg); // RFUEL 1146

	// copy the message
	memcpy(cTmpInfo.CardSaleInfo.cardData.sResultMsg, sMsg.GetBuffer(0),min( sizeof(cTmpInfo.CardSaleInfo.cardData.sResultMsg), sMsg.GetLength())); //4.0.20.40 

	// copy the timeout
	l2a(lTimeOut, cTmpInfo.CardSaleExtraData2.sMessageTimeOut, sizeof(cTmpInfo.CardSaleExtraData2.sMessageTimeOut));

	// Set General Properties
	l2a(nONMPProperties, cTmpInfo.CardSaleExtraData4.sONMPProperties, sizeof(cTmpInfo.CardSaleExtraData4.sONMPProperties));

	// Set the prompt type
	l2a(ePromptType, cTmpInfo.CardSaleExtraData3.sPromptType, sizeof(cTmpInfo.CardSaleExtraData3.sPromptType));

	// Set minimum prompt length
	cTmpInfo.CardSaleExtraData3.sPromptMinLen[0] = '1';

	// Set maximum prompt length
	l2a(iMaxNumOfOpenKeys, cTmpInfo.CardSaleExtraData3.sPromptMaxLen, sizeof(cTmpInfo.CardSaleExtraData3.sPromptMaxLen));


	memset(cTmpInfo.CardSaleExtraData3.sParamResult, ' ', sizeof(cTmpInfo.CardSaleExtraData3.sParamResult));  //4.0.23.1890

	// set open need more param
	cTmpInfo.CardSaleExtraData3.sParamResult[0] = '?';

	// set screen number
	if(lScreenId > 0)
		l2a(lScreenId, cTmpInfo.CardSaleExtraData5.sScreenMsgNumber, sizeof(cTmpInfo.CardSaleExtraData5.sScreenMsgNumber));

	// set the information into pump array
	m_cPumpArray[lPumpNumber - 1].SetPAPInfo(&cTmpInfo);

	CMD_STRUCT_PAP_SWIPE_RESULT3_EX cmdInfo;
	_Module.m_server.SetSwipeResultDataToCommand(cmdInfo, cTmpInfo, CD_MORE_DATA_REQUIRED);
	SetCommand(CMD_SWIPE_RESULT, SERVER_POS_NUMBER, lPumpNumber, &cmdInfo, sizeof(CMD_STRUCT_PAP_SWIPE_RESULT3_EX));

}


GPIRetCode CServerMain::IsPostVoidTrsAllowed(long lPumpNumber ,short nUnpaid) //CR 351687: Coles Enhanced post void transaction
{
	long p =		lPumpNumber-1;
	CString			sMsg;
	GPIRetCode		lRetCode = GPI_OK;
	if( MAX_ALLOWED_POST_VOID_TRS(p) == 0)
	{	
		// post void are included in post pay
		if(nUnpaid >= MAX_ALLOWED_UNPAID_TRS(p) + SLOT_SAVED_FOR_POST_VOID_TRS) // 4.0.27.230
		{
			lRetCode = GPI_PUMP_TRS_LIST_FULL;
		}
	}
	
	if ((lRetCode == GPI_OK) && (m_cPumpArray[p].GetPostVoidTrsCount() >= MAX_ALLOWED_POST_VOID_TRS(p))) //CR 351687: Enhanced post void transactions
	{
		// post void counter is stand alone
		lRetCode = GPI_PUMP_POST_VOID_TRS_LIST_FULL;	
	}	
	
	return lRetCode;
}


// 4.0.23.1960  TD 378403
void CServerMain::SortGradeLimitArrayByPosition(long lPumpNumber ,TAG_DISCOUNT_LOYALTY_INFO4 * pRec)
{
	CString str;
	BYTE byNozzle;
	
	GRADE_LIMITS sTmpGradeLimitsArray[8]; //4.0.23.270 111746
	memset (sTmpGradeLimitsArray, ' ', sizeof(sTmpGradeLimitsArray));
	
	for (int i = 0; i<MAX_POSITIONS_PER_PUMP; i++)
	{
		int iGradeID = a2l(pRec->GradeAmountLimit[i].sGradeID, sizeof(pRec->GradeAmountLimit[i].sGradeID)); // TD 378403
		if (iGradeID > 0)
		{
			long lPosition = 0;   //4.0.23.723
			byNozzle = m_cPumpArray[lPumpNumber-1].GetGradePosition(iGradeID, &lPosition);
			if ((byNozzle > 0) && (byNozzle < MAX_POSITIONS_PER_PUMP))
			{
				memcpy(sTmpGradeLimitsArray[byNozzle - 1].sGradeID, pRec->GradeAmountLimit[i].sGradeID, sizeof(sTmpGradeLimitsArray[byNozzle - 1].sGradeID));
				memcpy(sTmpGradeLimitsArray[byNozzle - 1].sGradeAmountLimit, pRec->GradeAmountLimit[i].sGradeAmountLimit, sizeof(sTmpGradeLimitsArray[byNozzle - 1].sGradeAmountLimit));
				memcpy(&sTmpGradeLimitsArray[byNozzle - 1].sLimitType, &pRec->GradeAmountLimit[i].sLimitType, sizeof(sTmpGradeLimitsArray[byNozzle - 1].sLimitType));
				
				str.Format("Found grade limit grade = %.02s, nozzle = %.01s AmountLimit = %.09s, LimitType = %.01s", sTmpGradeLimitsArray[byNozzle - 1].sGradeID,
																													 byNozzle,sTmpGradeLimitsArray[byNozzle - 1].sGradeAmountLimit,
																													 sTmpGradeLimitsArray[byNozzle - 1].sLimitType);
				m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
			}
		}		
	}
	
	memcpy(pRec->GradeAmountLimit, sTmpGradeLimitsArray, sizeof(pRec->GradeAmountLimit));
}


// TD 357023	4.0.23.1970
BOOL CServerMain::DoCancelInTheMiddleOfAuthorize(PAY_AT_PUMP_INFO * pInfo, OLA_STAT * pOla, long p, CPumpTransact &trs )
{
	if( (pInfo->CardSaleInfo.cardData.sTranStatus == CD_DECLINE_GR) || 
		(pInfo->CardSaleInfo.cardData.sTranStatus == CD_APPROVE_OK) ||
		(pInfo->CardSaleInfo.cardData.sTranStatus == CD_FORCE_COMPLETION_ZERO) ||
		(GetOLAFlags(pInfo->CardSaleExtraData3.sFlags1 ,FL_CANCEL_REC,sizeof(pInfo->CardSaleExtraData3.sFlags1))))    //4.0.8.502 // 3.2.0.64	
	{								
		pOla->m_lSessionNumber = 0; 
		pOla->m_byCheckCount = 0;
		
		long lTmp = a2l(pInfo->CardSaleExtraData3.sFlags1, sizeof(pInfo->CardSaleExtraData3.sFlags1));

		if (lTmp & FL_PAP_LOYALTY_ACCEPTED)    //4.0.23.273?
		{
			if (LOG_BASIC_FLOW_CONTROL)  //4.0.13.202
			{
				CString str;
				str.Format("DoCancelInTheMiddleOfAuthorize  Pump=%ld  complete for pap trs , Loyalty Flags=0x%08x, Payment flags =%d ", 
					p + 1, 
					lTmp & FL_PAP_LOYALTY_ACCEPTED, 
					lTmp & FL_PAP_PAYMENT_ACCEPTED); //4.0.23.1510 326452
				_LOGMSG.LogMsg(str);
			}


			if (FALSE == _Module.m_server.m_cFuelLoayaltyPS.GetInitDllFlag())//we have to init
			{
				_LOGMSG.LogMsg("CGCI", "LoyaltyPapReadyTrs", p + 1, LOG_PUMP, "LoyaltyFuel is not initialized! skipping add item and moving to complete session");
				pOla->m_byState = SESSION_COMPLETE | OLA_REQUEST_TO_SEND;
				//_Module.m_server.m_cPumpArray[p].SetOlaStat(&ola);

				_LOGMSG.LogMsg(p + 1, LOG_PUMP, "LoyaltyEndPapTrs  DoCancelInTheMiddleOfAuthorize");
			}
			else
			{
				pOla->m_byState = SESSION_COMPLETE | OLA_LOYALTY_WAIT_RESPONSE;
				//	_Module.m_server.m_cPumpArray[p].SetOlaStat(&ola);
				_Module.m_server.m_cFuelLoayaltyPS.SetTotalDiscount(p, 0);//Liat LPE - initialize total discount
				_Module.m_server.m_cFuelLoayaltyPS.SetPrintReceipt(p, TRUE);//TBD - Liat LPE - initialize According to user's choose 
				_Module.m_server.m_cFuelLoayaltyPS.AddItem(p + 1, trs.m_lNumber, *pOla);//4.0.9.508
			}
		}
		else
		{
			pOla->m_byState = OLA_REQUEST_TO_SEND | SESSION_COMPLETE;
		}
		
		if(LOG_BASIC_FLOW_CONTROL)
			m_cLogger.LogOLAMsg(p+1, pOla->m_byState, pOla->m_lSessionNumber);
		m_cPumpArray[p].SetOlaStat(pOla); 
		
		if (SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)
			m_cInitDebitHandler.SetStatus(p + 1, DEBIT_SERVER_IDLE) ; //4.0.3.58
		
		return TRUE;
	}
	else
	{
		// we are here as a result of timeout in Authorization wait for response,
		// and after we send PAPSwipeResult we got an immediate response of PAPReadyTrs(0,0)
		// which change the session type to be SESSION_CANCEL_AUTH, this is not GR case, hance
		// we do not have to send complete
		
		//failed on card authorization 
		trs.SetLink(TRS_LINK_OLA_NUMBER, m_cPumpArray[p].GetPAPSeqNumber());					
		
		if(!m_cPumpArray[p].GetTrsByLinkNumber(&trs))					
		{	
			if(PUMPSRV_IS_MASTER)
			{
				if (trs.m_lResExt != RES_EXT_ATTENDANT)   //4.0.0.77
				{
					if (OLAByController() != 2)  ////4.0.23.800
					{
						m_cShiftLog.LogTrs(&trs, TRUE,FALSE);
						m_cPumpArray[p].ClearTrs(trs.m_lNumber);
					}
				}
			}
		}
		
		m_cPumpArray[p].ClearOlaStat();	
		
		if (SESSION_TYPE(pOla->m_byState) == SESSION_INIT_DEBIT)
			m_cInitDebitHandler.SetStatus(p+1,DEBIT_SERVER_IDLE) ; //4.0.3.58
		
		return FALSE;
	}
}


//TD 378454 
void CServerMain::FillInPromotionsArrayByPumpNum( long lPumpNumber )
{
	PumpItems	cPumpItemsGrades;
	cPumpItemsGrades.lCounter = 0;
	m_cOLASrv->GetProductForSinglePump(lPumpNumber,cPumpItemsGrades);
	m_cFuelLoayaltyPS.FillInPromotionsArray(&cPumpItemsGrades, lPumpNumber);
}

void CServerMain::CancelLoyaltyTrs(long lPumpNumber, OLA_STAT * pOla, PAY_AT_PUMP_INFO * pTmpInfo, BOOL bSendSwipeResult/* = TRUE */)
{
	_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, "Cancel trs was selected by the user");

	m_cFuelLoayaltyPS.CancelTicket(lPumpNumber);

	pOla->m_byState = OLA_NONE;

	if (bSendSwipeResult)
		m_cFuelLoayaltyPS.CancelLoyaltyTrs(*pTmpInfo, lPumpNumber, *pOla);
}


/******************************************************************************
 Description:	Gets the item price according to the configured service mode

 Returns:      	

 Parameters:   	
 
 WHO			WHEN                    WHAT
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Omer			17/10/2011	 19:34		Start 4.0.23.1052 TD 270145
******************************************************************************/
long CServerMain::GetItemPrice(long lPumpNumber , PumpItems * pInfo , int iItem)
{
	long lUnitPrice = 0;

	long lServiceMode = m_cPumpArray[lPumpNumber-1].GetModeService();	//the default is self service = 0

	if (lServiceMode == 0)	//SelfService
		lUnitPrice = pInfo->m_cItemSoldInfo[iItem].lPriceCreditSelfService;
	else
		lUnitPrice = pInfo->m_cItemSoldInfo[iItem].lPriceCreditFullService;
	
	return lUnitPrice;
}


/******************************************************************************
 Description: Return grade the fits the nacs code
 Parameters:    pPumpItem -   Hold all the grade,nace codes

  WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Amram			17/5/2005   15:38		Start
******************************************************************************/

long CServerMain::GetGradeCodeByNacsCode(PumpItems & pPumpItem,long lNacsCode)
{
	int i = 0;
	long lGradeCode = 0;

	while(i<pPumpItem.lCounter)
	{
		if(pPumpItem.m_cItemSoldInfo[i].lNACSCode == lNacsCode)
		{
			lGradeCode = pPumpItem.m_cItemSoldInfo[i].lGrade;
			break;
		}
		i++;
	}

	return lGradeCode;
}

/******************************************************************************
 Description:	Clear PapToPak Flag	
 Returns:      	
 Parameters:   	long lPumpNumber, 
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			13/10/2013   16:32		Start 4.0.23.2060 TD 381449
******************************************************************************/
void CServerMain::ClearPapToPakFlag(long lPumpNumber) // 4.0.23.2060 TD 381449
{
	CSQLPumpSrvFile & SQLPumpSrvFile = CSQLPumpSrvFile::GetInstance();

	if (m_cPumpArray[lPumpNumber - 1].IsPapToPakTrs())
	{
		m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, "Clearing PapToPak flag!");

		m_cPumpArray[lPumpNumber - 1].ClearPapToPakFlag();
		SQLPumpSrvFile.SavePAPInfo(lPumpNumber, __FUNCTION__, __LINE__);
	}
}


/******************************************************************************
 Description:    Check for timeout on events from LoyaltyFuel		
 Returns:      	
 Parameters:   
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			4/11/2013   			4.0.23.2100	
******************************************************************************/
void CServerMain::DoAutomaticLoyaltyTimeout__(long lPumpNumber, OLA_STAT *pOla)
{
	CString sMsg;
	long p = lPumpNumber - 1;
	long lTimeOutCode;
	CTime cStartTime; 
	m_cFuelLoayaltyPS.GetTimer(p,lTimeOutCode,cStartTime);
	
	if(lTimeOutCode > 0)
	{
		CTime cCurTime = CTime::GetCurrentTime();
		CTimeSpan cTimeSpan = cCurTime - cStartTime;
		CString sTimeoutCode = m_cFuelLoayaltyPS.GetStringTimeoutCode(lTimeOutCode);

		long lTimeForExpire = 0;
		if(lTimeOutCode == START_TICKET_CHECK_TIMEOUT || lTimeOutCode == ADD_MEMBER_CARD_CHECK_TIMEOUT || lTimeOutCode == ADD_ADD_MEMBER_INFO_CHECK_TIMEOUT || lTimeOutCode == ADD_CARWASH_ITEM_CHECK_TIMEOUT)
			lTimeForExpire = LOYALTY_START_TRS_TIMEOUT;	
		else if(lTimeOutCode == QUERY_CHECK_TIMEOUT) // TD 406362  4.0.23.2390
			lTimeForExpire = LOYALTY_QUERY_TIMEOUT;
		else if(lTimeOutCode == ADD_ITEM_CHECK_TIMEOUT || lTimeOutCode == END_TICKET_CHECK_TIMEOUT)
			lTimeForExpire = GetLoyaltyTransactionCompleteTimeout();
			
		if(cTimeSpan.GetTotalSeconds() > lTimeForExpire)
			LoyaltyFlowAfterTimeout(sTimeoutCode, lPumpNumber, lTimeOutCode, pOla);
		else
		{
			sMsg.Format("Waiting for %s response, %ld seconds have passed",sTimeoutCode,cTimeSpan.GetTotalSeconds());
			m_cLogger.LogMsg("CServerMain","CheckLoyaltyStartTrsTimeout",lPumpNumber,LOG_PUMP,sMsg);
		}
	}
}

// 4.0.23.2100
void CServerMain::LoyaltyFlowAfterTimeout( CString sTimeoutCode, long lPumpNumber, long lTimeOutCode, OLA_STAT * pOla )
{
	CString sMsg;
	long p = lPumpNumber-1;

	sMsg.Format("loyalty timeout on %s!",sTimeoutCode);
	m_cLogger.LogMsg("CServerMain","LoyaltyFlowAfterTimeout",lPumpNumber,LOG_PUMP,sMsg);
	
	if(lTimeOutCode == START_TICKET_CHECK_TIMEOUT)
	{
		CBaseFlow *pFlow = m_cFlowControlManager.GetPumpFlow(lPumpNumber);
		if (pFlow)		
			pFlow->StartTicketFail(lPumpNumber, pOla);
	}
	else if(lTimeOutCode == ADD_MEMBER_CARD_CHECK_TIMEOUT ) 
	{
		m_cFuelLoayaltyPS.HandleAddMemberCardResult(lPumpNumber,pOla,LOYALTY_STATE_LOYALTY_SERVER_DOWN);
	}
	else if (lTimeOutCode == ADD_ADD_MEMBER_INFO_CHECK_TIMEOUT)
	{
		m_cFuelLoayaltyPS.HandleGetMemberInfoResult(lPumpNumber, NULL);
	}
	else if(lTimeOutCode == ADD_ITEM_CHECK_TIMEOUT || lTimeOutCode == END_TICKET_CHECK_TIMEOUT)
	{
		m_cFuelLoayaltyPS.CancelTicket(lPumpNumber);
		
		pOla->m_byState = SESSION_COMPLETE | OLA_REQUEST_TO_SEND;
		
		m_cPumpArray[p].SetOlaStat(pOla); 
	}
	else if(lTimeOutCode == QUERY_CHECK_TIMEOUT) // TD 406362  4.0.23.2390
	{
		PAY_AT_PUMP_INFO  cTmpInfo;
		m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cTmpInfo);	
		
		m_cFlowControlManager.StartAfterQueryFlowControl(lPumpNumber, *pOla, cTmpInfo);	
	}
	else if(lTimeOutCode == ADD_CARWASH_ITEM_CHECK_TIMEOUT) // TD 406362  4.0.23.2390
	{
		PAY_AT_PUMP_INFO  cTmpInfo;
		m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cTmpInfo);	

		m_cFlowControlManager.HandleNMPSessions(lPumpNumber, pOla, &cTmpInfo);	
	}
	
	m_cFuelLoayaltyPS.ClearTimer(p);
}


/******************************************************************************
 Description: Unlock the pumps that connected to the tank, returns TRUE
			  If all pump were unlocked
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 Haimk			29/01/2014   15:00			Start		4.0.19.2100   TD 396017
******************************************************************************/
BOOL CServerMain::ClearPumpsConnectedToTankStatus(long lTankNumber)
{
	for (int p = 0; p < m_lLastValidPump; p++)
	{
		if (IsPumpConnctedToTank(lTankNumber,p) && FALSE == m_cSinglePumpLock.IsExclusivelyLocked(p+1) )
		{				
			if(m_cPumpsLockbyTankStateArray[p].IsLocked())			
			{				
				SetLockPumpByTankStatus(p+1,PTL_UNLOCK);
			}														
		}						
	}	
	return TRUE;
}


void CServerMain::AddMemberInfo( long lPumpNumber, OLA_STAT * pOla, long p )
{
	m_cFuelLoayaltyPS.AddMemberInfo(lPumpNumber);
	
	m_cFuelLoayaltyPS.PrintLoyaltyStateToLog(lPumpNumber , pOla->m_byState , OLA_LOYALTY_WAIT_ADD_MEMBER_INFO_RESPONSE);
	
	pOla->m_byState = OLA_NEW_STATE(pOla->m_byState,OLA_LOYALTY_WAIT_ADD_MEMBER_INFO_RESPONSE);
	
	m_cPumpArray[p].SetOlaStat(pOla);
}


long CServerMain::GetInterval(SYSTEMTIME stStartTime)
{
	long lInterval = 3600000L; // 1 hour
	
	SYSTEMTIME	Now;
	GetLocalTime(&Now);
	//If we still at the same second.
	if ((stStartTime.wYear   == Now.wYear)	 &&
		(stStartTime.wMonth  == Now.wMonth)	 &&
		(stStartTime.wDay	  == Now.wDay)	 &&
		(stStartTime.wHour   == Now.wHour)	 &&
		(stStartTime.wMinute == Now.wMinute) &&
		(stStartTime.wSecond == Now.wSecond))
	{
		lInterval = Now.wMilliseconds - stStartTime.wMilliseconds;
	}
	//If we moved to a different second.
	else if ((stStartTime.wYear   == Now.wYear)	&&
		(stStartTime.wMonth  == Now.wMonth)	&&
		(stStartTime.wDay	 == Now.wDay)	&&
		(stStartTime.wHour   == Now.wHour)	&&
		(stStartTime.wMinute == Now.wMinute)&&
		(stStartTime.wSecond != Now.wSecond))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond -stStartTime.wSecond) *  1000);
	}
	//If we moved to the next minute.
	else if ((stStartTime.wYear   == Now.wYear)	&&
		(stStartTime.wMonth  == Now.wMonth) &&
		(stStartTime.wDay	 == Now.wDay)	&&
		(stStartTime.wHour   == Now.wHour)	&&
		(stStartTime.wMinute != Now.wMinute))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond - stStartTime.wSecond) *  1000) + ((Now.wMinute - stStartTime.wMinute) * 60000);
	}
	//If we moved to the next hour.
	else if ((stStartTime.wYear   == Now.wYear)	&&
		(stStartTime.wMonth  == Now.wMonth)	&&
		(stStartTime.wDay	 == Now.wDay)	&&
		(stStartTime.wHour   == Now.wHour-1))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond - stStartTime.wSecond) *  1000) + (((60 - stStartTime.wMinute) + Now.wMinute ) * 60000);
	}
	//If we moved to the next day.
	else if ((stStartTime.wYear   == Now.wYear)					&&
		(stStartTime.wMonth  == Now.wMonth)					&&
		(stStartTime.wDay	 == Now.wDay-1)					&&
		(stStartTime.wHour   == 23) && (Now.wHour   == 0))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond - stStartTime.wSecond) *  1000) + (((60 - stStartTime.wMinute) + Now.wMinute ) * 60000);
	}
	//If we moved to the next month.
	else if ((stStartTime.wYear   == Now.wYear)					&&
		(stStartTime.wMonth  == Now.wMonth-1)				&&
		(stStartTime.wDay    >  28) && (Now.wDay    == 1)	&&
		(stStartTime.wHour   == 23) && (Now.wHour   == 0))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond - stStartTime.wSecond) *  1000) + (((60 - stStartTime.wMinute) + Now.wMinute ) * 60000);
	}
	//If we moved to the next year.(decade, century, millennium ...)
	else if ((stStartTime.wYear   == Now.wYear-1)				&&
		(stStartTime.wMonth  == 12) && (Now.wMonth  == 1)	&&
		(stStartTime.wHour   == 23) && (Now.wHour   == 0)	&&
		(stStartTime.wDay    >  28) && (Now.wDay    == 1)	&&
		(stStartTime.wHour   == 23) && (Now.wHour   == 0))
	{
		lInterval = (Now.wMilliseconds - stStartTime.wMilliseconds) + ((Now.wSecond - stStartTime.wSecond) *  1000) + (((60 - stStartTime.wMinute) + Now.wMinute ) * 60000);
	}
    return lInterval;
}


/******************************************************************************
 Description:	Print Grade Limit Array

 Returns:      	void 
 Parameters:    long lPumpNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			02/01/2014   14:00		Start	  CR 370688
******************************************************************************/
void CServerMain::LoadGradeLimitArrayFromCardData( IN long lPumpNumber , OUT CMD_STRUCT_AUTHORIZE_LIMIT &cmdInfo)
{
	_LOGMSG.LogMsg(lPumpNumber,LOG_PUMP,"Loading GradeLimitArray From CardSaleData");

	PAY_AT_PUMP_INFO cPapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&cPapInfo);

	PrintGradeLimitArray(lPumpNumber,cPapInfo);
	
	memcpy(cmdInfo.GradeAmountLimit, cPapInfo.CardSaleExtraData3.GradeLimitsArray, sizeof(cPapInfo.CardSaleExtraData3.GradeLimitsArray));
	memcpy(cmdInfo.GradeVolumeLimit, cPapInfo.CardSaleExtraData5.GradeLimitsArrayEx, sizeof(cPapInfo.CardSaleExtraData5.GradeLimitsArrayEx));
}


/******************************************************************************
 Description:	Print Grade Limit Array

 Returns:      	void 
 Parameters:    long lPumpNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			02/01/2014   14:00		Start	  CR 370688
******************************************************************************/
long CServerMain::LoadGradeLimitArrayFromExtraInfo( IN CPumpTransact trs, OUT CMD_STRUCT_AUTHORIZE_LIMIT &cmdInfo )
{
	EXTRA_INFO_REC cExtraInfo;
	memset(&cExtraInfo, 0 , sizeof(cExtraInfo));
	cExtraInfo.info.lIndexNumber = trs.m_lNumber;					
	long lRtc = IndexOperation(EXTRA_INFO_FILE , REC_READ, &cExtraInfo);
	
	if(LOG_BASIC_FLOW_CONTROL)
	{	
		CString sMsg;
		sMsg.Format("LoadGradeLimitArrayFromExtraInfo() ", trs);
		m_cLogger.LogMsg(sMsg);
	}
	
	if (!lRtc) 
	{
		cmdInfo.lFlags |= MULTIPLE_VOLUME_AND_AMOUNT_LIMIT;

		for(int i = 0; i < MAX_POSITIONS_PER_PUMP; i++)
		{
			l2a(cExtraInfo.info.GradeAmountLimit[i].lGradeLimit, cmdInfo.GradeAmountLimit[i].sGradeAmountLimit, sizeof(cmdInfo.GradeAmountLimit[i].sGradeAmountLimit));
			memcpy(cmdInfo.GradeAmountLimit[i].sGradeID, cExtraInfo.info.GradeAmountLimit[i].sGradeID, sizeof(cmdInfo.GradeAmountLimit[i].sGradeID));
			cmdInfo.GradeAmountLimit[i].sLimitType = '0';

			l2a(cExtraInfo.info.GradeVolumeLimit[i].lGradeLimit, cmdInfo.GradeVolumeLimit[i].sGradeAmountLimit, sizeof(cmdInfo.GradeVolumeLimit[i].sGradeAmountLimit));
			memcpy(cmdInfo.GradeVolumeLimit[i].sGradeID,cExtraInfo.info.GradeVolumeLimit[i].sGradeID, sizeof(cmdInfo.GradeVolumeLimit[i].sGradeID));
			cmdInfo.GradeVolumeLimit[i].sLimitType = '1';
		}

		for(int i = 0; i < MAX_GRADES; i++)
		{
			cmdInfo.lDiscountArray[i] = cExtraInfo.info.lDiscountArray[i];
		}	
	}

	return lRtc;
}


/******************************************************************************
 Description:	Print Grade Limit Array

 Returns:      	void 
 Parameters:    long lPumpNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			02/01/2014   14:00		Start	  CR 370688
******************************************************************************/
void CServerMain::PrintGradeLimitArray(long lPumpNumber, PAY_AT_PUMP_INFO & cPapInfo)
{
	CString sMsg;
	GRADE_LIMITS * GradeLimitsArray = cPapInfo.CardSaleExtraData3.GradeLimitsArray; 
	GRADE_LIMITS * GradeLimitsArrayEx = cPapInfo.CardSaleExtraData5.GradeLimitsArrayEx; 

	try
	{
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			sMsg.Format("PrintGradeLimitArray() - GradeLimitsArray = %.96s", cPapInfo.CardSaleExtraData3.GradeLimitsArray);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg); 

			sMsg.Format("PrintGradeLimitArray() - GradeLimitsArrayEx = %.96s", cPapInfo.CardSaleExtraData5.GradeLimitsArrayEx);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg); 
		}

		for(int i = 0; i < MAX_POSITIONS_PER_PUMP; i++)
		{
			if(FALSE == ChrAll((char *)GradeLimitsArray[i].sGradeAmountLimit, sizeof(GradeLimitsArray[i].sGradeAmountLimit)))
			{
				sMsg.Format("GradeLimitsArray[%d]: GradeID = %.2s, sGradeAmountLimit = %.9s, limitType = %.1s", i, GradeLimitsArray[i].sGradeID, GradeLimitsArray[i].sGradeAmountLimit, &GradeLimitsArray[i].sLimitType);
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg); 
			}
		}

		for(int i = 0; i < MAX_POSITIONS_PER_PUMP; i++)
		{
			if(FALSE == ChrAll((char *)GradeLimitsArrayEx[i].sGradeAmountLimit, sizeof(GradeLimitsArrayEx[i].sGradeAmountLimit)))
			{
				sMsg.Format("GradeLimitsArrayEx[%d]: GradeID = %.2s, sGradeAmountLimit = %.9s, limitType = %.1s", i,	GradeLimitsArrayEx[i].sGradeID, GradeLimitsArrayEx[i].sGradeAmountLimit, &GradeLimitsArrayEx[i].sLimitType);
				m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sMsg); 
			}
		}
	}
	catch(...)
	{
		m_cLogger.LogMsg("CServerMain::PrintGradeLimitArray ,Unexpected error has happened",LOG_LEVEL_1);
	}
}

void CServerMain::SetGradeLimitsAndDiscounts(IN long lPumpNumber,IN PAY_AT_PUMP_INFO & cPAPInfo, OUT EXTRA_INFO & cExtraInfo)
{
	PrintGradeLimitArray(lPumpNumber, cPAPInfo);

	GRADE_LIMITS * GradeLimitsArray = cPAPInfo.CardSaleExtraData3.GradeLimitsArray;
	GRADE_LIMITS * GradeLimitsArrayEx = cPAPInfo.CardSaleExtraData5.GradeLimitsArrayEx;
	DISCNT		 * DiscountArray = cPAPInfo.CardSaleExtraData2.sDiscountPerGrade;
	
	memset(cExtraInfo.GradeAmountLimit,' ',sizeof(cExtraInfo.GradeVolumeLimit));
	memset(cExtraInfo.GradeVolumeLimit,' ',sizeof(cExtraInfo.GradeVolumeLimit));
	memset(cExtraInfo.lDiscountArray,0,sizeof(cExtraInfo.GradeVolumeLimit));

	for(int i = 0; i < MAX_POSITIONS_PER_PUMP; i++)      //4.0.22.1661
	{
		memcpy(cExtraInfo.GradeAmountLimit[i].sGradeID, GradeLimitsArray[i].sGradeID, sizeof(cExtraInfo.GradeAmountLimit[i].sGradeID));
		cExtraInfo.GradeAmountLimit[i].lGradeLimit = a2l(GradeLimitsArray[i].sGradeAmountLimit,sizeof(GradeLimitsArray[i].sGradeAmountLimit)) * 1000;
		
		memcpy(cExtraInfo.GradeVolumeLimit[i].sGradeID, GradeLimitsArrayEx[i].sGradeID, sizeof(cExtraInfo.GradeVolumeLimit[i].sGradeID));
		cExtraInfo.GradeVolumeLimit[i].lGradeLimit = a2l(GradeLimitsArrayEx[i].sGradeAmountLimit,sizeof(GradeLimitsArrayEx[i].sGradeAmountLimit)) * 100;
	}	
	
	
	for(int i = 0; i < MAX_GRADES; i++)
	{
		if(FALSE == ChrAll((char *)DiscountArray[i].sDiscount, sizeof(DiscountArray[i].sDiscount)))
			cExtraInfo.lDiscountArray[i] = a2l(DiscountArray[i].sDiscount, sizeof(DiscountArray[i].sDiscount));
	}
}

/******************************************************************************
 Description:	Print Grade Limit Array

 Returns:      	void 
 Parameters:    long lPumpNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			02/01/2014   14:00		Start	  CR 370688
******************************************************************************/
BOOL CServerMain::SaveGradeLimitsAndDiscountsArrayToExtraData(IN long lPumpNumber, IN BSTR & bstrInXML , IN OUT CPumpTransact &trs)
{
	BOOL				bRet = TRUE;
	char				sXmlBuff[MAX_XML_BUF_LEN];
	PAY_AT_PUMP_INFO	cPAPInfo;
	TAG_OLA_REC12		cTagOlaRec;	
	long				lBuffSize;
	EXTRA_INFO			cExtraInfo;	
	
	memset(&sXmlBuff,0 ,sizeof(sXmlBuff)); //4.0.22.300 - TD 102900 
	memset(&cTagOlaRec, ' ', sizeof(cTagOlaRec));
	
	lBuffSize = Bstr2Buffer(bstrInXML, sXmlBuff, MAX_XML_BUF_LEN);
	
	if (lBuffSize > 0)
	{
		ConvertXmlToCardSale(sXmlBuff, cTagOlaRec, cPAPInfo);
		
		trs.SetLink(trs.GetLinkFlags() + TRS_LINK_EXTRA_INFO, trs.m_lNumber);
								
		cExtraInfo.lIndexNumber = trs.m_lNumber;

		SetGradeLimitsAndDiscounts(lPumpNumber,cPAPInfo,cExtraInfo);

		long lRtc = IndexOperation(EXTRA_INFO_FILE,REC_INSERT,&cExtraInfo);
		
		if(LOG_DETAIL_FLOW_CONTROL)
		{
			CString sLogMsg; 
			sLogMsg.Format("Insert extra info PrePay record (Trs %d, Status %d, link Number %d, RetCode %ld)",
				trs.m_lNumber,
				trs.m_lStatus,
				trs.m_lLinkNumber , 
				lRtc);
			m_cLogger.LogMsg(lPumpNumber,LOG_PUMP,sLogMsg); 
		}

		return TRUE;
	}

	return FALSE;
}


/******************************************************************************
 Description:	ConvertXmlToCardSale

 Returns:      	void 
 Parameters:    long lPumpNumber
 
 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT			02/01/2014   14:00		Start	  CR 370688
******************************************************************************/
void CServerMain::ConvertXmlToCardSale( char * sXmlBuff, TAG_OLA_REC12 &cTagOlaRec, PAY_AT_PUMP_INFO &cPAPInfo )
{
	m_cXmlConvertorEx.ConvertFromXmlToStruct((char *)sXmlBuff, &cTagOlaRec);

	cPAPInfo.CardSaleInfo.cardData = cTagOlaRec.tagOlaRec11.tagOlaRec10.cardData;
	cPAPInfo.CardSaleInfo.extraData = cTagOlaRec.tagOlaRec11.tagOlaRec10.extraData;
	cPAPInfo.CardSaleExtraData2 = cTagOlaRec.tagOlaRec11.tagOlaRec10.extraData2;
	cPAPInfo.CardSaleExtraData3 = cTagOlaRec.tagOlaRec11.tagOlaRec10.extraData3;
	cPAPInfo.CardSaleExtraData4 = cTagOlaRec.tagOlaRec11.tagOlaRec10.extraData4;
	cPAPInfo.CardSaleExtraData5 = cTagOlaRec.extraData5;
}



BOOL CServerMain::DoAutomaticReconfigure( BOOL bAllPumpsUnLocked )
{
	bool bIsNeedToSendReconfigure = FALSE;
	
	if (bAllPumpsUnLocked)
	{
		// In case Reconfigure in EOS was registered in the Registred, Clear the parameter in the registry 
		// and Register Reconfigre events for all tables
		if (ReconfigureEOSEnabledInRegistry())
		{
			m_cLogger.LogMsg("Info: Reconfigure all Tables (Registry  ReconfigureInEOS Flag Enabled) ");
			
			RegisterEOSReconfigureEventForAllTables();
			SetReconfigureInEOSRegistry(FALSE);
		}
		


		if (IsRegistredReconfigureEvents())
		{
			bIsNeedToSendReconfigure = TRUE;
			HandleReconfigureWhileEOS();
		}
	}
	
	return bIsNeedToSendReconfigure;
}



BOOL CServerMain::ReconfigureEOSEnabledInRegistry ()
{
	DWORD dwTmp = 0;

	m_cParam.LoadParam("GeneralParam", "ReconfigureInEOS",	&dwTmp, (DWORD)0, TRUE);

	return (dwTmp != 0);
}


void CServerMain::SetReconfigureInEOSRegistry (IN BOOL bEnable /*= FALSE*/)
{
	m_cParam.SaveParam("GeneralParam", "ReconfigureInEOS",(DWORD)bEnable);
}


void CServerMain::RegisterEOSReconfigureEventForAllTables ()
{
	long lRetVal = CS_OK;
	CMD_STRUCT_RECONFIGURATION_EVENT cCtrlUnion;
	
	memset((void*)&cCtrlUnion, 0, sizeof(cCtrlUnion));
	
	
	cCtrlUnion.lFlags = 0x01;


	cCtrlUnion.lTableId	= PURE_PRODUCTS_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= TANKS_TABLE;
	cCtrlUnion.lSubTableId = (-1);
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= TAXES_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= GRADES_TABLE;
	cCtrlUnion.lSubTableId = -1;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= MODES_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= SERVICE_FEE_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);


	cCtrlUnion.lTableId	= TERMINALS_TABLE;
	cCtrlUnion.lSubTableId = -1;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= PUMPS_TABLE;
	cCtrlUnion.lSubTableId = -1;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= MESSAGES_TABLE;
	cCtrlUnion.lSubTableId = -1 & (0x3f);
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= RECEIPT_TABLE;
	cCtrlUnion.lSubTableId = 0;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);


	cCtrlUnion.lTableId	= RFS_TABLE;
	cCtrlUnion.lSubTableId = RFS_TABLE_GENERAL | RFS_TABLE_AVI;	//TD 493551;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId = GENERAL_PARAM_TABLE;
	cCtrlUnion.lSubTableId = 0;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);
	
	cCtrlUnion.lTableId	= DATABASE_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	
	cCtrlUnion.lTableId	= CARWASH_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xffff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

	cCtrlUnion.lTableId	= PRICE_POLES_TABLE;
	cCtrlUnion.lSubTableId = (-1) & 0xff;
	cCtrlUnion.lSubTableIdExt = 0;
	RegisterEOSReconfigureEvent(&cCtrlUnion);

}


char * CServerMain::ReconfigureTableIdToString (IN ULONG ulTableId)
{
	switch (ulTableId)
	{
		case CARWASH_TABLE:
		{
			return "CARWASH_TABLE";
		}
		break;
		
		case DATABASE_TABLE:
		{
			return "DATABASE_TABLE";
		}
		break;
		case GRADES_TABLE:
		{
			return "GRADES_TABLE";
		}
		break;
		case IPT_TABLE:
		{
			return "IPT_TABLE";
		}
		break;
		case MESSAGES_TABLE:
		{
			return "MESSAGES_TABLE";
		}
		break;
		case MODES_TABLE:
		{
			return "MODES_TABLE";
		}
		break;
		case PATHS_TABLE:
		{
			return "PATHS_TABLE";
		}
		break;
		case PRICE_POLES_TABLE:
		{
			return "PRICE_POLES_TABLE";
		}
		break;
		case PUMPS_TABLE:
		{
			return "PUMPS_TABLE";
		}
		break;
		case PURE_PRODUCTS_TABLE:
		{
			return "PURE_PRODUCTS_TABLE";
		}
		break;
		case RECEIPT_TABLE:
		{
			return "RECEIPT_TABLE";
		}
		break;
		case RFS_TABLE:
		{
			return "RFS_TABLE";
		}
		break;
		case SCREEN_LAYOUT_TABLE:
		{
			return "SCREEN_LAYOUT_TABLE";
		}
		break;
		case SERVICE_FEE_TABLE:
		{
			return "SERVICE_FEE_TABLE";
		}
		break;
		case SHIFTS_TABLE:
		{
			return "SHIFTS_TABLE";
		}
		break;
		case TANKS_TABLE:
		{
			return "TANKS_TABLE";
		}
		break;
		case TAXES_TABLE:
		{
			return "TAXES_TABLE";
		}
		break;
		case TERMINALS_TABLE:
		{
			return "TERMINALS_TABLE";
		}
		break;
		case WASH_PROGRAMS_TABLE:
		{
			return "WASH_PROGRAMS_TABLE";
		}
		break;
		case ALLIED_TABLE:
		{
			return "ALLIED_TABLE";
		}
		break;
		case GENERAL_PARAM_TABLE:
		{
			return "GENERAL_PARAM_TABLE";
		}
		break;
		case MEGGITT_TABLE:
		{
			return "MEGGITT_TABLE";
		}
		break;
		case DOMS_TABLE:
		{
			return "DOMS_TABLE";
		}
		break;
		case LANGUAGES_TABLE:
		{
			return "LANGUAGES_TABLE";
		}
		break;
		case POSTEC_TABLE:
		{
			return "POSTEC_TABLE";
		}
		break;
	
		default:
		break;
	}

	return "UNKNOWN_TABLE";
}

// 4.0.22.1610	TD 389480
void CServerMain::SetLoyaltyTenderAmount( IN OUT  PAY_AT_PUMP_INFO * pPAPInfo, IN long lTotalTransactionAmount , OUT SALE_EXTRA_DETAILS &cSaleExtraDetails )
{
	//4.0.22.710 - TD 247268
	//Set loyalty tender amount - if fueling amount is lower or equal to loyalty tender amount, then set to 0

	long lTrsLoyaltyTenderAmt = a2l(pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount, sizeof(pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount)); 
	lTrsLoyaltyTenderAmt *= 10; //4.0.22.830 302780

	{	
		CString sMsg;
		sMsg.Format("SetLoyaltyTenderAmount() - lTrsLoyaltyTenderAmt = %ld, lTotalTransactionAmount = %ld", lTrsLoyaltyTenderAmt, lTotalTransactionAmount);
		m_cLogger.LogMsg(sMsg);
	}
	
	if (lTotalTransactionAmount < lTrsLoyaltyTenderAmt) //4.0.22.820 299059 //4.0.22.821 //4.0.22.830 302780
		l2a(0, pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount, sizeof(pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount));

	// otherwise the sLoyaltyTenderAmount will be equal to the original value received from eps.

	memcpy(cSaleExtraDetails.sTransLoyaltyTenderAmount, pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount, sizeof(pPAPInfo->CardSaleExtraData5.sLoyaltyTenderAmount));
}

/******************************************************************************
 Description: return type of measure to the given grade
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    	01/07/2013   18:15		Start		4.0.27.240	TD 363041
******************************************************************************/
BYTE CServerMain::GetTypeOfMeasure(short nGrade) const // TD 363041
{
	if(nGrade < 0 || nGrade >= MAX_GRADES_99)
		return '0';
	if(m_GradesRegistryData[nGrade-1].m_bTypeOfMeasure)
		return '1';
	else
		return '0';

}

void CServerMain::FillTaxDetails(int iTaxIndex ,TAX_PROPERTIES &cTaxPropertis)
{
	memcpy(&cTaxPropertis,&m_cTaxMap[iTaxIndex],sizeof(m_cTaxMap[iTaxIndex]));
}


/******************************************************************************
 Description: Return to car wash amount to charge.
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
******************************************************************************/
long CServerMain::GetCarWashAmountToCharge(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);

	long lPrice = a2l((BYTE *)&PapInfo.CardSaleInfo.extraData.SALES[0].sUnitPrice,sizeof(PapInfo.CardSaleInfo.extraData.SALES[0].sUnitPrice));
	long lQuantity = a2l((BYTE *)&PapInfo.CardSaleInfo.extraData.SALES[0].sQty,sizeof(PapInfo.CardSaleInfo.extraData.SALES[0].sQty));

	if(lPrice > 0 )
		return lPrice*lQuantity;

	return 0;
}

/******************************************************************************
 Description: Return the pre authorize amount 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
******************************************************************************/
long CServerMain::GetAuthorizedAmount(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);

	long lAuthorizedAmount = ConvertStringsToLong(PapInfo.CardSaleInfo.cardData.sAuthAmt,sizeof(PapInfo.CardSaleInfo.cardData.sAuthAmt),
		PapInfo.CardSaleInfo.extraData.sAuthAmt_Msb   ,sizeof(PapInfo.CardSaleInfo.extraData.sAuthAmt_Msb));

	return lAuthorizedAmount;
}

/******************************************************************************
 Description: Returns the requested amount for authorizing
			  in case we have preset amount use it.
			  in case we don't have preset amount get the pre-authorized amount from the card.
			  in both cases we add the car wash amount
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
 OmerT						Update      Do not add the carwash amount
******************************************************************************/
long CServerMain::GetRequstedAuthorizeAmount(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);

	long lPreAuthorizedAmount = a2l(PapInfo.CardSaleExtraData4.sPreAuthAmount, sizeof(PapInfo.CardSaleExtraData4.sPreAuthAmount)) * 10;
	long lPresetAmount = a2l(PapInfo.CardSaleExtraData3.sPreSetlimit, sizeof(PapInfo.CardSaleExtraData3.sPreSetlimit));

	long lSiteLitmit = GetLimit(PRICE_LEVEL_CREDIT);

	if (lPresetAmount > 0)
		return min(lPresetAmount,lSiteLitmit);
	else if (lPreAuthorizedAmount > 0 )
		return min(lPreAuthorizedAmount, lSiteLitmit);
	else
		return lSiteLitmit;

	/*
	if (lPresetAmount > 0)
		return lPresetAmount;
	else
		return lPreAuthorizedAmount;
	*/

}
/******************************************************************************
 Description: Returns authorized amount for first tender
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
******************************************************************************/
long CServerMain::GetFirstTenderAuthorizedAmountLimit(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);
	return a2l(PapInfo.CardSaleExtraData6.PaymentCard1.sAuthorizeAmountLimit,sizeof(PapInfo.CardSaleExtraData6.PaymentCard1.sAuthorizeAmountLimit));
}
/******************************************************************************
 Description: Returns authorized amount for second tender 
 Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
******************************************************************************/
long CServerMain::GetSecondTenderAuthorizedAmountLimit(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);
	return a2l(PapInfo.CardSaleExtraData6.PaymentCard2.sAuthorizeAmountLimit,sizeof(PapInfo.CardSaleExtraData6.PaymentCard2.sAuthorizeAmountLimit));
}
/******************************************************************************
Description: Returns the the remaining balance for the current transaction 
(the first tender authorized amount was not enough to cover for all the trs)
Returns:      	
 Parameters:   

 WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
 OmerT	    				Start		4.0.32.102 CR 404913
******************************************************************************/
long CServerMain::GetRemainingBalance(long lPumpNumber)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&PapInfo);
	return a2l(PapInfo.CardSaleExtraData6.sRemainingBalance,sizeof(PapInfo.CardSaleExtraData6.sRemainingBalance));
}
void CServerMain::HandlePriceChangeUnlock()
{
	m_cServerInfo.SetServerReservation(PRICE_CHANGE);
	SetServerLockStatus(STARTED);

	if ((m_cOLASrv != NULL) && m_cOLASrv->SupportIFSFProtocoll())				//4.0.5.39
		m_cOLASrv->LoadAllProductSoldOnPump(0);
}

void CServerMain::HandlePriceChangeWaitLock()
{
	long lTmpLockResExt = m_cServerInfo.GetServerReservation();
	BOOL bForeCourtCloseByMaintenence  = (lTmpLockResExt & MAINTENANCE)? TRUE : FALSE; 

	BOOL bAllPumpsLocked = TRUE;

	lTmpLockResExt = PRICE_CHANGE;

	// TD 426940
	if ((TRUE == m_cPriceChangeFlags.IsRequiredTotals()) && (m_cServerInfo.GetLockForecourtOnPriceChangeFlags()))
	{
		CString str;  // it's does not works together
		str.Format("Detect RequiredTotals and LockForecourtOnPriceChangeFlag - it's does not works together, Set LockForecourtOnPriceChangeFlag as FALSE"); 
		m_cServerInfo.SetLockForecourtOnPriceChangeFlags(FALSE);
		m_cLogger.LogMsg(str, LOG_LOGIC_ERROR);	

	}

	if ((m_cServerInfo.GetLockForecourtOnPriceChangeFlags()) && (!bForeCourtCloseByMaintenence))
	{
		for (int p=0;p< m_lMaxPumps;p++)  
		{
			if(!DoAutomaticPumpLock(p+1,lTmpLockResExt))							
			{
				bAllPumpsLocked = FALSE;

				if(m_cServerInfo.GetServerStatus() != WAIT_LOCK) 
					SetServerLockStatus(WAIT_LOCK);	
			}
		}
	}


	if (TRUE == m_cPriceChangeFlags.IsRequiredTotals())
	{
		bAllPumpsLocked = PriceChangeReadPumpTotals();
	}


	if(bAllPumpsLocked)
		SetServerLockStatus(LOCKED);	

	m_cServerInfo.SetServerReservation(lTmpLockResExt);
}

void CServerMain::HandlePriceChangeLocked()
{
	SendGradePrice(0);
	SetServerLockStatus(RESPONSE_RECEIVED);
}

void CServerMain::HandlePriceChangeResponseReceived()
{
	BOOL bAllPumpsUnLocked = TRUE;
	long lTmpLockResExt = m_cServerInfo.GetServerReservation();
	BOOL bForeCourtCloseByMaintenence  = (lTmpLockResExt & MAINTENANCE)? TRUE : FALSE;  //3.0.1.84


	if ((m_cServerInfo.GetLockForecourtOnPriceChangeFlags()) && (!bForeCourtCloseByMaintenence))
	{
		for(int p=0;p<m_lLastValidPump;p++)
		{
			if(DoAutomaticPumpUnLock(p+1) == FALSE)
			{
				bAllPumpsUnLocked = FALSE;
			}
		}
	}

	if(bAllPumpsUnLocked)
	{				
		m_cServerInfo.SetRequiredPriceChangeFlags(FALSE);

		if (!bForeCourtCloseByMaintenence)  //2.9.3.2
		{
			m_cServerInfo.SetServerReservation(0);
			SetServerLockStatus(UNLOCK);
		}
		else
		{
			m_cServerInfo.SetServerReservation(MAINTENANCE);
			SetServerLockStatus(LOCKED);
		}

		// 14/11/00
		// Update the field "PriceChangeDone", and changing the Price Change State
		// to CHANGE_DONE was moved from the function CheckPriceChange, because
		// a new price change request from the B/O might come until we will get to that
		// point, and it will not be processed.
		m_cPriceChangeFlags.SetPriceChangeStatus(1); //4.0.8.501

		SetPriceChangeState(CHANGE_DONE);

		//4.0.12.517
		SetInOriginalPriceChangeProcess(FALSE);


		if (GetPriceChangeResponse() == GOT_PRICE_CHANGE_SUCCESS)
		{
			//*************
			///Success
			//*************
			PriceChangeSuccess();
		}
		else if (GetPriceChangeResponse() == GOT_PRICE_CHANGE_FAILURE)
		{
			//*************
			///Failure
			//*************
			PriceChangeFailure();
		}

		//Do not Reset the response of the price change in case we are waiting for commit. We remain in process
		if (GetPriceChangeResponse() != GOT_PRICE_CHANGE_PENDING_COMMIT_AFTER_FAILURE)	//4.0.27.30 TD 222751
			SetPriceChangeResponse(PRICE_CHANGE_NO_RESPONSE);

		//4.0.22.503 - TD 73366
		// When price change process ends, send reconfigure to IFSFTerminalSrv (if active)
		if (GetIFSFTerminalSrvInUse() || IsFuelMobileSrvInUse())// CR 444830
			m_cGPIEventMgr.AddReconfigure(GRADES_TABLE, 0, 0, 0);

	}
}
//CR_475695_Start
BOOL CServerMain::PriceChangeReadPumpTotals()
{
	BOOL bAllPumpsReadDone = TRUE;

	for (int p = 0; p < m_lLastValidPump; p++)  
	{
		int iRetValPumpRead = -1;

		if (m_cPriceChangeFlags.GetPriceChangeTotalsRequestState(p+1) != PChange_TOTALS_REQUEST_RECEIVED)
		{
			iRetValPumpRead = DoAutomaticReadTotal(p+1,FALSE);  // without LOCK
		}


		if(iRetValPumpRead == 0) //in progress 
		{
			bAllPumpsReadDone = FALSE;  			// wait for DONE 
			m_cPriceChangeFlags.SetPriceChangePumpTotalsRequestState(p+1, PChange_TOTALS_REQUEST_STARTED);

			if(m_cServerInfo.GetServerStatus() != WAIT_LOCK) 
				SetServerLockStatus(WAIT_LOCK);	
		}

		if(iRetValPumpRead == 1) //done 
		{
			m_cPriceChangeFlags.SetPriceChangePumpTotalsRequestState(p+1, PChange_TOTALS_REQUEST_RECEIVED);

			if(LOG_BASIC_FLOW_CONTROL)
			{	
				CString str;
				str.Format("Total Pump Read done by PRICE_CHANGE request."); 
				m_cLogger.LogMsg(p+1,LOG_PUMP,str);
			}
		}
	}


	return bAllPumpsReadDone;
}


BOOL CServerMain::PriceChangeTankReadTotals()
{   
  BOOL bIsFirstCall = FALSE; 
  BOOL bAllTanksReadDone = FALSE;
  bIsFirstCall = (m_cPriceChangeFlags.GetPriceChangeTanksReadState() == PChange_Tanks_NO_TOTALS_REQUEST);
	if (TRUE == bIsFirstCall)  
	{
		CString str;
		str.Format("PriceChangeTankReadTotals  - First Call !" );
		m_cLogger.LogMsg(str);	
		 if(LOG_BASIC_FLOW_CONTROL)
		 {	
			 CString str;
			 str.Format("Send Commands : GET_TANK_READING (periodic tank )");
			 m_cLogger.LogMsg(str);
		 }
		m_bTankReadingRcved = FALSE;
		 m_cPriceChangeFlags.SetPriceChangeTanksReadState(PChange_Tanks_TOTALS_REQUEST_STARTED);
		CMD_STRUCT_TANK_READING cmdInfo;
		cmdInfo.lStatus = TANK_STATUS_IDLE;							
		SetCommand(CMD_GET_TANK_READING, SERVER_POS_NUMBER, 0,&cmdInfo,sizeof(CMD_STRUCT_TANK_READING)); // 0 - All tanks.
	}
	if (TRUE == m_bTankReadingRcved)
	{
		CString str;
		str.Format("PriceChangeTankReadTotals  - Received !" );
		m_cLogger.LogMsg(str);
		m_cPriceChangeFlags.SetPriceChangeTanksReadState(PChange_Tanks_TOTALS_REQUEST_RECEIVED);
	}
    bAllTanksReadDone  = m_bTankReadingRcved;
	 return bAllTanksReadDone;
}
//CR_475695_End

void CServerMain::SaveTenderData(long lPumpNumber, PAY_AT_PUMP_INFO * pInfo)
{
	long lPumpIndex = lPumpNumber - 1;
	CTendersCard tendersCard(m_cTendersCard[lPumpIndex].size(), lPumpIndex);

	CString sAccountNumber;
	sAccountNumber.Format("%.21s", pInfo->CardSaleInfo.cardData.sAccountNumber);
	tendersCard.SetAccountNumber(sAccountNumber);
	
	char cExpireDate[sizeof(pInfo->CardSaleInfo.cardData.sExpire) + 1] = { 0 };
	sprintf_s(cExpireDate, sizeof(cExpireDate), "%.4s", pInfo->CardSaleInfo.cardData.sExpire);
	tendersCard.SetExpireDate(cExpireDate, *pInfo);

	CString sMediaMasterType;
	sMediaMasterType.Format("%.20s", pInfo->CardSaleExtraData2.sMediaMasterType);
	tendersCard.SetMediaMasterType(sMediaMasterType);

	tendersCard.SetMediaType(pInfo->CardSaleInfo.cardData.sTranType);

	m_cTendersCard[lPumpIndex].push_back(tendersCard);

	SaveTenderAuthorizedAmount(lPumpNumber, pInfo);
}

void CServerMain::SaveTenderAuthorizedAmount( long lPumpNumber, PAY_AT_PUMP_INFO * pInfo )
{
	if(FALSE == m_bTwoTendersInTransaction)
		return;
	
	long lAmountLimit = ConvertStringsToLong(pInfo->CardSaleInfo.cardData.sAuthAmt,sizeof(pInfo->CardSaleInfo.cardData.sAuthAmt),pInfo->CardSaleInfo.extraData.sAuthAmt_Msb,sizeof(pInfo->CardSaleInfo.extraData.sAuthAmt_Msb));				

	long lOffet = 0;
	if(GetNumberOfTendersAuthotized(lPumpNumber-1) > 0)
	{
		lOffet = sizeof(PAYMENT_CARD_DETAILS);
	}

	if (ChrAll(pInfo->CardSaleExtraData6.PaymentCard1.sCardName + lOffet, sizeof(pInfo->CardSaleExtraData6.PaymentCard1.sCardName))) // TD 456795
	{
		memcpy(pInfo->CardSaleExtraData6.PaymentCard1.sCardName + lOffet, pInfo->CardSaleInfo.cardData.sCardName, sizeof(pInfo->CardSaleInfo.cardData.sCardName));		
	}

	memcpy(pInfo->CardSaleExtraData6.PaymentCard1.sRefernceNumber+lOffet,pInfo->CardSaleInfo.cardData.sReferenceNumber,sizeof(pInfo->CardSaleExtraData6.PaymentCard1.sRefernceNumber));
	l2a0(lAmountLimit, pInfo->CardSaleExtraData6.PaymentCard1.sAuthorizeAmountLimit+lOffet , 10);

	m_cPumpArray[lPumpNumber-1].SetPAPInfo(pInfo);

	IncrementNumberOfTendersAuthorized(lPumpNumber-1);
}


void CServerMain::ClearTendersCards(long lPumpIndex)
{
	m_cTendersCard[lPumpIndex].clear();
}

long CServerMain::GetCustInfoRetryRequest(PAY_AT_PUMP_INFO & cTmpInfo, long lPumpNumber, OLA_STAT & ola)
{
	long p = lPumpNumber - 1;

	l2a(120, cTmpInfo.CardSaleExtraData2.sMessageTimeOut, sizeof(cTmpInfo.CardSaleExtraData2.sMessageTimeOut));

	// QC 461948 l2a((ONMP_OpenYesNoKeys | ONMP_NoAsCancel), cTmpInfo.CardSaleExtraData4.sONMPProperties, sizeof(cTmpInfo.CardSaleExtraData4.sONMPProperties));
	l2a(ONMP_EnterAsYes | ONMP_LoyaltyCard | 13, cTmpInfo.CardSaleExtraData4.sONMPProperties, sizeof(cTmpInfo.CardSaleExtraData4.sONMPProperties));

	memset(cTmpInfo.CardSaleExtraData3.sParamResult, ' ', sizeof(cTmpInfo.CardSaleExtraData3.sParamResult));  //4.0.23.1890

	l2a(PT_GENERIC, cTmpInfo.CardSaleExtraData3.sPromptType, sizeof(cTmpInfo.CardSaleExtraData3.sPromptType));//General ONMP
	cTmpInfo.CardSaleExtraData3.sPromptMinLen[0] = '1';

	l2a(NMP_MAX_NUM_OF_OPEN_KEYS, cTmpInfo.CardSaleExtraData3.sPromptMaxLen, sizeof(cTmpInfo.CardSaleExtraData3.sPromptMaxLen));
	cTmpInfo.CardSaleExtraData3.sParamResult[0] = '?';

	_Module.m_server.m_cPumpArray[lPumpNumber - 1].SetPAPInfo(&cTmpInfo);

	CMD_STRUCT_PAP_SWIPE_RESULT3_EX cmdInfo;
	_Module.m_server.SetSwipeResultDataToCommand(cmdInfo, cTmpInfo, CD_MORE_DATA_REQUIRED);
	SetCommand(CMD_SWIPE_RESULT, SERVER_POS_NUMBER, lPumpNumber, &cmdInfo, sizeof(CMD_STRUCT_PAP_SWIPE_RESULT3_EX));

	_Module.m_server.m_cPumpArray[lPumpNumber - 1].SetPAPInfo(&cTmpInfo);

	_LOGMSG.LogMsg(lPumpNumber, LOG_PUMP, "GetCustInfo Retry Request");

	return 0;
}


long CServerMain::GetFuelTaxAmountFormCardSaleData(long lPumpIndex,int iTaxId )
{
	PAY_AT_PUMP_INFO papInfo;
	m_cPumpArray[lPumpIndex].GetPAPInfo(&papInfo);

	if(iTaxId == 1)
		return a2l(papInfo.CardSaleExtraData5.sTaxAmt1,sizeof(papInfo.CardSaleExtraData5.sTaxAmt1));
	if(iTaxId == 2)
		return a2l(papInfo.CardSaleExtraData2.sTaxAmt2,sizeof(papInfo.CardSaleExtraData2.sTaxAmt2));
	if(iTaxId == 3)
		return a2l(papInfo.CardSaleExtraData2.sTaxAmt3,sizeof(papInfo.CardSaleExtraData2.sTaxAmt3));
	if (iTaxId == 4)
		return a2l(papInfo.CardSaleExtraData6.sTaxAmt4, sizeof(papInfo.CardSaleExtraData6.sTaxAmt4));
	return 0;

}

long CServerMain::GetCarWashTaxFromCardSaleData(long lPumpIndex,int iTaxId )
{
	PAY_AT_PUMP_INFO papInfo;
	m_cPumpArray[lPumpIndex].GetPAPInfo(&papInfo);

	if(iTaxId == 1)
		return a2l(papInfo.CardSaleExtraData6.CarWashItem.sTaxAmount1,sizeof(papInfo.CardSaleExtraData6.CarWashItem.sTaxAmount1));
	if(iTaxId == 2)
		return a2l(papInfo.CardSaleExtraData6.CarWashItem.sTaxAmount2,sizeof(papInfo.CardSaleExtraData6.CarWashItem.sTaxAmount2));

	return 0;

}

void CServerMain::CalculateTendersTotalAmount(long lPumpNumber, long lTotalAmount,DOUBLE &dFirstCardTenderAmount,DOUBLE &dSecondCardTenderAmount)
{
	PAY_AT_PUMP_INFO info;
	m_cPumpArray[lPumpNumber-1].GetPAPInfo(&info);

	DOUBLE dAuthorizeAmountLimit1 = GetFirstTenderAuthorizedAmountLimit(lPumpNumber)*10;
	DOUBLE dAuthorizeAmountLimit2 = GetSecondTenderAuthorizedAmountLimit(lPumpNumber)*10;
	DOUBLE dRemainingBalance = GetRemainingBalance(lPumpNumber);
	if(lTotalAmount != 0)
	{
		if(dAuthorizeAmountLimit1 >= lTotalAmount)
		{
			dFirstCardTenderAmount = lTotalAmount;
		}
		else
		{
			dFirstCardTenderAmount = dAuthorizeAmountLimit1;
			dSecondCardTenderAmount = min(min(lTotalAmount - dFirstCardTenderAmount,dAuthorizeAmountLimit2),dRemainingBalance*10);
		}
	}
}

/******************************************************************************
Description: Load loyalty receipt info xml file and concatenate it to the
card sale data xml. The root node in the xml will be <PrintMessages>


WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
Omer			21/05/2012				// 4.0.111.171
******************************************************************************/
void CServerMain::ConcatenateLoyaltyReceiptMessages(CXMLInterface & xmlFatherDoc, CXMLPointers & pCurrElement, char * sFileName, long  & lPumpNumber)
{
	BOOL bRetCode = TRUE;
	CString strMsg;
	try
	{
		CXMLInterface	xmlSonDoc;
		bRetCode = xmlSonDoc.InitDoc();
		bRetCode = xmlSonDoc.LoadFile(sFileName);

		if (!bRetCode)
		{
			strMsg.Format("LoadLoyaltyReceiptInfo, Failed to load xml from file %s", sFileName);
			m_cLogger.LogMsg(strMsg, LOG_LEVEL_0);
		}
		else
		{
			strMsg.Format("LoadLoyaltyReceiptInfo load xml from file %s successfully", sFileName);
			m_cLogger.LogMsg(strMsg);

			// get the root to the son.
			CXMLPointers pRoot;
			bRetCode = xmlSonDoc.GetRootNode(&pRoot);

			m_cCardSaleDataXML.AppendLoyaltyMessagesToXmlObject(lPumpNumber, xmlSonDoc);   //4.0.111.194

			// concatenate the xmls
			if (bRetCode)
				bRetCode = xmlFatherDoc.AppendChildElement(&pRoot, &pCurrElement);

			xmlSonDoc.CloseDoc();
		}

		if (LOG_BASIC_FLOW_CONTROL)
		{
			if (bRetCode)
				m_cLogger.LogMsg("CServerMain::LoadLoyaltyReceiptInfo - concatenate ReceiptInfo xml successfully");
			else
				m_cLogger.LogMsg("CServerMain::LoadLoyaltyReceiptInfo - Failed to concatenate ReceiptInfo xml!", LOG_LEVEL_0);
		}
	}
	catch (...)
	{
		m_cLogger.LogMsg("CServerMain::LoadLoyaltyReceiptInfo - Failed to concatenate ReceiptInfo xml!", LOG_LEVEL_0);
	}
}


/******************************************************************************
Description: Call getMemberInfo and move OLA state to wait response from 
			 loyaltyFuel


WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
Omer			02/05/2016				// CR 405435
******************************************************************************/
void CServerMain::GetMemberInfo(long lPumpNumber, OLA_STAT * pOla, long p)
{
	m_cFuelLoayaltyPS.GetMemberInfo(lPumpNumber);

	m_cFuelLoayaltyPS.PrintLoyaltyStateToLog(lPumpNumber, pOla->m_byState, OLA_LOYALTY_WAIT_GET_MEMBER_INFO_RESPONSE);

	pOla->m_byState = OLA_NEW_STATE(pOla->m_byState, OLA_LOYALTY_WAIT_GET_MEMBER_INFO_RESPONSE);

	m_cPumpArray[p].SetOlaStat(pOla);
}

BOOL CServerMain::IsContactlessCard(long lPumpNumber)
{
	PAY_AT_PUMP_INFO info;
	m_cPumpArray[lPumpNumber - 1].GetPAPInfo(&info);
	return (info.CardSaleInfo.cardData.sEntryMethod == CD_TYPE_FLEET) || (info.CardSaleInfo.cardData.sEntryMethod == CD_TYPE_SPEED_PASS);
}

BOOL CServerMain::IsCardSwiped(BYTE	&sEntryMethod)
{
	return (sEntryMethod == CD_TYPE_FLEET || sEntryMethod == CD_TYPE_SPEED_PASS || sEntryMethod == CD_TYPE_CREDIT || sEntryMethod == 'S');
}

long CServerMain::ConvertOlaToCReceiptInfo(CPumpTransact *pTrs, PAY_AT_PUMP_INFO *pPAPInfo, CReceiptInfo & ReceiptInfo, BYTE lOlaState /*= 0*/)
{
	return m_cBaseReceipt->ConvertOlaToReceipt(pTrs, pPAPInfo, ReceiptInfo, lOlaState);
}

/******************************************************************************
Description: GetCardInfoEx2 - Warper for OLA getCardInfoEx
loyaltyFuel


WHO				WHEN                    WHAT
-------------------------------------------------------------------------------
Omer			29/06/16				
******************************************************************************/
long CServerMain::GetCardInfoEx(long lPumpNumber, long lClientId, BYTE byTrack1[], BYTE byTrack2[], PAY_AT_PUMP_INFO * pInfo, long lFlags, BSTR *sRetData, long *pVal)
{
	long lRtc = 0;
	CComBSTR sCardBuf;
	CString sBuffer;

	BYTE sEntryMethod[2];	
	sEntryMethod[0] = pInfo->CardSaleInfo.cardData.sEntryMethod;

	//RFUEL-3868 - MediaMasterType field is incorrect for all outdoor EMV cards
	//Change entryMethod to be "S" instead of "C" or "W" instead of "H"
	if (pInfo->CardSaleInfo.cardData.sEntryMethod == 'C')
		sEntryMethod[0] = 'S';

	if (pInfo->CardSaleInfo.cardData.sEntryMethod == 'H')
		sEntryMethod[0] = 'W';


	if (pInfo->CardSaleInfo.cardData.sEntryMethod == 'B')  //RFUEL-2399
		sBuffer.Format("AccountNumber[S]=%.21s,EntryMethod[S]=%.1s , AID[S]=%.32s", byTrack2, sEntryMethod, pInfo->CardSaleExtraData3.sAID);
	else
		sBuffer.Format("Track1[S]=%.76s,Track2[S]=%.37s,EntryMethod[S]=%.1s , AID[S]=%.32s", byTrack1, byTrack2, sEntryMethod, pInfo->CardSaleExtraData3.sAID);

	CComBSTR bstrInBuffer(sBuffer.GetBuffer(0));
	CARD_SALE_ALL3 CardData;
	memset(&CardData, ' ', sizeof(CardData));
	CardData.CardSaleAll.data.sEntryMethod = pInfo->CardSaleInfo.cardData.sEntryMethod; // TD 460209
	long lOlaRecordSize = sizeof(CARD_SALE_ALL3);

	if (CheckOLA() != OLASRV_COM_ERROR)
	{
		lRtc = m_cOLASrv->GetCardInfoEx(lClientId, bstrInBuffer, &sCardBuf, lFlags);
	}

	if (m_cOLASrv->Valid() && lRtc == 0)
	{
		if (lFlags & GET_ALL_CARDS_DATA)
		{
			CString sCardOlaInfo = sCardBuf.m_str;
			PAY_AT_PUMP_INFO cPayAtPumpInfo;
			memset(&cPayAtPumpInfo, ' ', sizeof(cPayAtPumpInfo));
			m_cOLASrv->ParseData(OLASRV_NEED_MORE_PARAMS, &sCardOlaInfo, &cPayAtPumpInfo, NULL, 0, lPumpNumber); //4.0.16.503
			CardData.CardSaleAll.data = cPayAtPumpInfo.CardSaleInfo.cardData;
			CardData.CardSaleAll.extData = cPayAtPumpInfo.CardSaleInfo.extraData;
			CardData.extData2 = cPayAtPumpInfo.CardSaleExtraData2;
			CardData.extData3 = cPayAtPumpInfo.CardSaleExtraData3;
		}
		else
			m_cOLASrv->ParseCardData(sCardBuf, &CardData, lPumpNumber);


		if (lFlags & SWIPE_THREE_OLA_REC)
		{
			if (!GetOLAFlags(CardData.extData2.sFlags, FL_PAP_AS_THIRD_REC))
			{
				long lTmp = a2l(CardData.extData2.sFlags, sizeof(CardData.extData2.sFlags)) + FL_PAP_AS_THIRD_REC;
				l2a(lTmp, CardData.extData2.sFlags, sizeof(CardData.extData2.sFlags));
			}
		}

		char sXmlBuff[MAX_XML_BUF_LEN] = { 0 };
		memcpy(sXmlBuff, &CardData, lOlaRecordSize);

		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("GetCardInfoEx Attendant name=%.15s, ID=%.10s,buffer size=%ld.", CardData.extData2.sAttendantName, CardData.extData2.sAttendantID, lOlaRecordSize);
			m_cLogger.LogMsg(str);
		}

		CComBSTR CParam(sizeof(sXmlBuff), sXmlBuff);
		CParam.CopyTo(sRetData);
	}

	return lRtc;
}

// TD COSTCO-Tax
void CServerMain::CalculateTaxes(PAY_AT_PUMP_INFO * pInfo, long lPumpNumber, CPumpTransact*pTrs)
{
	long p = lPumpNumber - 1;

	CARD_SALE_ALL3 cardSaleAll3;
	memset(&cardSaleAll3, ' ', sizeof(CARD_SALE_ALL3));
	cardSaleAll3.CardSaleAll.data = pInfo->CardSaleInfo.cardData;
	cardSaleAll3.CardSaleAll.extData = pInfo->CardSaleInfo.extraData;
	cardSaleAll3.extData2 = pInfo->CardSaleExtraData2;
	cardSaleAll3.extData3 = pInfo->CardSaleExtraData3;
	cardSaleAll3.extData4 = pInfo->CardSaleExtraData4;
	cardSaleAll3.extData5 = pInfo->CardSaleExtraData5;
	cardSaleAll3.extData6 = pInfo->CardSaleExtraData6;
	
	TAX_PROPERTIES cTaxProp;

	CPumpTransact trs;
	m_cPumpArray[p].GetCurrentTrs(&trs);
	
	DWORD dwTaxMap;
	char       strRegEntry[50];
	sprintf_s(strRegEntry, _countof(strRegEntry), "Grades\\Grade%.2d", trs.m_nGrade);
	m_cParam.LoadParam((LPCSTR)strRegEntry, "MapTaxLink", &dwTaxMap, (DWORD)0, FALSE);
	
	GetTaxProperties(dwTaxMap, &cTaxProp);

	// Save tax index
	l2a0(cTaxProp.lTaxId, pInfo->CardSaleExtraData3.sTaxId, sizeof(pInfo->CardSaleExtraData3.sTaxId));

	if (cTaxProp.bIsIncluded)
		pInfo->CardSaleExtraData3.sTaxIncluded = '1';
	else
		pInfo->CardSaleExtraData3.sTaxIncluded = '0';

	unsigned char sTmpVatRate[5] = { '0' };
	l2a(cTaxProp.lTaxRate, (unsigned char *)sTmpVatRate, sizeof(sTmpVatRate));
	UnpackFields(sTmpVatRate, pInfo->CardSaleInfo.extraData.sVAT_Rate, sizeof(pInfo->CardSaleInfo.extraData.sVAT_Rate),
		&pInfo->CardSaleExtraData5.sVAT_RateMSB, sizeof(pInfo->CardSaleExtraData5.sVAT_RateMSB)); // TD 404911

	if (m_cTaxCalclator == NULL)
	{
		if (LOG_BASIC_FLOW_CONTROL)
			_LOGMSG.LogMsg("Tax Calculator not configured!", lPumpNumber);
		return;
	}
	else
	{
		//Grade Taxes
		FuelTaxDetails cFuelDetails;
		FillGradeTaxDetalis(p, cFuelDetails,pTrs);

		// carwash
		CarWashTaxDetails cCarWashTax;
		FillCarWashTaxDetalis(p, cCarWashTax);

		m_cTaxCalclator->Calculate(cFuelDetails, cCarWashTax, &cardSaleAll3);

		pInfo->CardSaleInfo.cardData = cardSaleAll3.CardSaleAll.data;
		pInfo->CardSaleInfo.extraData = cardSaleAll3.CardSaleAll.extData;
		pInfo->CardSaleExtraData2 = cardSaleAll3.extData2;
		pInfo->CardSaleExtraData3;  cardSaleAll3.extData3;
		pInfo->CardSaleExtraData4 = cardSaleAll3.extData4;
		pInfo->CardSaleExtraData5 = cardSaleAll3.extData5;
		pInfo->CardSaleExtraData6 = cardSaleAll3.extData6;
	}
}


// TD COSTCO-Tax
void CServerMain::CreateTaxCalcator()
{
	DWORD dwParam;
	char  strRegEntry[MAX_PATH];

	sprintf_s(strRegEntry, MAX_PATH, "Taxes\\GeneralParam");
	m_cParam.LoadParam((LPCSTR)strRegEntry, "TaxRegulation", &dwParam, (DWORD)0, TRUE);
//	LoadParam(strRegEntry, 0, 0, "TaxRegulation", &dwParam, 0, TRUE);

	if (m_cTaxCalclator) // 2.5.31.510
		delete m_cTaxCalclator;

	m_cTaxCalclator = NULL;

	switch (dwParam)
	{
	case eCandianTaxCalclator:
	{
								 if (LOG_DETAIL_FLOW_CONTROL)
									 _LOGMSG.LogMsg("Canadian Tax detected!");

								 CreateCandianTaxCalaclator();
								 break;
	}
	case eDefaultTaxCalclator:
	{
								 if (LOG_DETAIL_FLOW_CONTROL)
									 _LOGMSG.LogMsg("Legacy Tax detected!");

								 m_cTaxCalclator = new CLegacyTaxCalc();
								 break;
	}

	case eMultipleTaxCalclator:
	{
								  if (LOG_DETAIL_FLOW_CONTROL)
									  _LOGMSG.LogMsg("Multiple Tax detected!");

								  m_cTaxCalclator = new CMutipleTaxCalculator();
								  break;
	}
	default:
		break;
	}

	if (m_cTaxCalclator == NULL)
	{
		if (LOG_DETAIL_FLOW_CONTROL)
			_LOGMSG.LogMsg("Tax calculator was not configured!");
	}
	else
		m_cTaxCalclator->Print();

}

// TD COSTCO-Tax
void CServerMain::CreateCandianTaxCalaclator()
{
	DWORD dwGST, dwQST, dwPST;

	if (LoadCanaidanParams(dwGST, dwQST, dwPST))
		m_cTaxCalclator = new CCandianTaxCalc(dwGST, dwPST, dwQST);

}

/******************************************************************************
Description:	return a tax properties according to the the tax bit map.
support only one tax (if an item has more then one tax in the bit
map, only the first properties will be returned.

Returns:      	index to the registry entry of the tax.
Parameters:

WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
Ariel			30/04/2006   17:29		Start
******************************************************************************/
long CServerMain::GetTaxProperties(DWORD dwTaxMap, TAX_PROPERTIES * TaxProp)	// TD COSTCO-Tax
{
	DWORD dwMask = 1;
	long lTaxTaxIndex = 0;
	BOOL bContinue = TRUE;

	for (int i = 0; i < MAX_TAXES && bContinue; i++)
	{
		if (dwTaxMap & dwMask)
		{
			if (TaxProp)
				memcpy(TaxProp, &m_cTaxMap[i], sizeof(TAX_PROPERTIES));
			lTaxTaxIndex = i + 1;
			bContinue = FALSE;
		}
		dwMask = dwMask << 1;
	}
	return lTaxTaxIndex;
}

void CServerMain::FillGradeTaxDetalis(long lPumpIndex, FuelTaxDetails &cFuelDetails, CPumpTransact*pTrs)
{
	CPumpTransact trs;
	m_cPumpArray[lPumpIndex].GetCurrentTrs(&trs);

	DWORD dwTaxMap;
	char       strRegEntry[50];
	sprintf_s(strRegEntry, _countof(strRegEntry), "Grades\\Grade%.2d", trs.m_nGrade);
	m_cParam.LoadParam((LPCSTR)strRegEntry, "MapTaxLink", &dwTaxMap, (DWORD)0, FALSE);

	PAY_AT_PUMP_INFO Info;
	m_cPumpArray[lPumpIndex].GetPAPInfo(&Info);
	long lTmpFuelAmt = ConvertStringsToLong(Info.CardSaleInfo.extraData.sFuelAmt, sizeof(Info.CardSaleInfo.extraData.sFuelAmt), Info.CardSaleInfo.extraData.sFuelAmt_Msb, sizeof(Info.CardSaleInfo.extraData.sFuelAmt_Msb));
	lTmpFuelAmt = lTmpFuelAmt * 10;
	long lGRTotalDiscount = a2l(Info.CardSaleInfo.extraData.sGRTotalDiscount, sizeof(Info.CardSaleInfo.extraData.sGRTotalDiscount));
	
	if ((lGRTotalDiscount > 0) && (lGRTotalDiscount < lTmpFuelAmt))
		lTmpFuelAmt = lTmpFuelAmt - lGRTotalDiscount;

	CString str;
	str.Format("CServerMain::FillGradeTaxDetalis Fuel amount for tax calculation after discount = %ld", lTmpFuelAmt);
	_LOGMSG.LogMsg(str);

	cFuelDetails.lAmount = lTmpFuelAmt;			//m_PumpInfo[lPumpIndex].Trs.m_lValue;
	cFuelDetails.tax.dwLink = dwTaxMap;			//m_nGrade[m_PumpInfo[lPumpIndex].Trs.m_nGrade - 1].dwTaxMap;
	cFuelDetails.tax.dwRate = TranlateTaxMap(dwTaxMap);		// (m_nGrade[m_PumpInfo[lPumpIndex].Trs.m_nGrade - 1].dwTaxMap);
	cFuelDetails.nGrade = trs.m_nGrade;		// m_PumpInfo[lPumpIndex].Trs.m_nGrade;
	cFuelDetails.lVolume = trs.m_lRoundedVolume;
}

// TD COSTCO-Tax
void CServerMain::FillCarWashTaxDetalis(long lPumpIndex, CarWashTaxDetails &cCarWashTax)
{
	PAY_AT_PUMP_INFO PapInfo;
	m_cPumpArray[lPumpIndex].GetPAPInfo(&PapInfo);

	CAR_WASH_PROGRAM cCarWashProgramInfo;
	long lCarWashCode = a2l(PapInfo.CardSaleInfo.extraData.SALES[0].sDPTProdCode, sizeof(PapInfo.CardSaleInfo.extraData.SALES[0].sDPTProdCode));

	long lQty = a2l(PapInfo.CardSaleInfo.extraData.SALES[0].sQty, sizeof(PapInfo.CardSaleInfo.extraData.SALES[0].sQty));

	if ((lCarWashCode >=1) || (lCarWashCode <= MAX_CAR_WASH_PROGRAM))
	{
		cCarWashProgramInfo = m_cCarWashProgramsDetails[lCarWashCode];

		cCarWashTax.lAmount = cCarWashProgramInfo.lPrice * lQty;
		long lCCMTaxLink = a2l(PapInfo.CardSaleExtraData6.sCCMTaxLink, sizeof(PapInfo.CardSaleExtraData6.sCCMTaxLink));

		if (lCCMTaxLink > 0)
			cCarWashTax.tax.dwLink = lCCMTaxLink;
		else
			cCarWashTax.tax.dwLink = cCarWashProgramInfo.lMapTaxLink;

		if (cCarWashTax.tax.dwLink == 0) //No linked taxes! Use TaxRate from the wash Program
		{
			cCarWashTax.dwIncluded = 0;
			cCarWashTax.tax.dwRate = cCarWashProgramInfo.lTaxRate;
		}
		else // link to the relevant tax
		{
			int iTax = 0;
			for (; iTax < MAX_TAXES; iTax++)
			{
				if (cCarWashTax.tax.dwLink & (1 << iTax))
				{
					break;
				}
			}
			// get the tax rate from the relevant tax
			cCarWashTax.tax.dwRate = m_cTaxMap[iTax].lTaxRate;
			cCarWashTax.dwIncluded = m_cTaxMap[iTax].bIsIncluded;
		}

		if (cCarWashTax.lAmount > 0)
		{
			CString str;
			str.Format("CarWash Details: Amount %ld , TaxIncluded = %ld, TaxRate = %d, Quantity = %d",
				cCarWashTax.lAmount, cCarWashTax.dwIncluded, cCarWashTax.tax.dwRate, lQty);
			_LOGMSG.LogMsg(str);
		}
	}
	else
	{
		cCarWashTax.lAmount = 0;
	}
}

// TD COSTCO-Tax
BOOL CServerMain::LoadCanaidanParams(OUT DWORD &dwGST, OUT DWORD &dwQST, OUT DWORD & dwPST)
{
	int iCnt = 0;
	for (int i = 0; i < MAX_TAXES; i++)
	{
		if (strcmp(m_cTaxMap[i].sTaxName, "GST") == 0)
		{
			dwGST = m_cTaxMap[i].lTaxRate;
			iCnt++;
		}
		if (strcmp(m_cTaxMap[i].sTaxName, "PST") == 0)
		{
			dwPST = m_cTaxMap[i].lTaxRate;
			iCnt++;
		}
		if (strcmp(m_cTaxMap[i].sTaxName, "QST") == 0)
		{
			dwQST = m_cTaxMap[i].lTaxRate;
			iCnt++;
		}

		if (iCnt == 3)
			return TRUE;
	}

	return FALSE;

}

// TD COSTCO-Tax
/******************************************************************************
Description:	Translate the tax bit map into a value representing the tax
Returns:
Parameters:

WHO			WHEN                    WHAT
-------------------------------------------------------------------------------
Elad			16/5/2004   7:56		Start
YoavR			13/08/2008  14:06		Add support for returning included or excluded tax
******************************************************************************/
long CServerMain::TranlateTaxMap(DWORD dwTaxMap, BOOL bTaxIncluded)
{
	long lTaxVal = 0;
	DWORD dwMask = 1;

	for (int i = 0; i<MAX_TAXES; i++)
	{
		if (dwTaxMap & dwMask)
		{
			if (m_cTaxMap[i].bIsIncluded && bTaxIncluded)
				lTaxVal += m_cTaxMap[i].lTaxRate;
			else if (!m_cTaxMap[i].bIsIncluded && !bTaxIncluded)
				lTaxVal += m_cTaxMap[i].lTaxRate;
		}
		dwMask = dwMask << 1;
	}

	return lTaxVal;
}


void CServerMain::SetMobilePaymentMisc(long lPumpNumber, BOOL bOn)	//CR 438744
{
	long lPumpIndex = lPumpNumber - 1;

	CPumpStatus pumpStat = m_cPumpArray[lPumpIndex].GetStat();

	long lMisc = pumpStat.GetMiscExt();

	if (bOn)
	{
		lMisc |= MISC_EXT_MOBILE_PAYMENT;
	}
	else
	{
		lMisc &= MISC_EXT_NOT_MOBILE_PAYMENT;
	}

	pumpStat.SetMiscExt(lMisc);

	m_cPumpArray[lPumpIndex].SetStat(pumpStat);

	SavePumpInfo(lPumpNumber);

	CString sMsg;
	sMsg.Format("Mobile payment misc - %s", bOn ? "On" : "Off");

	m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, sMsg);
}

// CR 474446 
long CServerMain::CreateConnectToFuelMobileSrv()
{

	long lRetCode = S_OK;
	HRESULT hRes = 0;

	m_pFuelMobileSrvCtrl = NULL;

	try
	{
		m_cLogger.LogClassMsg("ServerMain", "CreateConnectToFuelMobileSrv", 0, LOG_NONE, "Create connection To FuelMobileSrv.");

		hRes = m_pFuelMobileSrvCtrl.CreateInstance(CLSID_FuelMobileCtrl);

		if (SUCCEEDED(hRes))
		{
			m_pFuelMobileSrvCtrl->Start();
			lRetCode = S_OK;
		}
		else
		{
			m_pFuelMobileSrvCtrl = NULL; // also release the object
			lRetCode = 1; //change!
		}
	}
	catch (_com_error& e)
	{
		m_cLogger.LogClassMsg("ServerMain", "CreateConnectToFuelMobileSrv", 0, LOG_NONE, e.ErrorMessage(), LOG_LEVEL_0);

		m_pFuelMobileSrvCtrl = NULL; // also release the object
		lRetCode = 1; //change!		
	}
	catch (...)
	{
		if (LOG_LOGIC_ERROR)
		{
			CString sMsg;
			sMsg.Format("CreateConnectToFuelMobileSrv");
			m_cLogger.LogMsg(sMsg, LOG_LOGIC_ERROR);
		}
	}

	return lRetCode;
}


// CR 474446 
long CServerMain::CloseConnectToFuelMobileSrv()
{
	long lRetCode = S_OK;
	HRESULT  hr = 0;

	if (m_pFuelMobileSrvCtrl != NULL)
	{

		m_cLogger.LogClassMsg("ServerMain", "CloseConnectToFuelMobileSrv", 0, LOG_NONE, "Close connection To FuelMobileSrv.");
		try
		{
			m_pFuelMobileSrvCtrl->Stop();
			m_pFuelMobileSrvCtrl.Release();
			m_pFuelMobileSrvCtrl.Detach();
			m_pFuelMobileSrvCtrl = NULL;
		}
		catch (_com_error& e)  //4.0.2.26
		{
			m_cLogger.LogClassMsg("ServerMain", "CloseConnectToFuelMobileSrv", 0, LOG_NONE, e.ErrorMessage(), LOG_LEVEL_0);
			m_pFuelMobileSrvCtrl = NULL; // also release the object
			lRetCode = 1;
		}
		catch (...)
		{
			m_cLogger.LogMsg("CServerMain::CloseConnectToFuelMobileSrv", LOG_LEVEL_1);
			m_pFuelMobileSrvCtrl = NULL;
			lRetCode = 1;
		}
	}

	return lRetCode;
}


void CServerMain::GetCurrentTransactionNumber(long lPumpNumber, long *pTrsNumber, long *pVal)
{
	GCIRetCode retCode = GCI_OK;

	if (PUMPSRV_NOT_INIT)
		retCode = GCI_MUST_INIT_FIRST;

	else if (PUMP_NOT_VALID(lPumpNumber))
		retCode = GCI_INVALID_PUMP_NUMBER;

	if (retCode == GCI_OK)
	{
		long p = lPumpNumber - 1;
		BOOL bFound = FALSE;
		CPumpTransact trs;
		PumpReservation res;
		long lResExt;


		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
		CSingleLock slPumpArray(&_Module.m_server.m_csPumpArray, TRUE);

		// M.L 12.7.98 Start
		bFound = !m_cPumpArray[p].GetCurrentTrs(&trs);
		res = m_cPumpArray[p].GetStat().GetRes();
		lResExt = m_cPumpArray[p].GetStat().GetResExt();

		if (bFound)
		{
			if (
				// 4.0.6.501
				((PAK_LINK_TYPE(trs.GetLinkFlags())) && (res == PAY_AT_KIOSK)) ||
				((trs.GetLinkFlags() & TRS_LINK_ATTEND) && (res == PAY_AT_KIOSK)) ||
				((trs.GetLinkFlags() & TRS_LINK_PREPAY_NUMBER) && (res == PRE_PAY_AT_POS)) ||
				((trs.GetLinkFlags() == TRS_LINK_OLA_NUMBER) && (res == PAY_AT_PUMP)) ||
				((PAK_LINK_TYPE(trs.GetLinkFlags())) && (res == TEST)) ||
				((PAK_LINK_TYPE(trs.GetLinkFlags())) && (res == ATTEND)) ||
				((trs.GetLinkFlags() == TRS_LINK_OLA_NUMBER) && (OLA_BY_CONTROLLER))
				)
			{
				*pTrsNumber = trs.m_lNumber;
			}

			else
			{
				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("Res %d,  Current Trs found %d, Trs type not match reservation !!!", res, trs.m_lNumber);
					m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
				}

				bFound = FALSE;
			}
		}
		// M.L 12.7.98  End 


		// first find out if there is current trs ( in progress one)
		if (!bFound)
		{	// not found  - create new one

			// if pump reserve to PRE_PAY_AT_POS
			// then find the WAIT_PROGRESS trs get the number ,				

			// if pump reserve to PAY_AT_PUMP then return the 
			// IN PROGRESS,Link OLA number

			// if pump reserve to NULL_RES then return the 
			// WAIT_PROGRESS trs number

			// if pump reserved to 	PAY_AT_KIOSK or ATTEND or TEST 
			// then generate new trs number , and set
			// trs status to - WAIT_PROGRESS.

			// if pump reserve to PAY_AT_OPT and server 
			// is master on OPT 
			// then find the WAIT_PROGRESS trs get the number ,



			switch (res)
			{
			case PRE_PAY_AT_POS:
				//============================================================
			{

				if ((m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS, TRS_LINK_PREPAY_NUMBER, &trs)) ||
					(m_cPumpArray[p].GetTrsByStatus(WAIT_AUTH, TRS_LINK_PREPAY_NUMBER, &trs)) || // ) //4.0.5.34
					((m_cPumpArray[p].GetTrsByStatus(WAIT_TIME_OUT, TRS_LINK_PREPAY_NUMBER, &trs)) && (lResExt == RES_EXT_CASH_ACCEPTOR)))  //4.0.10.504
				{  // found						
					*pTrsNumber = trs.m_lNumber;
				}
				else
				{
					CMD_STRUCT_RELEASE_PUMP cmdInfo;
					cmdInfo.lRes = res;
					cmdInfo.lResExt = lResExt; // unknown
					SetCommand(CMD_RELEASE_PUMP, SERVER_POS_NUMBER, lPumpNumber, &cmdInfo, sizeof(CMD_STRUCT_RELEASE_PUMP));

					retCode = GCI_TRS_NOT_FOUND;
				}
			}
			break;

			case PAY_AT_KIOSK:
			case TEST:
			case ATTEND:
				//============================================================
			{
				//4.0.1.32
				if ((lResExt == RES_EXT_ATTENDANT) && (m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS, TRS_LINK_ATTEND, &trs)))
				{
					*pTrsNumber = trs.m_lNumber;
				}
				else if (m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS, TRS_NO_LINK, &trs))
				{ // found
					*pTrsNumber = trs.m_lNumber;
				}
				else
				{
					if (!m_bControllerGenTrsNumber)
					{
						short nPrePayWaiting, nFree, nUnpaid;
						m_cPumpArray[p].GetTrsListCount(&nPrePayWaiting, &nFree, &nUnpaid);

						if (nUnpaid >= MAX_ALLOWED_UNPAID_TRS(p))
						{
							retCode = GCI_PUMP_TRS_LIST_IS_FULL;
						}
						//4.0.11.390
						else if (IS_SERVER_IN_MIDDLE_LOCK_SHIFT)
						{
							retCode = GCI_SERVER_IN_MIDDLE_LOCK_SHIFT;
						}
						else
						{
							// 
							// Creating a new Pay At Kiosk transaction 
							// ---------------------------------------
							CPumpTransact trs(NewTransactNumber(), m_cPumpArray[p].GetShiftNumber());
							trs.SetStatus(WAIT_PROGRESS);	// first state of PAK trs: WAIT_PROGRESS
							trs.m_lPump = lPumpNumber;
							trs.m_sLoyaltyDiscountApplied = ' ';


							// M.L 8/5/98 Lock PumpArray in large scope 
							int iRetNum = CentralInsertTrs(lPumpNumber, &trs);
							switch (iRetNum)
							{
							case 0:
								*pTrsNumber = trs.m_lNumber;

								retCode = GCI_OK;
								break;
							case 1:
								retCode = GCI_PUMP_TRS_LIST_IS_FULL;
								break;
							case 4:
								retCode = GCI_TRS_NOT_FOUND;
								break;
							}


							//4.0.25.1140 TD 412765
							if ((retCode == GCI_OK) && (TRUE == trs.IsTrsPumpTestOrCalib()))
							{
								UpdatePakPumpTestExtraInfo(lPumpNumber, &trs);
							}
						}

					}
					else
						retCode = GCI_TRS_NOT_FOUND;
				}
			}
			break;

			case PAY_AT_PUMP:
				//============================================================
			{
				if ((m_cPumpArray[p].GetTrsByStatus(WAIT_PROGRESS, TRS_LINK_OLA_NUMBER, &trs)) ||
					(m_cPumpArray[p].GetTrsByStatus(INCOMPLETE, TRS_LINK_OLA_NUMBER, &trs)))   //4.0.10.45

				{  // found
					*pTrsNumber = trs.m_lNumber;
				}
				else
				{

					//4.0.11.390
					if (IS_SERVER_IN_MIDDLE_LOCK_SHIFT)
					{
						retCode = GCI_SERVER_IN_MIDDLE_LOCK_SHIFT;
					}
					else if (OLA_BY_CONTROLLER)
					{
						CPumpTransact trs(NewTransactNumber(), m_cPumpArray[p].GetShiftNumber());
						trs.SetLink(TRS_LINK_OLA_NUMBER, 0);
						trs.SetStatus(WAIT_PROGRESS);	// first state of : WAIT_PROGRESS
						trs.m_lPump = lPumpNumber;
						trs.m_sLoyaltyDiscountApplied = ' ';

						// M.L 8/5/98 Lock PumpArray in large scope 
						int iRetNum = CentralInsertTrs(lPumpNumber, &trs);
						switch (iRetNum)
						{
						case 0:
							*pTrsNumber = trs.m_lNumber;
							retCode = GCI_OK;
							break;
						case 1:
							retCode = GCI_PUMP_TRS_LIST_IS_FULL;
							break;
						case 4:
							retCode = GCI_TRS_NOT_FOUND;
							break;
						}
					}
					else
						retCode = GCI_TRS_NOT_FOUND;
				}
			}
			break;

			case NULL_RES:
				//============================================================
			{
				//4.0.20.500
				retCode = GCI_TRS_NOT_FOUND;

				//Speciall treatment for Postec CL - on switches in the middle of dispensing it starts with Ready Null res.
				//If there were dispensing transaction during the switch - it needs the IN_PROGRESS PAK trs number even in NULL_RES...
				CPumpTransact trs;
				if (m_cPumpArray[p].GetTrsByStatus(IN_PROGRESS, TRS_LINK_ANY, &trs))
				{
					if ((trs.GetRes() == PAY_AT_KIOSK) && ((trs.m_lRoundedValue > 0) || (trs.m_lRoundedVolume > 0)))
					{
						// found
						*pTrsNumber = trs.m_lNumber;
						retCode = GCI_OK;
						if (LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Res %d, Found IN_PROGRESS PAY_AT_KIOSK Trs %ld, !!!", res, trs.m_lNumber);
							m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str, LOG_LEVEL_1);
						}
					}
					else if (trs.GetRes() == PRE_PAY_AT_POS) //4.0.20.500 - TD 65887
					{
						// found
						*pTrsNumber = trs.m_lNumber;
						retCode = GCI_OK;
						if (LOG_BASIC_FLOW_CONTROL)
						{
							CString str;
							str.Format("Res %d, Found IN_PROGRESS PRE_PAY_AT_POS Trs %ld, !!!", res, trs.m_lNumber);
							m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str, LOG_LEVEL_1);
						}
					}
				}
			}
			break;
			}
		}


		// M.L 8/5/98 Lock PumpArray in large scope 
		//-----------------------------------------
	}


	if (LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetCurrentTransactionNumber return %d", *pTrsNumber);
		m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
	}



	if (retCode != GCI_PUMP_TRS_LIST_IS_FULL)
		if (retCode)
			if (LOG_LOGIC_ERROR)
				m_cLogger.LogResult(
				0, // Src
				"IGCI",
				"GetCurrentTransactionNumber",
				TRUE, retCode,
				FALSE, 0);


	if (pVal != NULL)
		*pVal = retCode;
}


void CServerMain::DoAutomaticPriceProtectionCheck__()
{
	try
	{
		DoAutomaticPriceProtectionCheck();
	}
	catch (...)
	{
		if (LOG_ERROR)
			m_cLogger.LogMsg("CServerMain::DoAutomaticPriceProtectionCheck__()", LOG_LEVEL_0);
		exit(1);
	}
}

void CServerMain::DoAutomaticPriceProtectionCheck()
{
	if (m_lPriceProtectionActive)
	{
		SYSTEMTIME st;
		GetLocalTime(&st);
		CTime	cCurTime(st);

		if (cCurTime.GetHour() >= m_lPriceProtectionStart / 100 && cCurTime.GetHour() <= m_lPriceProtectionEnd / 100)
		{
			if ((cCurTime.GetMinute() >= m_lPriceProtectionStart % 100 || cCurTime.GetHour() > m_lPriceProtectionStart / 100) &&
				(cCurTime.GetMinute() < m_lPriceProtectionEnd % 100 || cCurTime.GetHour() < m_lPriceProtectionEnd / 100))
			{
				if (m_lPriceProtectionActive != PRICE_PROTECTION_ACTIVE_INSIDE_TIME_FRAME)
				{
					m_cLogger.LogMsg("Price protection mechanism activated");
				}

				m_lPriceProtectionActive = PRICE_PROTECTION_ACTIVE_INSIDE_TIME_FRAME;
			}
			else
			{
				if (m_lPriceProtectionActive != PRICE_PROTECTION_ACTIVE_OUTSIDE_TIME_FRAME)
				{
					m_cLogger.LogMsg("Price protection mechanism deactivated");
				}

				m_lPriceProtectionActive = PRICE_PROTECTION_ACTIVE_OUTSIDE_TIME_FRAME;
			}
		}
		else
		{
			if (m_lPriceProtectionActive != PRICE_PROTECTION_ACTIVE_OUTSIDE_TIME_FRAME)
			{
				m_cLogger.LogMsg("Price protection mechanism activated");
			}

			m_lPriceProtectionActive = PRICE_PROTECTION_ACTIVE_OUTSIDE_TIME_FRAME;
		}

		SetLowestPriceToCurrentPrice(st);
	}
}


void CServerMain::SetLowestPriceToCurrentPrice(SYSTEMTIME st)
{
	CTime	cCurTime(st);

	// Is midnight
	if ((cCurTime.GetHour() == 0) &&
		(cCurTime.GetMinute() == 0) &&
		(cCurTime.GetSecond() == 0))
	{
		DWORD dwTmp = 0;
		CString str, sTable("Grades\\Grade"), sTableMaxGrade("Grades");
		char sNumber[8];

		long lGradePriceLevel = GetGradePriceProtectionLevel();

		for (int i = 1; i <= MAX_GRADES_99; i++)
		{
			memset(sNumber, 0, sizeof(sNumber));

			sprintf_s(sNumber, _countof(sNumber), "%02d", i);
			str = sTable + sNumber;

			dwTmp = GetInitialGradePrice(lGradePriceLevel, i);

			m_cParam.SaveParam((char *)((LPCTSTR)str), "Day_Lowest_Price", (DWORD)dwTmp, TRUE, 0, 0, 0, TRUE);
			SetGradePriceToArray(i, dwTmp, PRICE_PROTECTION_LOWEST_PRICE);
		}

		m_cLogger.LogMsg("Setting the lowest price to the current price");
	}
}

void CServerMain::SetGradePriceToArray(long lGrade, long lPrice, long lPriceType)
{
	if (lGrade > 0)
		m_lGradePriceArray[lGrade - 1][lPriceType] = lPrice;

#ifdef DEBUG
	CString sMsg;
	sMsg.Format("SetGradePriceToArray() - lGrade %ld, lPrice %ld, lPriceType %ld", lGrade, lPrice, lPriceType);
	m_cLogger.LogMsg(sMsg);
#endif
}

long CServerMain::GetLowestGradePriceFromArray(long lGrade)
{
	long lPrice = 0;

	if (lGrade > 0)
	{
		long lPriceA = m_lGradePriceArray[lGrade - 1][0];
		lPriceA = MIN(lPriceA, m_lGradePriceArray[lGrade - 1][1]);
		lPriceA = MIN(lPriceA, m_lGradePriceArray[lGrade - 1][2]);
		lPriceA = MIN(lPriceA, m_lGradePriceArray[lGrade - 1][3]);
//		lPriceA = MIN(lPriceA, m_lGradePriceArray[lGrade - 1][4]);  don't include lowest price ptotection..
		lPrice = lPriceA;
	}

	CString sMsg;
	sMsg.Format("GetLowestGradePriceFromArray() - lGrade %ld, lPrice %ld all grades: %ld,%ld,%ld,%ld, (%ld lowest price protection..) ", lGrade, lPrice, m_lGradePriceArray[lGrade - 1][0], m_lGradePriceArray[lGrade - 1][1], m_lGradePriceArray[lGrade - 1][2], m_lGradePriceArray[lGrade - 1][3], m_lGradePriceArray[lGrade - 1][4]);
	if (LOG_ALL_FLOW_CONTROL)
		m_cLogger.LogMsg(sMsg);

	return lPrice;
}


long CServerMain::GetHighestGradePriceFromArray(long lGrade)
{
	long lPrice = 0;

	if (lGrade > 0)
	{
		long lPriceA = m_lGradePriceArray[lGrade - 1][0];
		lPriceA = MAX(lPriceA, m_lGradePriceArray[lGrade - 1][1]);
		lPriceA = MAX(lPriceA, m_lGradePriceArray[lGrade - 1][2]);
		lPriceA = MAX(lPriceA, m_lGradePriceArray[lGrade - 1][3]);
		lPriceA = MAX(lPriceA, m_lGradePriceArray[lGrade - 1][4]);
		lPrice = lPriceA;
	}
#ifdef DEBUG
	CString sMsg;
	sMsg.Format("GetHighestGradePriceFromArray() - lGrade %ld, lPrice %ld", lGrade, lPrice);
	if (LOG_ALL_FLOW_CONTROL)
		m_cLogger.LogMsg(sMsg);
#endif

	return lPrice;
}


long CServerMain::GetGradePriceFromArray(long lGrade, long lPriceType)
{
	long lPrice = 0;

	if (lGrade > 0)
		lPrice = m_lGradePriceArray[lGrade - 1][lPriceType];

	CString sMsg;
	sMsg.Format("GetGradePriceFromArray() - lGrade %ld, lPrice %ld, lPriceType %ld", lGrade, lPrice, lPriceType);
	m_cLogger.LogMsg(sMsg);

	return lPrice;
}


BOOL CServerMain::BuildPriceProtectionDiscounts(long lPumpNumber, long* lDiscountArray)
{
	BOOL bRetCode = FALSE;

	if (GetPriceProtectionActive() == PRICE_PROTECTION_ACTIVE_INSIDE_TIME_FRAME)
	{
		long lPrice = 0,
			lLowestPrice = 0;

		m_lGradePriceArray[5][0] = 0;

		if (m_bControllerSupportNozzleRestrction)
		{
			long lTmpGrade = 0;

			for (int i = 0; i <= MAX_POSITIONS_PER_PUMP; i++)
			{
				lTmpGrade = m_cPumpArray[lPumpNumber - 1].NozzleToGrade(i + 1);

				if ((lTmpGrade > 0) && (lTmpGrade <= MAX_GRADES))
				{
					lPrice = GetGradePriceFromArray(lTmpGrade, GetGradePriceProtectionLevel());
					lLowestPrice = GetGradePriceFromArray(lTmpGrade, PRICE_PROTECTION_LOWEST_PRICE);

					long lDiscount = (lPrice - lLowestPrice) > 0 ? (lPrice - lLowestPrice) : 0;
					lDiscountArray[i] += ValidateDiscount(lPrice, lDiscount, GetGradePriceMinimumLimit());

					if (lDiscount) 
					{
						bRetCode = TRUE;
					}

					CString str;
					str.Format("Pump %02ld - BuildPriceProtectionDiscounts(): lTmpGrade = %ld, lDiscount = %ld, lPrice %ld, lLowestPrice %ld", lPumpNumber, lTmpGrade, lDiscountArray[lTmpGrade], lPrice, lLowestPrice);
					m_cLogger.LogMsg(str);
				}
			}
		}
		else
		{
			for (int i = 0; i < MAX_GRADES; i++)
			{
				lPrice = GetGradePriceFromArray(i + 1, GetGradePriceProtectionLevel());
				lLowestPrice = GetGradePriceFromArray(i + 1, PRICE_PROTECTION_LOWEST_PRICE);

				long lDiscount = (lPrice - lLowestPrice) > 0 ? (lPrice - lLowestPrice) : 0;
				lDiscountArray[i] += ValidateDiscount(lPrice, lDiscount, GetGradePriceMinimumLimit());
				
				if (lDiscount) 
				{
					bRetCode = TRUE;
				}
			}

			CString str;
			str.Format("Pump %02ld - BuildPriceProtectionDiscounts(): Discount Grade01=%ld,Grade02=%ld,Grade03=%ld,Grade04=%ld,Grade05=%ld,Grade06=%ld,Grade07=%ld,Grade08=%ld,Grade09=%ld,Grade10=%ld",
				lPumpNumber,
				lDiscountArray[0],
				lDiscountArray[1],
				lDiscountArray[2],
				lDiscountArray[3],
				lDiscountArray[4],
				lDiscountArray[5],
				lDiscountArray[6],
				lDiscountArray[7],
				lDiscountArray[8],
				lDiscountArray[9]);

			m_cLogger.LogMsg(str);
		}
	}

	return bRetCode;
}

BOOL CServerMain::BuildPriceProtectionDiscounts(long lPumpNumber, PAY_AT_PUMP_INFO *info)
{
	BOOL bRetCode = FALSE;

	if (GetPriceProtectionActive() == PRICE_PROTECTION_ACTIVE_INSIDE_TIME_FRAME)
	{
		long lPrice = 0,
			lLowestPrice = 0;

		m_lGradePriceArray[5][0] = 0;

		if (m_bControllerSupportNozzleRestrction)
		{
			long lTmpGrade = 0;

			for (int i = 0; i <= MAX_POSITIONS_PER_PUMP; i++)
			{
				lTmpGrade = m_cPumpArray[lPumpNumber - 1].NozzleToGrade(i + 1);

				if ((lTmpGrade > 0) && (lTmpGrade <= MAX_GRADES))
				{
					lPrice = GetGradePriceFromArray(lTmpGrade, GetGradePriceProtectionLevel());
					lLowestPrice = GetGradePriceFromArray(lTmpGrade, PRICE_PROTECTION_LOWEST_PRICE);

					long lDiscount = a2l(info->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount, sizeof(DISCNT));
					if (lDiscount < 0)
						lDiscount = 0;

					lDiscount += (lPrice - lLowestPrice) > 0 ? (lPrice - lLowestPrice) : 0;

					lDiscount = ValidateDiscount(lPrice, lDiscount, GetGradePriceMinimumLimit());

					l2a(lDiscount, info->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount, sizeof(DISCNT));

					if (lDiscount > 0) {
						l2a(DISCOUNT_CENTS_PG, &info->CardSaleExtraData2.sGRDiscountType, sizeof(info->CardSaleExtraData2.sGRDiscountType));
					}

					if (lDiscount) 
					{
						bRetCode = TRUE;
					}

					CString str;
					str.Format("Pump %02ld - BuildPriceProtectionDiscounts(PAY_AT_PUMP_INFO): lTmpGrade = %ld, lDiscount = %ld, lPrice %ld, lLowestPrice %ld", lPumpNumber, lTmpGrade, lDiscount, lPrice, lLowestPrice);
					m_cLogger.LogMsg(str);
				}
			}
		}
		else
		{
			for (int i = 0; i < MAX_GRADES; i++)
			{
				lPrice = GetGradePriceFromArray(i + 1, GetGradePriceProtectionLevel());
				lLowestPrice = GetGradePriceFromArray(i + 1, PRICE_PROTECTION_LOWEST_PRICE);

				long lDiscount = a2l(info->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount, sizeof(DISCNT));
				if (lDiscount < 0)
					lDiscount = 0;

				lDiscount += (lPrice - lLowestPrice) > 0 ? (lPrice - lLowestPrice) : 0;

				lDiscount = ValidateDiscount(lPrice, lDiscount, GetGradePriceMinimumLimit());

				l2a(lDiscount, info->CardSaleExtraData2.sDiscountPerGrade[i].sDiscount, sizeof(DISCNT));

				if (lDiscount) 
				{
					bRetCode = TRUE;
				}
			}

			CString str;
			str.Format("BuildPriceProtectionDiscounts(PAY_AT_PUMP_INFO*info): Discount Grade01=%s,Grade02=%s,Grade03=%s,Grade04=%s,Grade05=%s,Grade06=%s,Grade07=%s,Grade08=%s,Grade09=%s,Grade10=%s",
				info->CardSaleExtraData2.sDiscountPerGrade[0].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[1].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[2].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[3].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[4].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[5].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[6].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[7].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[8].sDiscount,
				info->CardSaleExtraData2.sDiscountPerGrade[9].sDiscount);

			m_cLogger.LogMsg(str);
		}
	}

	return bRetCode;
}


long CServerMain::GetGradePriceMinimumLimit()
{
	return m_lGradePriceMinimumLimit * 10;
}


void CServerMain::SetGradePriceMinimumLimit(long lGradePriceMinimumLimit)
{
	m_lGradePriceMinimumLimit = lGradePriceMinimumLimit;
}


long CServerMain::ValidateDiscount(long lGradePrice, long lDiscount, long lMinimumGradePrice)
{
	long lFinalDiscount = 0;
	long lTempPrice = lGradePrice;

	if (lTempPrice > lMinimumGradePrice)
	{
		if (lTempPrice - lDiscount > lMinimumGradePrice || lMinimumGradePrice == 0)
		{
			lFinalDiscount = lDiscount;
		}
		else
		{
			lFinalDiscount = lTempPrice - lMinimumGradePrice;
		}
	}
	else
	{
		lFinalDiscount = 0;
	}

	return lFinalDiscount;
}


void CServerMain::HandlePunchhAlternateIDfailure(long lPumpNumber, OLA_STAT * pOla, PAY_AT_PUMP_INFO * cInfo)
{
	switch (cInfo->CardSaleInfo.cardData.sTranStatus)
	{
	case CD_DECLINE_DECLINED:
	case CD_DECLINE_NONET:
	{
		if (_Module.m_server.m_dwLoyaltyClubNumberRetry)
		{
			if (cInfo->CardSaleExtraData6.sIdRetryCount < (_Module.m_server.m_dwLoyaltyClubNumberRetry + '0'))
			{
				_Module.m_server.m_cFlowControlManager.SetPumpSrvAddMemberCardRes(lPumpNumber, LOYALTY_STATE_PUNCHH_ERROR);

				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("HandleAlternateIDfailure  first failure Punchh", lPumpNumber);
					_Module.m_server.m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
				}
			}
			else
			{
				memset(cInfo->CardSaleInfo.extraData.sLoyalId, ' ', sizeof(cInfo->CardSaleInfo.extraData.sLoyalId));
				cInfo->CardSaleExtraData4.sLoyaltyEntryMethod = ' ';

				if (LOG_BASIC_FLOW_CONTROL)
				{
					CString str;
					str.Format("HandleAlternateIDfailure second failure Punchh", lPumpNumber);
					_Module.m_server.m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, str);
				}
			}
		}
	}
	break;
	case CD_DECLINE_NOHOST:  // accept member as host is off line - need to send set_cust_info 
	{
		//			cInfo->CardSaleInfo.cardData.sTranStatus =  CD_APPROVE_OK;

		if (LOG_BASIC_FLOW_CONTROL)
		{
			CString str;
			str.Format("Pump  %02ld HandleAlternateID offline ", lPumpNumber);
			m_cLogger.LogMsg(str);
		}
	}
	default:
		break;
	}

	cInfo->CardSaleInfo.cardData.sTranStatus = CD_APPROVE_OK;
}

void CServerMain::ResetPriceChangedFlags()
{
	long lMaxGrades = GetMaxValidGradeNumber();

	for (int j = 0; j < lMaxGrades; j++)
		m_GradeData.SetGradePriceChanged(j + 1, FALSE);
}

long CServerMain::AdjustPriceProtectionDiscount(long & lGRDiscount, CPumpTransact *pTrs)
{
	if (pTrs->m_sLoyaltyPriceProtection == '1')  //4.0.23.2561
	{
		long lOriginalPrice = GetGradePriceFromArray(pTrs->m_nGrade, GetGradePriceProtectionLevel());

		if (GetGradePriceMinimumLimit() == pTrs->m_lGradePrice)
		{
			if (pTrs->m_lLowestGradePrice > GetGradePriceMinimumLimit())
			{
				lGRDiscount = pTrs->m_lLowestGradePrice - GetGradePriceMinimumLimit();
			}
			else
			{
				lGRDiscount = 0;
			}
		}
		else if (pTrs->m_lGradePrice == pTrs->m_lLowestGradePrice)
		{
			lGRDiscount = 0; // discount apply due to lowest price 
		}
		else if (pTrs->m_lGradePrice < pTrs->m_lLowestGradePrice)
		{
			lGRDiscount = pTrs->m_lLowestGradePrice - pTrs->m_lGradePrice;
		}

		if (LOG_DETAIL_FLOW_CONTROL)
		{
			CString str;
			str.Format("Pump %02ld - Price reported = %ld, Lowest price = %ld, m_nNozzle = %d, lGRDiscount = %ld", pTrs->m_lPump, pTrs->m_lGradePrice, pTrs->m_lLowestGradePrice, pTrs->m_nNozzle, lGRDiscount);
			m_cLogger.LogMsg(str);
		}
	}

	return 0;
}


//RFUEL-3194 (task RFUEL-3257) limit minimal unit price after loyalty discounts are applied to according to lowest price
DWORD CServerMain::GetInitialGradeHighestPrice(short nGrade)
{
	DWORD dwPrice_SELF_CASH, dwPrice_FULL_CASH, dwPrice_FULL_CREDIT, dwPrice_SELF_CREDIT, dwRetPrice;
	CString str("Grades\\Grade");
	char sNumber[8];
	memset(sNumber, 0, sizeof(sNumber));
	sprintf_s(sNumber, _countof(sNumber), "%02d", nGrade);
	str += sNumber;
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_SelfService",   &dwPrice_SELF_CASH	, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //SELF_CASH:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_FullService",   &dwPrice_FULL_CASH	, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);  //FULL_CASH:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_SelfService", &dwPrice_SELF_CREDIT, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //SELF_CREDIT:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_FullService", &dwPrice_FULL_CREDIT	, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //FULL_CREDIT
	dwRetPrice = MAX(dwPrice_SELF_CASH, dwPrice_FULL_CASH);
	dwRetPrice = MAX(dwRetPrice, dwPrice_FULL_CREDIT);
	dwRetPrice = MAX(dwRetPrice, dwPrice_SELF_CREDIT);
	if (LOG_ALL_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetInitialGradeHighestPrice() Grade %d,  lowest price %ld  prices are:%ld,%ld,%ld,%ld ", nGrade, dwRetPrice,dwPrice_SELF_CASH,dwPrice_FULL_CASH,dwPrice_SELF_CREDIT,dwPrice_FULL_CREDIT);
		_LOGMSG.LogMsg(str);
	}
	return dwRetPrice;
}


//RFUEL-3194
DWORD CServerMain::GetInitialGradeLowestPrice(short nGrade)
{
	DWORD dwPrice_SELF_CASH, dwPrice_FULL_CASH, dwPrice_FULL_CREDIT, dwPrice_SELF_CREDIT, dwRetPrice;
	CString str("Grades\\Grade");
	char sNumber[8];
	memset(sNumber, 0, sizeof(sNumber));
	sprintf_s(sNumber, _countof(sNumber), "%02d", nGrade);
	str += sNumber;
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_SelfService", &dwPrice_SELF_CASH, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //SELF_CASH:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_FullService", &dwPrice_FULL_CASH, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);  //FULL_CASH:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_SelfService", &dwPrice_SELF_CREDIT, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //SELF_CREDIT:
	m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_FullService", &dwPrice_FULL_CREDIT, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE); //FULL_CREDIT
	dwRetPrice = MIN(dwPrice_SELF_CASH, dwPrice_FULL_CASH);
	dwRetPrice = MIN(dwRetPrice, dwPrice_FULL_CREDIT);
	dwRetPrice = MIN(dwRetPrice, dwPrice_SELF_CREDIT);
	if (LOG_BASIC_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetInitialGradeLowestPrice() Grade %d,  lowest price %ld  prices are:%ld,%ld,%ld,%ld ", nGrade, dwRetPrice, dwPrice_SELF_CASH, dwPrice_FULL_CASH, dwPrice_SELF_CREDIT, dwPrice_FULL_CREDIT);
		_LOGMSG.LogMsg(str);
	}
	return dwRetPrice;
}


DWORD CServerMain::GetInitialGradePrice(long lPriceLevel, short nGrade )
{
	DWORD dwPrice;

	CString str("Grades\\Grade");

	char sNumber[8];
	memset(sNumber, 0, sizeof(sNumber));
	sprintf_s(sNumber, _countof(sNumber), "%02d", nGrade);
	str += sNumber;

	switch (lPriceLevel)
	{
	case SELF_CASH:
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_SelfService", &dwPrice, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		break;
	case FULL_CASH:
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCash_FullService", &dwPrice, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		break;
	case SELF_CREDIT:
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_SelfService", &dwPrice, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		break;
	case FULL_CREDIT:
		m_cParam.LoadParam((char *)((LPCTSTR)str), "New_PriceCredit_FullService", &dwPrice, (DWORD)0, TRUE, TRUE, 0, HOP_DIRECT_LOCAL, TRUE);
		break;
	case LOWEST_PRICE:
		dwPrice = GetInitialGradeLowestPrice(nGrade);
		break;
	case HIGHEST_PRICE:
	default:
		dwPrice = GetInitialGradeHighestPrice(nGrade);
		break;
	}

	if (LOG_FCC_FLOW_CONTROL)
	{
		CString str;
		str.Format("GetInitialGradePrice() Grade %d, lPriceLevel %d, price %ld", nGrade, lPriceLevel, dwPrice);
		_LOGMSG.LogMsg(str);
	}

	return dwPrice;
}

//4.0.25.1140 TD 412765
void CServerMain::UpdatePakPumpTestExtraInfo(long lPumpNumber, CPumpTransact *pTrs)
{
	PAY_AT_PUMP_INFO cPayPumpInfo;
	EXTRA_INFO		cExtraInfo;

	memset(&cExtraInfo, ' ', sizeof(EXTRA_INFO));
	_Module.m_server.m_cPumpArray[lPumpNumber - 1].GetPAPInfo(&cPayPumpInfo);

	pTrs->SetLink(pTrs->GetLinkFlags() + TRS_LINK_EXTRA_INFO, pTrs->m_lNumber);

	//Create record in Extra Info QDX										
	cExtraInfo.lIndexNumber = pTrs->m_lNumber;

	memcpy(cExtraInfo.sReferenceNumber, cPayPumpInfo.CardSaleInfo.cardData.sReferenceNumber, sizeof(cPayPumpInfo.CardSaleInfo.cardData.sReferenceNumber));

	memset(cPayPumpInfo.CardSaleInfo.cardData.sReferenceNumber, ' ', sizeof(cPayPumpInfo.CardSaleInfo.cardData.sReferenceNumber));
	_Module.m_server.m_cPumpArray[lPumpNumber - 1].SetPAPInfo(&cPayPumpInfo);

	long lRtc = _Module.m_server.IndexOperation(EXTRA_INFO_FILE, REC_INSERT, &cExtraInfo);

	if (LOG_DETAIL_FLOW_CONTROL)
	{
		CString sLogMsg;
		sLogMsg.Format("Insert extra info PAK test mode record (Trs %d, Status %d, link Number %d, RetCode=%ld)",
			pTrs->m_lNumber,
			pTrs->m_lStatus,
			pTrs->m_lLinkNumber,
			lRtc);
		_Module.m_server.m_cLogger.LogMsg(lPumpNumber, LOG_PUMP, sLogMsg);
	}
}


//RFUEL - 2817
long CServerMain::GetTenderDiscount(const PAY_AT_PUMP_INFO& Info) const {
	long lTenderDiscount = 0L;
	try {
		const CARD_SALE_DATA*		   pCardData = &(Info.CardSaleInfo.cardData);

		constexpr size_t DISCOUNT_SIZE = sizeof(Info.CardSaleExtraData6.sTenderDiscount);
		lTenderDiscount = a2l(Info.CardSaleExtraData6.sTenderDiscount, DISCOUNT_SIZE);

		// make sure the discount is least 0
		lTenderDiscount = std::max<long>(lTenderDiscount, 0L);
	}
	catch (...)
	{		
		CString Msg;
		Msg.Format("%s - %s", __FUNCTION__, "Exception Thown");
		_LOGMSG.LogMsg(Msg);
	}

	return lTenderDiscount;
}


//RFUEL - 2817
long CServerMain::GetPaymentDiscount(const PAY_AT_PUMP_INFO& Info) const {
	long lGRDiscount = 0L;
	try {
		const CARD_SALE_DATA*		   pCardData = &(Info.CardSaleInfo.cardData);

		constexpr size_t DISCOUNT_SIZE = sizeof(pCardData->sGRDiscountPerGallon);
		lGRDiscount = a2l(pCardData->sGRDiscountPerGallon, DISCOUNT_SIZE);

		// make sure the discount is least 0
		lGRDiscount = std::max<long>(lGRDiscount, 0L);
		if (LOG_DETAIL_FLOW_CONTROL)
		{
			CString sLogMsg;
			sLogMsg.Format("%s DISCOUNT:  sGRDiscountPerGallon=%d", __FUNCTION__, lGRDiscount);
			_LOGMSG.LogMsg(sLogMsg);
		}
	}
	catch (...)
	{
		CString Msg;
		Msg.Format("%s - %s", __FUNCTION__, "Exception Thown");
		_LOGMSG.LogMsg(Msg);
	}

	return lGRDiscount;
}

//RFUEL - 2817
long CServerMain::FinalLoyaltyDiscount(PAY_AT_PUMP_INFO& Info, long lPumpNumber, long lGradeIndex, long lAdditionalDiscount) 
{		
	long lFinalDiscount = 0L;

	try {
		const CARD_SALE_EXTRA_DATA2_  *pCardDataExtra2 = &(Info.CardSaleExtraData2);

		const long lGrade = lGradeIndex + 1;
		// Get Grade Postion (1 based)
		long lGradePos = 0; //_Module.m_server.GetGradePositionRestrection(lGrade, lPumpNumber);
		lGradePos = lGradeIndex;

		// position is index 0 based, subtract 1 
		//lGradePos = (lGradePos > 0L) ? (lGradePos - 1) : 0L;

		constexpr size_t DISCOUNT_SIZE = sizeof(pCardDataExtra2->sDiscountPerGrade[lGradePos].sDiscount);
		long lLoyaltyDiscount = a2l(pCardDataExtra2->sDiscountPerGrade[lGradePos].sDiscount, DISCOUNT_SIZE);
		lLoyaltyDiscount = std::max<long>(lLoyaltyDiscount, 0L);

		// Add additional discount
		long lFinalDiscount = lLoyaltyDiscount + lAdditionalDiscount;

		// Disabled ???????
		// Decided not to implement the minimum limit from this location
		//const bool bMinPriceActive = _Module.m_server.m_cFuelLoayaltyPS.GetMinLoyaltyUnitPriceIsActive();
		const bool bMinPriceActive = false;
		if (bMinPriceActive) {
			// This is the minimal price we want to enforce
			const long lMinLimitPrice = _Module.m_server.m_cFuelLoayaltyPS.GetMinLoyaltyUnitPrice();
			
			// pull the Grade price
			const long lGradePrice = GetInitialGradeLowestPrice((short)lGrade);

			// Calculate what would be a discount price, if it does not violate minimal requirement
			const long lDiscountedPrice = lGradePrice - lFinalDiscount;

			// if not meeting miminal price requirement
			if (lDiscountedPrice < lMinLimitPrice) {
				// calculate max discount we can give
				const long MaxDiscount = lGradePrice - lMinLimitPrice;

				lFinalDiscount = MaxDiscount;
				if (LOG_ALL_FLOW_CONTROL) {
					LogStream LogMsg;
					LogMsg << __FUNCTION__ << " - Adjusting Discount to Max allowed=" << MaxDiscount << ends;
					_LOGMSG.LogMsg(LogMsg);
				}
			}
		}

		l2a(lFinalDiscount, (unsigned char*)pCardDataExtra2->sDiscountPerGrade[lGradePos].sDiscount, DISCOUNT_SIZE);		
		if (LOG_ALL_FLOW_CONTROL) {
			LogStream LogMsg;
			LogMsg << __FUNCTION__ << " - Before=" << lLoyaltyDiscount
				<< " After=" << lFinalDiscount
				<< " Added Discount Amount=" << lAdditionalDiscount
				<< std::ends;
			_LOGMSG.LogMsg(LogMsg);
		}
	}
	catch (...)
	{
		LogStream LogMsg;
		LogMsg << __FUNCTION__ << "Exception Thrown" << std::ends;
		_LOGMSG.LogMsg(LogMsg, LOG_LEVEL_1);
	}

	return lFinalDiscount;
}


//RFUEL - 2817
long CServerMain::GetLoyaltyDiscount(const PAY_AT_PUMP_INFO& Info, long lPumpNumber, long lGrade) const
{
	long lLoyaltyDiscount = 0L;
	try {
		const CARD_SALE_EXTRA_DATA2_  *pCardDataExtra2 = &(Info.CardSaleExtraData2);

		// Get Grade Postion (1 based)
		long lGradePos = _Module.m_server.GetGradePositionRestrection(lGrade, lPumpNumber);

		// position is index 0 based, subtract 1 
		lGradePos = (lGradePos > 0L) ? (lGradePos - 1) : 0L;

		constexpr size_t DISCOUNT_SIZE = sizeof(pCardDataExtra2->sDiscountPerGrade[lGradePos].sDiscount);
		lLoyaltyDiscount = a2l(pCardDataExtra2->sDiscountPerGrade[lGradePos].sDiscount, DISCOUNT_SIZE);

		// cannot allow negative discount
		lLoyaltyDiscount = std::max<long>(lLoyaltyDiscount, 0L);
	}
	catch (...)
	{		
		LogStream LogMsg;
		LogMsg << __FUNCTION__ << "Exception Thrown" << std::ends;
		_LOGMSG.LogMsg(LogMsg, LOG_LEVEL_1);
	}

	return lLoyaltyDiscount;
}


void CServerMain::SetPaymentDiscount(PAY_AT_PUMP_INFO& Info, int lDiscount) const {
	// Set DiscountPerGallon to lDiscount
	constexpr size_t DISCOUNT_SIZE = sizeof(Info.CardSaleInfo.cardData.sGRDiscountPerGallon);
	BYTE* const pGRDiscountPerGallon = &Info.CardSaleInfo.cardData.sGRDiscountPerGallon[0];

	if (lDiscount == 0) {
		std::fill(pGRDiscountPerGallon, pGRDiscountPerGallon + DISCOUNT_SIZE, ' ');
	}
	else {
		l2a(lDiscount, pGRDiscountPerGallon, DISCOUNT_SIZE);
	}

	if (LOG_ALL_FLOW_CONTROL) {
		string sReportingData = std::string(pGRDiscountPerGallon, pGRDiscountPerGallon + DISCOUNT_SIZE);
		CString str;
		str.Format("%s - Setting sGRDiscountPerGallon to %s",
			__FUNCTION__, sReportingData.c_str());
		_LOGMSG.LogMsg(str);
	}
}


//RFUEL-3028
bool CServerMain::CheckRealtimeDB(long lPumpNumber) const {
	CPumpSrvDatabase& PumpSrvDatabase = CPumpSrvDatabase::GetInstance();

	// check for connection
	const bool bDBConnection = DBConnectionAvailable() ? true : false;

	PAY_AT_PUMP_INFO papInfo;

	// no need to memset as we just want to test the IO and not going to use the data
	//memset(&papInfo, 0, sizeof(PAY_AT_PUMP_INFO));

	// check for access
	const bool bDBAccess = bDBConnection && 
		PumpSrvDatabase.LoadPayAtPumpInfo(papInfo, lPumpNumber);

	// if database access is Good
	if (bDBAccess) {
		// if we have alarm set, end it and set the flag
		if (SentDBAlarm()) {		
			_Module.m_server.AlarmSrv().AddSendMessage(CATEGORY_SOFTWARE, 
				SUB_DATABASE, SQl_DB_NOT_RUNNING, 0, ALARM_ENDED, 0, 0);
			_Module.m_server.SetDBAlaram(FALSE);
		}
		else {
			; // No action required
		}
	}
	else {
		// No database access, if we already set the alarm, do nothing
		if (SentDBAlarm()) {
			; // No action required
		} else {
			// Set Alarm and flag
			_Module.m_server.AlarmSrv().AddSendMessage(CATEGORY_SOFTWARE, 
				SUB_DATABASE, SQl_DB_NOT_RUNNING, 0, ALARM_STARTED, 0, 0);
			_Module.m_server.SetDBAlaram(TRUE);
		}
	}

	return bDBAccess;
}
